/**
 * @license
 * Copyright 2022 Thought Stream, LLC dba Bluescape
 * Permission is hereby granted, free of charge, to any person obtaining a copy 
 * of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, 
 * subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS 
 * OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
*/

/** 
 * Purpose:
 *  This demo app will upload assets (Images, Videos or Documents) into an existing Canvas in a workspace, using Bluescape REST APIs.
 *  The app will calculate the insertion point for the new assets, and will verify if there is enough space
 *  inside the Canvas to upload the assets. If not, the app will check if the Canvas bottom can be extended
 *  to make enough space for the upload of the new assets. It also verifies that the new space under the Canvas 
 *  is empty, to avoid loading the new assets over elements already present in the workspace.
 * 
 * Usage:
 *      node upload-content-into-existing-canvas.REST.js --token=<token> --workspaceId=<workspaceId>
 *          --uploadMethod=<'URL'|'LOCAL'> --canvasId=<canvasId>
 *          [--pathToFiles='<path-to-assets-to-upload>/'] (when --uploadMethod='LOCAL')
 *          [--assetsToUploadByUrl='<tab-delimited-list-if-urls-pointing-to-assets-to-upload>'] (when --uploadMethod='URL')
 * Requirements:
 *   - To install all the required libraries, run 'npm install' in both this folder and the ../bluescape-modules folder.
 *   - ffprobe needs to be installed in your system.
 *       - this is used to determine the height and width of the videos before uploading them into the workspace
 *       - Check https://www.npmjs.com/package/ffprobe-static#version-notes for the version to be installed.
 *       - You need to set the path to your local install of ffprobe in the ffprobePath variable in this script.
 *
 * Example of required parameters to use
 *  --uploadMethod=<'URL'|'LOCAL'>
 *  --pathToFiles='/Users/littlejohnny/assets/to-upload/'
 *  --assetsToUploadByUrl='https://s3.amazonaws.com/webclienttest.bluescape.com/share/images/landscape.jpg|https://s3.amazonaws.com/webclienttest.bluescape.com/share/images/18.jpg' 
 * 
 * Notes:
 *  To run this app against the entire instance requires that the token be
 *  generated by a user with Instance Admin privileges. A regular user can
 *  run the app when limiting the search to an Organization or Workspace,
 *  provided they can supply the necessary Id value.
 * 
 *  To obtain a token you can follow the instructions in the Application
 *  Authorization Guide found in the Developer Portal:
 *          https://api.apps.us.bluescape.com/docs/page/app-auth
 * 
 *  The Workspace Id can be obtained from the URL displayed in the browser.
 *  When you open a workspace the Id is the first value following the domain.
 *  For example, this URL includes the Workspace Id "bbKg00aNOelot2SkYno0":
 *    https://client.apps.us.bluescape.com/bbKg00aNOelot2SkYno0
 * 
*/

import fs from 'fs';
import Yargs from "yargs";
import { runRestRequest } from '../bluescape-modules/bluescapeApis.js';
import { uploadAssetByUrlIntoCanvasRest } from '../bluescape-modules/uploadAssetByURL.js';
import getAssetDimensionsInsideExistingCanvas, { filterAndPreProcessAssets, getPositionForAssetInCanvasRest, getYCoordinateToUploadNewAssets } from '../bluescape-modules/uploadUtils.js';
import { uploadAssetFromLocalIntoCanvasRest } from '../bluescape-modules/uploadAssetFromLocal.js'
import isEqual from 'lodash.isequal';

// APP PARAMETERS
const args = Yargs(process.argv.slice(2)).argv;
const apiURL = 'https://api.apps.us.bluescape.com';
const apiVersion = 'v3';
const workspaceId = args.workspaceId ?? '<SET_WORKSPACE_ID>';
const canvasId = args.canvasId ?? '<CANVAS-ID>';
const token = args.token ?? '<SET_TOKEN>';
const localFilesPath = args.pathToFiles ?? '<SET_FULL_PATH_TO_YOUR_LOCAL_FOLDER>'; // Remember to add the final '/' to the path
const uploadMethod = args.uploadMethod ?? "<SET_UPLOAD_METHOD>"; // "URL" or "LOCAL"
const assetsToUploadByURL = args.assetsToUploadByUrl ? args.assetsToUploadByUrl.split('|') : "<LIST_OF_TAB_DELIMITED_URLs>".split('|');
const ffprobePath = '/usr/local/bin/ffprobe'; // Example: '/usr/local/bin/ffprobe' (depends on where it is installed in your system) 

// DEFAULT ASSETS' WIDTH AND HEIGHT
const DEFAULT_ASSET_WIDTH = 1500;
const DEFAULT_ASSET_HEIGHT = 1500;

// DEFAULT SPACING BETWEEN ASSETS TO UPLOAD
const VERTICAL_SPACING = 100;
const HORIZONTAL_SPACING = 100;


/*
    Canvas object, measurements are in pixels
    This object is used to:
    1. Provide the properties of the Canvas to be created: width, height, position.
    2. Provide properties for the spacing of the uploaded assets  
    3. Keep track of the insertion point for the next asset to be uploaded (insertX,insertY )
 */
let canvasElement = {
    "id": "",
    "canvasX": 0,
    "canvasY": 0,
    "insertX": 100,
    "insertY": 100,
    "horizontalSpacing": 100,
    "verticalSpacing": 100,
    "maximumHeightInRow": 0,
    "canvasInitialWidth": 0,
    "canvasInitialHeight": 0
}

// Object to store the parameters for Bluescape API execution 
const bluescapeApiParams = {
    'token': token,
    'apiPortalUrl': apiURL,
    'apiVersion': apiVersion
}

/**
 * Uploads a list of assets to an existing canvas.
 * @param {Object} bluescapeApiParams - Object containing the data for executing Bluescape APIs
 * @param {string} bluescapeApiParams.token -  Access Token (oauth2 token, see https://api.apps.us.bluescape.com/docs/page/app-auth)
 * @param {string} bluescapeApiParams.apiPortalUrl - URL to the portal to execute the APIs, e.g. "https://api.apps.us.bluescape.com/api"
 * @param {string} bluescapeApiParams.apiVersion - Version of the APIs to be executed, e.g.: "v3". Current version: v3
 * 
 * @param {Object} parameterValues - Values to use in this function
 * @param {Object} parameterValues.canvasElement - Properties of the Canvas where the assets will be uploaded
 * @param {string} parameterValues.canvasElement.id - Id of the Canvas
 * @param {number} parameterValues.canvasElement.canvasX - X coordinate of the Canvas
 * @param {number} parameterValues.canvasElement.canvasY - Y coordinate of the Canvas
 * @param {number} parameterValues.canvasElement.insertX - Variable to calculate the X position of the assets in the Canvas
 * @param {number} parameterValues.canvasElement.insertY - Variable to calculate the Y position of the assets in the Canvas
 * @param {number} parameterValues.canvasElement.canvasInitialWidth - Initial width of the Canvas
 * @param {number} parameterValues.canvasElement.canvasInitialHeight - Initial height of the Canvas
 * @param {number} parameterValues.canvasElement.initialYInsertionValue - Initial Y coordinate where start inserting elements, it is under the element closest to the bottom of the Canvas. 
 * @param {('URL'|'LOCAL')} parameterValues.uploadMethod - Upload method to use for uploading the assets
 * @param {string} parameterValues.ffprobePath - Path to ffprobe, to calculate the width and height of video assets
 * @param {string} parameterValues.workspaceId - Workspace Id of workspace where the assets will be uploaded
 * @param {Object} parameterValues.defaultAssetDimensions - Object with default width and height to set to an asset if those values cannot be read directly from the asset 
 * @param {number} parameterValues.defaultAssetDimensions.DEFAULT_ASSET_WIDTH - Default width for an asset
 * @param {number} parameterValues.defaultAssetDimensions.DEFAULT_ASSET_HEIGHT - deafult height for an asset
 * @param {Object} parameterValues.spacingBetweenAssets - Object with values for default spacing between assets, and from the Canvas border when they are uploaded into the canvas in a grid like display
 * @param {number} parameterValues.spacingBetweenAssets.VERTICAL_SPACING - Vertical spacing between assets and from assets to the top and bottom borders of the canvas
 * @param {number} parameterValues.spacingBetweenAssets.HORIZONTAL_SPACING - Horizontal spacing between assets and from the left and right borders of the canvas
 * 
 * @returns {Object} Object with the data for the asset attemped to be uploaded and the result of the upload process
 * @returns {Object} object.newAsset - Object containing data for the asset that was attempted to be uploaded
 * @returns {('video'|'image'|'document')} object.newAsset.[assetType] - Type of the newly created asset: 'video', 'image' or 'document'.It is an object that contains the id of the created element in the workspace 
 * @returns {string} object.newAsset.[assetType].id - Id of the newly created element
 * @returns {Object} object.newAsset.uploadResult - Object with the data for the result of the upload process
 * @returns {('success'|'failure')} object.newAsset.uploadResult.result - Result of the upload process: 'success' or 'failure'
 * @returns {string} object.newAsset.uploadResult.assetPath - Path or full URL of the asset
*/
async function addAssetsToExistingCanvas(bluescapeApiParams, parameterValues) {

    // Minimum spacing between assets and bewtween assets and Canvas borders
    const HORIZONTAL_SPACING = parameterValues?.spacingBetweenAssets?.HORIZONTAL_SPACING ?? 100;
    const VERTICAL_SPACING = parameterValues?.spacingBetweenAssets?.VERTICAL_SPACING ?? 100;

    // Default width and height if those values cannot be retrieved
    const DEFAULT_ASSET_WIDTH = parameterValues?.defaultAssetDimensions?.DEFAULT_ASSET_WIDTH ?? 1500;
    const DEFAULT_ASSET_HEIGHT = parameterValues?.defaultAssetDimensions?.DEFAULT_ASSET_HEIGHT ?? 1500;

    const uploadMethod = parameterValues.uploadMethod;
    const assetsToUploadList = parameterValues.assetsToUploadList;

    const getAssetsDimensionsPromisesArray = [];
    let canvasElement = parameterValues.canvasElement;

    assetsToUploadList.map((assetFileData) => {
        const fileData = assetFileData;

        const assetURL = fileData.assetName;

        const assetType = fileData.assetType;
        const assetExtension = fileData.assetExtension;

        const getAssetDimensionsParams = {
            uploadMethod,
            assetType,
            assetExtension,
            canvasElement,
            assetName: fileData.assetName,
            'assetLocation': assetURL,
            ffprobePath,
            defaultAssetDimensions: {
                DEFAULT_ASSET_WIDTH,
                DEFAULT_ASSET_HEIGHT
            },
            spacingBetweenAssets: {
                VERTICAL_SPACING,
                HORIZONTAL_SPACING
            },
        }

        getAssetsDimensionsPromisesArray.push(getAssetDimensionsInsideExistingCanvas(getAssetDimensionsParams));

    });

    // Execute the process to get the dimensions for each asset
    const assetsDimensions = await Promise.all(getAssetsDimensionsPromisesArray);

    /*
        Calculate the position of the assets in the Canvas.
        The assets will be uploaded starting on the far left border of the canvas,
        and then adding the new one at the right of the previous one. If the width of the asset to upload
        does not fit on the remaining space on the current virtual row, then we start a new virtual row on
        the left border of the canvas.
        This process needs to be done one by one as the final asset position depends on its width and height, 
        and on the position of the previously processed asset.
    */
    const dataForUploadsArray = [];
    let bottomYCoordinateOfAreaNeededToInsertNewAssets = 0;
    for (let assetbyLocalData of assetsDimensions) {

        const assetTitle = assetbyLocalData.assetName;;
        const assetType = assetbyLocalData.assetType;
        const assetExtension = assetbyLocalData.assetExtension;

        const fileFullPath = assetbyLocalData.assetFileFullPath;

        const assetData = {
            'width': assetbyLocalData.assetWidth,
            'height': assetbyLocalData.assetHeight
        }

        // Using shorthand notation for fields with the same name as the variables: -> workspaceId is interpreted as "workspaceId": workspaceId 
        const getAssetPositionParams = {
            workspaceId,
            canvasElement,
            assetData,
            'canvasId': canvasElement.id,
            'extradata': canvasElement
        }

        // Get position where the asset asset will be uploaded, in absolute coordinates.
        const positionForAsset = await getPositionForAssetInCanvasRest(getAssetPositionParams);

        const x = positionForAsset.x;
        const y = positionForAsset.y;
        canvasElement = positionForAsset.canvasElement; // Get the updated properties of the Canvas (maybe height changed)

        // Get total height of the required space to insert all elements
        if (positionForAsset.y + assetData.height > bottomYCoordinateOfAreaNeededToInsertNewAssets) {
            bottomYCoordinateOfAreaNeededToInsertNewAssets = positionForAsset.y + assetData.height;
        }

        // This is the data needed to upload the asset in a specific position inside the Canvas
        const assetToUploadData = {
            workspaceId,
            "assetFullPath": fileFullPath,
            "assetURL": assetbyLocalData.assetLocation,
            assetData,
            assetType,
            assetExtension,
            assetTitle,
            "canvasId": canvasElement.id,
            x,
            y
        }

        // Store the insertion point coordinates for uploading the assets
        // Storing the data here as it is easier than to try to cancel all the promises for upload of assets if there is not enough space to upload the assets.
        dataForUploadsArray.push(assetToUploadData);
    }
    // Check if we have enough space to insert the new assets
    // Check space inside canvas, if there is enough space for uploading all the assets 
    const verticalNeededSpaceForInsertingNewAssets = bottomYCoordinateOfAreaNeededToInsertNewAssets - canvasElement.initialYInsertionValue;
    const bottomSpaceAvailableInsideCanvas = Math.abs(canvasElement.canvasY + canvasElement.canvasInitialHeight - canvasElement.initialYInsertionValue);

    console.log('Checking space for the new assets...')
    const uploadAssetsPromisesArray = [];
    let proceedWithUpload = true;

    if (verticalNeededSpaceForInsertingNewAssets > bottomSpaceAvailableInsideCanvas) {
        // There is not enough space inside the canvas to upload all the new elements
        // We will check if the Canvas bottom can be extended to accommodate the new assets.

        const extraSpaceNeededUnderCanvas = verticalNeededSpaceForInsertingNewAssets - bottomSpaceAvailableInsideCanvas + VERTICAL_SPACING;

        // Use findAvailableArea API call to check if there is enough available space under the Canvas,
        //  we do not want to put the new assets over other already existing content

        // proposedArea.y: added 10 pixels of padding to start just under the bottom of the Canvas
        const findAvailableAreaParams = {
            workspaceId,
            'direction': 'Down',
            'proposedArea': {
                'height': Math.floor(canvasElement.canvasInitialHeight + extraSpaceNeededUnderCanvas),
                'width': Math.floor(canvasElement.canvasInitialWidth),
                'x': Math.floor(canvasElement.canvasX),
                'y': Math.floor(canvasElement.canvasY + canvasElement.canvasInitialHeight + 10)
            }
        }

        const findAreaForNewAssetsUnderCanvasAnswer = await findAreaForNewAssetsUnderCanvasRest(bluescapeApiParams, findAvailableAreaParams);

        // Compare the area we proposed with the area found from the API execution. No change means there is enough space available for the assets to upload.
        if (isEqual(findAvailableAreaParams.proposedArea, findAreaForNewAssetsUnderCanvasAnswer.data)) {

            const extendCanvasBottomParams = {
                workspaceId,
                'canvasNewHeight': canvasElement.canvasInitialHeight + extraSpaceNeededUnderCanvas + VERTICAL_SPACING,
                'canvasId': canvasElement.id
            }

            const extendCanvasBottomAnswer = await extendCanvasBottomRest(bluescapeApiParams, extendCanvasBottomParams);

            if (extendCanvasBottomAnswer.status === 200) {

                // Canvas extension was successful, we can uplaod the assets
                proceedWithUpload = true;

            } else {
                throw `Error extending the bottom of the canvas, error: ${extendCanvasBottomAnswer.error}`;
            }
        } else {
            console.error('ERROR: There is not enough empty space below the canvas to add all the assets to upload. Try again providing a shorter list of assets.');
            return;
        }
    }

    if (proceedWithUpload === true) {

        // OK, let's upload the assets
        dataForUploadsArray.map((insertionPointDataForAsset) => {
            // Now that we have the position for the insertion of this asset, add its upload operation from local operation to the list of uploads to perform

            if (uploadMethod === 'URL') {
                // Upload from URL

                uploadAssetsPromisesArray.push(uploadAssetByUrlIntoCanvasRest(bluescapeApiParams, insertionPointDataForAsset));
            } else if (uploadMethod === 'LOCAL') {
                // Upload from LOCAL

                uploadAssetsPromisesArray.push(uploadAssetFromLocalIntoCanvasRest(bluescapeApiParams, insertionPointDataForAsset));
            } else {
                throw `uploadmethod value '${uploadMethod}' is not allowed`;
            }

        })

        // Do the upload of the assets:  we have the position, width & height and asset data for the upload
        const uploadProcessAnswer = await Promise.all(uploadAssetsPromisesArray);

        return uploadProcessAnswer;
    }
}


/** 
    * Creates report of the upload process, printed out in the console.
    * @param {Object} uploadData - Object with the data for the asset attempted to be uploaded and the result of the upload process
    * @param {Object} uploadData.newAsset - Object containing data for the asset that was attempted to be uploaded
    * @param {('video'|'image'|'document')} uploadData.newAsset.[assetType] - Type of the newly created asset: 'video', 'image' or 'document'. 
    *  It contains the id of the created element in the workspace 
    * @param {string} uploadData.newAsset.[assetType].id - Id of the newly created element
    * @param {Object} uploadData.newAsset.uploadResult - Object with data for the result of the upload process
    * @param {('success'|'failure')} uploadData.newAsset.uploadResult.result - Result of the upload process: 'success' or 'failure'
    * @param {string} uploadData.newAsset.uploadResult.assetPath - Path or full URL of the asset
    * 
    * @returns null
*/
async function generateUploadReport(uploadData) {

    const successfulUploads = [];
    const failedUploads = [];

    uploadData.map((uploadFromLocalResult) => {

        if (uploadFromLocalResult.newAsset.uploadResult.result === 'success') {
            successfulUploads.push(uploadFromLocalResult.newAsset.uploadResult.assetPath)
        } else {
            failedUploads.push(uploadFromLocalResult.newAsset.uploadResult.assetPath)
        }
    })

    const totalUploads = successfulUploads.length + failedUploads.length;

    console.log('-------------------------------------');
    console.log('UPLOAD REPORT');

    console.log(`Files attempted to upload: ${totalUploads}`);
    console.log(`   Successful uploads: ${successfulUploads.length} (${parseFloat((successfulUploads.length / totalUploads) * 100).toFixed(2)}%)`);
    successfulUploads.map((asset) => { console.log(`       ${asset} `) });
    console.log(`   Failed uploads: ${failedUploads.length} (${parseFloat((failedUploads.length / totalUploads) * 100).toFixed(2)}%)`);
    failedUploads.map((asset) => { console.log(`       ${asset} `) });

    return;
}
/**
 * Validates that mandatory arguments were supplied.
 */
function validateMandatoryArgs() {
    if (!token || token === "<SET_TOKEN>") {
        throw new ReferenceError("The token argument is required.");
    }

    if (!workspaceId || workspaceId === "<SET_WORKSPACE_ID>") {
        throw new ReferenceError("The workspaceId argument is required.");
    }

    if (!canvasId || canvasId === "<CANVAS-ID>") {
        throw new ReferenceError("The canvasId argument is required.");
    }

    if (!uploadMethod || uploadMethod === "<SET_UPLOAD_METHOD>") {
        throw new ReferenceError("The uploadMethod argument is required.");
    } else {
        if (uploadMethod !== 'URL' && uploadMethod !== 'LOCAL') {
            throw new ReferenceError("The uploadMethod argument must be 'URL' or 'LOCAL'.");
        }
        if (uploadMethod === 'URL' && (!assetsToUploadByURL || assetsToUploadByURL === '<LIST_OF_TAB_DELIMITED_URLs>'.split('|'))) {
            throw new ReferenceError("When using URL upload method, the assetsToUploadByURL argument is required");
        }
        if (uploadMethod === 'LOCAL' && (!localFilesPath || localFilesPath === '<SET_FULL_PATH_TO_YOUR_LOCAL_FOLDER>')) {
            throw new ReferenceError("When using upload from local drive method, the pathToFiles argument is required");
        }
    }
}

/**
 *  Extend the bottom of the canvas where the new assets will be uploaded
 * @param {Object} bluescapeApiParams - Object containing the data for executing Bluescape APIs
 * @param {string} bluescapeApiParams.token -  Access Token (oauth2 token, see https://api.apps.us.bluescape.com/docs/page/app-auth)
 * @param {string} bluescapeApiParams.apiPortalUrl - URL to the portal to execute the APIs, e.g. "https://api.apps.us.bluescape.com/api"
 * @param {string} bluescapeApiParams.apiVersion - Version of the APIs to be executed, e.g.: "v3". Current version: v3
 * 
 * @param {Object} functionParams - Object with the values to execute the function. 
 * @param {number} functionParams.canvasNewHeight - New height of the Canvas
 * @param {string} functionParams.workspaceId - Workspace Id where we are uploading the assets
 * @param {string} functionParams.canvasId - Canvas Id of the Canvas to modify
 * 
 * @returns {Object} Response body of the API execution
 */
async function extendCanvasBottomRest(bluescapeApiParams, functionParams) {

    const updateCanvasHeightPayload = {
        "type": "Canvas",
        "style": {
            "height": functionParams.canvasNewHeight
        }
    }
    const requestParamsUpdateCanvasRest = {
        'apiEndpoint': `/workspaces/${functionParams.workspaceId}/elements/${functionParams.canvasId}`,
        'requestMethod': 'PATCH',
        'dataLoad': updateCanvasHeightPayload
    }

    const canvasUpdate = await runRestRequest(bluescapeApiParams, requestParamsUpdateCanvasRest);
    if (canvasUpdate.status !== 200) {
        throw new Error(`Error extending canvas. Canvas Update: ${canvasUpdate?.error ?? canvasUpdate}`);
    }

    return canvasUpdate;
}

/**
 * Finds if the proposed area is empty or not. If not, finds the next available empty block using the specified direction ('Down' in this case).
 * @param {Object} bluescapeApiParams - Object containing the data for executing Bluescape APIs
 * @param {string} bluescapeApiParams.token -  Access Token (oauth2 token, see https://api.apps.us.bluescape.com/docs/page/app-auth)
 * @param {string} bluescapeApiParams.apiPortalUrl - URL to the portal to execute the APIs, e.g. "https://api.apps.us.bluescape.com/api"
 * @param {string} bluescapeApiParams.apiVersion - Version of the APIs to be executed, e.g.: "v3". Current version: v3
 * 
 * @param {Object} functionParams - Object with the values to execute the function. 
 * @param {string} functionParams.workspaceId - Workspace Id where we are uploading the assets
 * @param {('Up'|'Down'|'Left'|'Right')} functionParams.direction - Direction to use to find a new area if the Proposed area has elements inside it.
 * @param {Object} functionParams.proposedArea - Proposed area to search for empty space in the workspace
 * @param {Number} functionParams.proposedArea.x - X coordinate of the proposed area
 * @param {Number} functionParams.proposedArea.y - Y coordinate of the proposed area
 * @param {Number} functionParams.proposedArea.height - Height of the proposed area
 * @param {Number} functionParams.proposedArea.width - Width of the proposed area
 * 
 * @returns {Object} Response body of the API execution
 */
async function findAreaForNewAssetsUnderCanvasRest(bluescapeApiParams, functionParams) {

    const findAvailableAreaUnderCanvasParams = {
        'direction': functionParams.direction,
        'proposedArea': functionParams.proposedArea
    }

    const findAvailableAreaUnderCanvasParamsRest = {
        'apiEndpoint': `/workspaces/${functionParams.workspaceId}/findAvailableArea`,
        'requestMethod': 'POST',
        'dataLoad': findAvailableAreaUnderCanvasParams
    }

    const executionAnswer = await runRestRequest(bluescapeApiParams, findAvailableAreaUnderCanvasParamsRest);
    if (executionAnswer.status !== 200) {
        throw new Error(`Error running findAvailableArea for space under the canvas: ${executionAnswer?.error ?? executionAnswer}`);
    }

    return executionAnswer;

}

/** 
 *  Main Function.
 *  Bluescape sample app: upload assets into an existing Canvas in a workspace.
 *  The app will calcutate the insertion point for the new assets, and will verify if there is enough space
 *  inside the Canvas to upload the assets. If not, the app will check if the Canvas bottom can be extended
 *  to make enough space for the upload of the new assets. It also verifies that the new space under the canvas
 *  is empty, to avoid loading the new assets over elements already present in the workspace.  
 *  
 *  The upload can be from a local folder containing files to upload, or by a list of URLs pointing to assets to upload.
 *  Allowed extensions to upload into a workspace:
 *  - Images: jpeg, jpg, gif, png, tiff, tif
 *  - Documents: doc, docx, ppt, pptx, xls, xlsx, pdf
 *  - Videos: mp4, mov, m4v
*/
async function runAppExampleUploadAssetIntoExistingCanvasAndResizeCanvasRestApis() {

    try {

        validateMandatoryArgs();

        // STEP A: GET THE CANVAS PROPERTIES

        const getCanvasQueryParams = {
            'apiEndpoint': `/workspaces/${workspaceId}/elements/${canvasId}`,
            'requestMethod': 'GET',
            'dataLoad': {}
        }

        const getCanvasAnswer = await runRestRequest(bluescapeApiParams, getCanvasQueryParams);

        const canvasData = getCanvasAnswer?.data?.data ?? undefined

        if (canvasData) {
            // Load the values of the canvas into the canvasElement object
            canvasElement.canvasX = canvasData.transform.x
            canvasElement.canvasY = canvasData.transform.y;
            canvasElement.insertX = canvasData.transform.x + HORIZONTAL_SPACING;
            canvasElement.canvasInitialWidth = canvasData.style.width;
            canvasElement.canvasInitialHeight = canvasData.style.height;
            canvasElement.id = canvasData.id;
        } else {
            throw `Could not read properties for canvas Id ${canvasId}, please verify the Id and try again.`
        }

        const getYCoordinateToUploadNewAssetsParams = {
            workspaceId,
            canvasId,
            'canvasYCoordinate': canvasElement.canvasY,
            'verticalSpacing': canvasElement.verticalSpacing
        }

        // Get the Y coordinate insertion point for the new assets inside the Canvas, below the element closest to the bottom of the Canvas
        canvasElement.insertY = await getYCoordinateToUploadNewAssets(bluescapeApiParams, getYCoordinateToUploadNewAssetsParams) + canvasElement.verticalSpacing; // This value will be changed when calculating the position of the new assets 
        canvasElement.initialYInsertionValue = canvasElement.insertY; // We need to store the initial insertion point for later calculations

        const dataForAssetsUploadOnExistingCanvas = {
            canvasElement,
            uploadMethod,
            ffprobePath,
            workspaceId,
            defaultAssetDimensions: {
                DEFAULT_ASSET_WIDTH,
                DEFAULT_ASSET_HEIGHT
            },
            spacingBetweenAssets: {
                VERTICAL_SPACING,
                HORIZONTAL_SPACING
            }
        }

        console.log('Going to start the upload process...');

        // STEP B: UPLOAD CONTENT: URL OR FROM LOCAL DRIVE
        // RESIZE CANVAS IF NEEDED, EXTENDING ITS BOTTOM TO ADD THE NEW ASSETS

        if (uploadMethod === "URL") {
            // -----------------------
            // UPLOAD BY URL
            // -----------------------

            // Pre-filter the URLs, to process only the ones with valid extensions for uploading
            const preFilteredURLs = await filterAndPreProcessAssets(assetsToUploadByURL);

            // Add the list of URLS for upload to the  layoutImagesInGridParams object
            dataForAssetsUploadOnExistingCanvas.assetsToUploadList = preFilteredURLs

            const uploadFromUrlProcessAnswer = await addAssetsToExistingCanvas(bluescapeApiParams, dataForAssetsUploadOnExistingCanvas);

            // If nothing was uploaded, then uploadFromUrlProcessAnswer is empty 
            if (uploadFromUrlProcessAnswer) {
                await generateUploadReport(uploadFromUrlProcessAnswer);
            }

        }
        else if (uploadMethod === "LOCAL") {
            // -----------------------
            // UPLOAD FROM LOCAL
            // -----------------------

            fs.readdir(localFilesPath, async function (errorIssue, filesList) {
                if (errorIssue) {
                    return console.error(`ERROR: Unable to read directory "${localFilesPath}" . Issue: ${errorIssue}`);
                } else {
                    const filesListFullPath = [];
                    filesList.map((fileName) => {
                        filesListFullPath.push(`${localFilesPath}${fileName}`);
                    });

                    // Pre-filter the files, to process only the ones with valid extensions for uploading
                    const preFilteredFiles = await filterAndPreProcessAssets(filesListFullPath);

                    // Add the list of URLS for upload to the  layoutImagesInGridParams object
                    dataForAssetsUploadOnExistingCanvas.assetsToUploadList = preFilteredFiles;

                    const uploadFromLocalProcessAnswer = await addAssetsToExistingCanvas(bluescapeApiParams, dataForAssetsUploadOnExistingCanvas);

                    // If nothing was uploaded, then uploadFromUrlProcessAnswer is empty 
                    if (uploadFromLocalProcessAnswer) {
                        await generateUploadReport(uploadFromLocalProcessAnswer);
                    }
                }
            });

        } else {
            console.error("ERROR: upload method not recognized: ${uploadMethod}");
            console.error("Allowed values: URL or LOCAL");
        }

    } catch (error) {
        const buildErrorMessage = (e) =>
            `${e?.message ?? e} ${e?.extensions?.statusCode ? "(Status code: " + e.extensions.statusCode + ")" : ""} `;

        if (Array.isArray(error)) {
            console.error(`${error.length == 1 ? "An error" : "Errors"} occurred: `);
            for (const err of error) {
                console.error(buildErrorMessage(err));
            }
        }
        else {
            console.error(`An error occurred: ${buildErrorMessage(error)} `);
        }
        console.error(error?.stack ?? '');
    }
}

// Run the upload operation
runAppExampleUploadAssetIntoExistingCanvasAndResizeCanvasRestApis();
