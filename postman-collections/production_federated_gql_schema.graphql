type Query {
  # Returns a broadcast message by id
  broadcastMessage(broadcastMessageId: String!): BroadcastMessage!

  # Returns broadcast messages in a paged collection
  broadcastMessages(
    active: Boolean!
    cursor: String
    filtering: BroadcastMessageFilters
    ordering: [BroadcastMessageOrdering!]
    pagination: PaginationArgs
  ): BroadcastMessagesPaged!

  # Get a help menu
  helpMenu(
    # help menu Id
    id: String!
  ): HelpMenu!

  # Returns Help Menu in a paged collection
  helpMenus(
    cursor: String
    filtering: HelpMenuFilters
    ordering: [HelpMenuOrdering!]
    pagination: PaginationArgs
  ): HelpMenuPaged!

  # public: Returns an identity provider by id.
  identityProvider(
    # public: Identity provide id
    identityProviderId: String!
  ): IdentityProvider!

  # public: Returns a paginated collection of identity providers.
  identityProviders(
    # public: cursor
    cursor: String

    # public: filtering
    filtering: IdentityProviderFilters

    # public: ordering
    ordering: [IdentityProviderOrdering!]

    # public: pagination
    pagination: PaginationArgs
  ): IdentityProvidersPaged!

  # public: Get current user
  me: Me!

  # public: Get organization by Id
  organization(
    # public: Organization Id
    organizationId: String!
  ): Organization!

  # public: Get Organization list
  organizations(
    # public: cursor
    cursor: String

    # public: filtering
    filtering: OrganizationFilters

    # public: ordering
    ordering: [OrganizationOrdering!]

    # public: pagination
    pagination: PaginationArgs
  ): OrganizationsPaged!

  # public: A permission group selected by ID.
  permissionGroup(
    # public: Permission group ID
    permissionGroupId: String!
  ): PermissionGroup!

  # public: Pages list of permission groups.
  permissionGroups(
    # public: Cursor
    cursor: String

    # public: Filtering
    filtering: PermissionGroupFilters

    # public: Ordering
    ordering: [PermissionGroupOrdering!]

    # public: Pagination
    pagination: PaginationArgs
  ): PermissionGroupsPaged!

  # Returns permissions
  permissions(
    cursor: String
    filtering: PermissionFilters
    ordering: [PermissionOrdering!]
    pagination: PaginationArgs
  ): PermissionsPaged!

  # public: Get a role by Id.
  role(
    # public: Role Id
    roleId: String!
  ): Role!

  # public: Gets a listing of roles
  roles(
    # public: cursor
    cursor: String

    # public: filtering
    filtering: RoleFilters

    # public: ordering
    ordering: [RoleOrdering!]

    # public: pagination
    pagination: PaginationArgs
  ): RolesPaged!

  # Get all scratch workspaces belonging to the current user
  scratchWorkspaces(
    # cursor
    cursor: String

    # filtering
    filtering: ScratchWorkspaceFilters

    # ordering
    ordering: [ScratchWorkspaceOrdering!]

    # pagination
    pagination: PaginationArgs
  ): ScratchWorkspacesPaged!

  # Returns a template by id
  template(templateId: String!): Template!

  # Returns templates in a paged collection
  templates(
    cursor: String
    filtering: TemplateFilters
    ordering: [TemplateOrdering!]
    organizationId: ID!
    pagination: PaginationArgs
  ): TemplatePaged!

  # public: Get user by Id or email
  user(
    # public: Email
    email: String

    # public: User Id
    userId: String
  ): User!

  # public: Get users list
  users(
    # public: cursor
    cursor: String

    # public: last loggedin date
    filtering: UserFilters

    # public: ordering
    ordering: [UserOrdering!]

    # public: pagination
    pagination: PaginationArgs
  ): UsersPaged!

  # Returns a wall based upon the id
  wall(wallId: String!): Wall!

  # public: A paginated list of walls.
  walls(
    # public: cursor
    cursor: String

    # public: filters
    filtering: WallFilters

    # public: ordering options
    ordering: [WallOrdering!]

    # public: pagination
    pagination: PaginationArgs
  ): WallsPaged!

  # public: Get workspace by Id
  workspace(
    # public: Workspace Id
    workspaceId: String!
  ): Workspace!

  # public: Get workspace access request by ID
  workspaceAccessRequest(
    # public: The access request ID
    requestId: String!

    # public: The workspace ID
    workspaceId: String!
  ): WorkspaceAccessRequest!

  # public: Get workspace access request as a paginated list
  workspaceAccessRequests(
    # public: Cursor
    cursor: String

    # public: Filters
    filtering: WorkspaceAccessRequestFilters

    # public: Ordering
    ordering: [WorkspaceAccessRequestOrdering!]

    # public: Pagination
    pagination: PaginationArgs

    # public: The workspace ID
    workspaceId: String!
  ): WorkspaceAccessRequestPaged!

  # public: Get workspace lists
  workspaces(
    # public: archived
    archived: Boolean

    # public: cursor
    cursor: String

    # public: filtering Organization Id
    filtering: WorkspaceFilters

    # public: ordering
    ordering: [WorkspaceOrdering!]

    # public: pagination
    pagination: PaginationArgs
  ): WorkspacesPaged!
  workspaceState(
    workspaceId: String!

    # restrict output to elements with traits matching these traits
    traits: TraitInput

    # id of the canvas in which the elements are included
    canvasId: String

    # id of the element. When canvas is specified the element will exist in the bounds of the canvas
    id: String
    type: [ElementType!]
    overlaps: Viewport

    # retrieve element state as of the specified moment in time
    when: DateTime

    # include attachments in toplevel query results
    flatten: Boolean

    # id of the element. When specified, its origin point will be used to compute relative coordinates of other elements
    relativeToOriginOf: String
  ): WorkspaceState
  elementsWithMeta(
    workspaceId: String!

    # restrict output to elements with traits matching these traits
    traits: TraitInput

    # id of the canvas in which the elements are included
    canvasId: String

    # id of the element. When canvas is specified the element will exist in the bounds of the canvas
    id: String
    type: [ElementType!]
    overlaps: Viewport

    # retrieve element state as of the specified moment in time
    when: DateTime

    # include attachments in toplevel query results
    flatten: Boolean

    # id of the element. When specified, its origin point will be used to compute relative coordinates of other elements
    relativeToOriginOf: String
  ): WorkspaceState
    @deprecated(reason: "please use workspaceState query instead")
  elements(
    workspaceId: String!

    # restrict output to elements with traits matching these traits
    traits: TraitInput

    # id of the canvas in which the elements are included
    canvasId: String

    # id of the element. When canvas is specified the element will exist in the bounds of the canvas
    id: String
    type: [ElementType!]
    overlaps: Viewport

    # retrieve element state as of the specified moment in time
    when: DateTime

    # include attachments in toplevel query results
    flatten: Boolean

    # id of the element. When specified, its origin point will be used to compute relative coordinates of other elements
    relativeToOriginOf: String
  ): [Element]
  findAvailableArea(
    workspaceId: String!

    # Proposed starting area to begin search for available area in the workspace for a new object to be placed
    proposedArea: BoxInput!

    # Direction to move in during the search for available area (up, down, left, right)
    direction: FindAvailableAreaDirection = right
  ): Box
  _version: String

  # Retrieves invoice information
  invoices(organizationId: String!, sortOrder: SortOrder): [InvoiceInfo!]!

  # Retrieves invoice PDF link
  invoicePDF(organizationId: String!, invoiceId: String!): InvoicePDF!

  # Retrieves payment card information for an Organization from Chargebee
  paymentCard(organizationId: String!): PaymentCardInfo!

  # Retrieves plan information
  planInformation(
    planType: PlanTypeEnt!
    currency: CurrencyEnt = USD
  ): PlanInfo!

  # Retrieves estimated subscription plan price
  estimate(
    organizationId: String!
    planType: PlanTypeEnt!
    billingPeriod: SubscriptionIntervalEnt!
    licenseCount: Int!
    currency: CurrencyEnt = USD
  ): PriceEstimateResponse!

  # Retrieves estimated plan price for a new (non-existing) organization. Returns only the nextTermEstimate (preview of the estimated cost).
  estimateForNewOrganization(
    planType: PlanTypeEnt!
    billingPeriod: SubscriptionIntervalEnt!
    licenseCount: Int!
    billingAddress: AddressInput
    currency: CurrencyEnt = USD
  ): PriceEstimateNewOrganizationResponse!
}

type Mutation {
  # public: Add a member to Organization
  addMember(
    # public: AddMemberInput
    input: AddMemberInput!

    # public: Organization Id
    organizationId: String!
  ): Member!

  # public: Add a permission group to the role.
  addPermissionGroupsToRole(
    # public: Role Id
    RoleId: String!

    # public: AddPermissionGroupsToRoleInput
    input: AddPermissionGroupsToRoleInput!
  ): Role!

  # public: Add collaborator to workspace
  addWorkspaceCollaborator(
    # public: Add collaborator input
    input: AddCollaboratorInput!

    # public: workspaceId
    workspaceId: String!
  ): Collaborator!

  # Turn a scratch workspace into a workspace. Requires can_create_workspace permission in the organization and the email in the JWT token must match the email in the database
  claimScratchWorkspace(
    # public: Id of the organization to put the scratch workspace
    organizationId: String!

    # Scratch workspace id
    scratchWorkspaceId: String!
  ): Workspace!

  # Creates a new broadcast message
  createBroadcastMessage(input: CreateBroadcastMessageInput!): BroadcastMessage!

  # Creates a new org domain filter
  createDomainFilter(
    input: CreateOrgDomainFilterInput!
    organizationId: ID!
  ): [OrgDomainFilter!]!

  # public: Create favorite workspace
  createFavoriteWorkspace(
    # public: User Id
    userId: String!

    # public: Workspace Id
    workspaceId: String!
  ): Workspace!

  # Creates a new Helpmenu
  createHelpMenu(input: CreateHelpMenuInput!): HelpMenu!

  # public: Creates a new identity provider.
  createIdentityProvider(
    # public: CreateIdentityProviderInput
    input: CreateIdentityProviderInput!
  ): IdentityProvider!

  # Creates a new organization.
  createOrganization(input: CreateOrganizationInput!): Organization!

  # Creates a new verfication code
  createProvisioning(input: CreateVerficationCodeInput!): Provisioning!

  # public: Creates a new role.
  createRole(
    # public: createRole
    input: CreateRoleInput!
  ): Role!

  # Creates a new template.
  createTemplate(
    disableNameCheck: Boolean = false
    input: CreateTemplateInput!
  ): Template!

  # public: Create a new user
  createUser(
    # public: createUser
    input: CreateUserInput!
  ): User!

  # Creates a new wall
  createWall(input: CreateWallInput!): Wall!

  # public: Create new workspace
  createWorkspace(
    # public: createWorkspace
    input: CreateWorkspaceInput!
  ): Workspace!

  # public: Creates a workspace access request.
  createWorkspaceAccessRequest(
    # public: The workspace ID
    workspaceId: String!
  ): WorkspaceAccessRequest!

  # Deletes a broadcast message
  deleteBroadcastMessage(broadcastMessageId: ID!): Boolean!

  # Deletes Domain Filters.
  deleteDomainFilters(
    input: DeleteOrgDomainFilterInput!
    organizationId: String!
  ): Boolean!

  # public: Delete favorite workspace
  deleteFavoriteWorkspace(
    # public: User Id
    userId: String!

    # public: Workspace Id
    workspaceId: String!
  ): Boolean!

  # Delete Help menu
  deleteHelpMenu(helpMenuId: String!): Boolean!

  # public: Deletes an identity provider.
  deleteIdentityProvider(
    # public: Identity provider id
    identityProviderId: String!
  ): Boolean!

  # public: Delete Organization
  deleteOrganization(
    # public: When "isPermanentDelete" is true,
    #       1) A request to Collab to Delete Workspaces of the Organization is initiated
    #       2) The Organization and its relationships are Hard Deleted.
    #       When "isPermanentDelete" is false,
    #       1) Users who belong to only this organization are archived
    #       2) User Organization relationship is Soft deleted
    #       3) Organization is Soft Deleted.
    isPermanentDelete: Boolean!

    # public: ID of organization to delete.
    organizationId: String!
  ): Boolean!

  # public: Delete Organization Guests
  deleteOrganizationGuests(
    # public: Organization ID of organization to delete
    organizationId: String!
  ): Boolean!

  # public: Delete Organization Member
  deleteOrganizationMember(
    # public: DeleteMemberInput
    input: DeleteMemberInput!

    # public: ID of organization.
    organizationId: String!
  ): Boolean!

  # public: Deletes a permission group from a role.
  deletePermissionGroupFromRole(
    # public: Permission GroupId
    PermissionGroupId: String!

    # public: Role Id
    RoleId: String!
  ): Boolean!

  # public: Deletes a role.
  deleteRole(
    # public: Role Id
    RoleId: String!
  ): Boolean!

  # Delete the specified scratch workspace
  deleteScratchWorkspace(
    # Scratch workspace id
    scratchWorkspaceId: String!
  ): Boolean!

  # Deletes a template.
  deleteTemplate(templateId: ID!): Boolean!

  # public: Delete the user
  deleteUser(
    # public: Reassign the ownership of workspaces from the user being deleted to this user
    newWorkspaceOwnerId: ID

    # public: Delete all references to the user. This cannot be undone
    permanentDelete: Boolean

    # public: The id of the user to be deleted
    userId: ID!
  ): Boolean!

  # Deleted the specified wall
  deleteWall(deleteToken: String = null, wallId: String!): Boolean!

  # public: Delete workspace collaborator
  deleteWorkspaceCollaborator(
    # public: collaboratorId
    collaboratorId: String!

    # public: WorkspaceId
    workspaceId: String!
  ): Boolean!

  # public: Workspace access request denied.
  denyWorkspaceAccessRequest(
    # public: The access request ID
    requestId: String!

    # public: The workspace ID
    workspaceId: String!
  ): WorkspaceAccessRequest!

  # Creates a new verfication code
  getExchangeToken(
    input: VerificationCodeExchangeInput!
  ): VerificationCodeExchange!

  # Link an external subscription to the organization. This mutation should be called only when the external subscription is a Free Trial subscription.
  linkExternalFreeTrialSubscription(
    input: LinkExternalFreeTrialSubscriptionInput!
    organizationId: ID!
  ): FreeTrialSubscriptionInfo!

  # Link an external subscription to the organization. This mutation should be called only when the external subscription is a Paid Self Serve subscription.
  linkExternalSelfServeSubscription(
    input: LinkExternalSelfServeSubscriptionInput!
    organizationId: ID!
  ): SelfServeSubscriptionInfo!

  # Resend the verification code
  resendVerificationCode(
    input: ResendVerificationCodeExchangeInput!
  ): ResendVerificationCodeExchange!

  # Updates a broadcast message
  updateBroadcastMessage(
    broadcastMessageId: ID!
    input: UpdateBroadcastMessageInput!
  ): Boolean!

  # public: Update Collaborator Role
  updateCollaboratorRole(
    # public: Default Role Id
    defaultRoleId: String!

    # public: User Id
    userId: String!

    # public: Workspace Id
    workspaceId: String!
  ): Role!

  # Update Help menu
  updateHelpMenu(helpMenuId: String!, input: UpdateHelpMenuInput!): HelpMenu!

  # public: Updates an identity provider.
  updateIdentityProvider(
    # public: Identity Provider Id
    identityProviderId: String!

    # public: UpdateIdentityProviderInput
    input: UpdateIdentityProviderInput!
  ): IdentityProvider!

  # public: Update member's role
  updateMemberRole(
    # public: UpdateMemberRoleInput
    input: UpdateMemberRoleInput!

    # public: Member Id
    memberId: ID!

    # public: Organization Id
    organizationId: ID!
  ): Member!

  # public: Update the Organization
  updateOrganization(
    # public: UpdateOrganizationInput
    input: UpdateOrganizationInput!

    # public: Organization Id
    organizationId: String!
  ): Organization!

  # public: Updates a role.
  updateRole(
    # public: Role Id
    RoleId: String!

    # public: UpdateRoleInput
    input: UpdateRoleInput!
  ): Role!

  # Updates a subscription
  updateSubscription(
    externalSubscriptionId: String!
    input: UpdateSubscriptionInput!
  ): SubscriptionUnionType!

  # Updates a template.
  updateTemplate(
    disableNameCheck: Boolean = false
    input: UpdateTemplateInput!
    templateId: ID!
  ): Template!

  # public: Update the user
  updateUser(
    # public: UpdateUserInput
    input: UpdateUserInput!

    # public: User Id
    userId: String!
  ): User!

  # Update a wall
  updateWall(input: UpdateWallInput!, wallId: String!): Wall!

  # public: Update workspace
  updateWorkspace(
    # public: Update Workspace Input
    input: UpdateWorkspaceInput!

    # public: WorkspaceId
    workspaceId: String!
  ): Workspace!
  delete(id: String!, workspaceId: String!): Boolean!

  # Update traits of a workspace element
  updateTraits(
    # use as playground to test trait handling, does not add traits to history
    dryRun: Boolean = false

    # use the JSON-LD context specified in the input to compact the output
    compactOutput: Boolean = true

    # trait to add to the element
    input: TraitInput!

    # target workspace element id
    id: String!
    workspaceId: String!
  ): JSONObject!

  # Progress asset upload to processing
  processAsset(
    input: TransferCompleteInput!

    # asset upload id
    id: String!
    workspaceId: String!
  ): Boolean!

  # Update style of a workspace
  updateWorkspaceStyle(
    # new style of workspace
    input: UpdateWorkspaceStyleInput!
    workspaceId: String!
  ): UpdateWorkspaceStyleResponse!

  # Experimental: trait matching playground. Runs the trait matching algorithm on input traits and output its result. Does not change the workspace.
  matchTraits(
    # use the JSON-LD context specified in the input to compact the output
    compactOutput: Boolean = true

    # A JSON-LD frame describing a pattern to be matched in the input
    frame: TraitInput!

    # A JSON-LD document to match against
    input: TraitInput!
    workspaceId: String!
  ): JSONObject!

  # Add a comment to a workspace element
  createComment(
    # comment to add to the element
    input: CommentInput!

    # target workspace element id
    id: ID!
    workspaceId: String!
  ): Comment!
  createCanvas(
    # Id of the origin element. When specified the coordinates of a new element will be treated as relative to the origin point of that element
    relativeToOriginOf: String
    workspaceId: String!
    input: CreateCanvasInput!
  ): Canvas!
  updateCanvas(
    workspaceId: String!
    id: String!
    input: UpdateCanvasInput!
  ): UpdateElementResponse!
  createStroke(
    # Id of the origin element. When specified the coordinates of a new element will be treated as relative to the origin point of that element
    relativeToOriginOf: String
    workspaceId: String!
    input: CreateStrokeInput!
  ): Stroke!
  updateStroke(
    workspaceId: String!
    id: String!
    input: UpdateStrokeInput!
  ): UpdateElementResponse!
  createText(
    # Id of the origin element. When specified the coordinates of a new element will be treated as relative to the origin point of that element
    relativeToOriginOf: String
    workspaceId: String!
    input: CreateTextInput!
  ): Text!
  updateText(
    workspaceId: String!
    id: String!
    input: UpdateTextInput!
  ): UpdateElementResponse!
  createWindow(
    # Id of the origin element. When specified the coordinates of a new element will be treated as relative to the origin point of that element
    relativeToOriginOf: String
    workspaceId: String!
    input: CreateWindowInput!
  ): Window!
  updateWindow(
    workspaceId: String!
    id: String!
    input: UpdateWindowInput!
  ): UpdateElementResponse!
  createGrid(
    # Id of the origin element. When specified the coordinates of a new element will be treated as relative to the origin point of that element
    relativeToOriginOf: String
    workspaceId: String!
    input: CreateGridInput!
  ): Grid!
  updateGrid(
    workspaceId: String!
    id: String!
    input: UpdateGridInput!
  ): UpdateElementResponse!
  createVideo(
    # Id of the origin element. When specified the coordinates of a new element will be treated as relative to the origin point of that element
    relativeToOriginOf: String
    workspaceId: String!
    input: CreateVideoInput!
  ): CreateVideoResponse!
  updateVideo(
    workspaceId: String!
    id: String!
    input: UpdateVideoInput!
  ): UpdateElementResponse!
  createBrowser(
    # Id of the origin element. When specified the coordinates of a new element will be treated as relative to the origin point of that element
    relativeToOriginOf: String
    workspaceId: String!
    input: CreateBrowserInput!
  ): Browser!
  updateBrowser(
    workspaceId: String!
    id: String!
    input: UpdateBrowserInput!
  ): UpdateElementResponse!
  createImage(
    # Id of the origin element. When specified the coordinates of a new element will be treated as relative to the origin point of that element
    relativeToOriginOf: String
    workspaceId: String!
    input: CreateImageInput!
  ): CreateImageResponse!
  updateImage(
    workspaceId: String!
    id: String!
    input: UpdateImageInput!
  ): UpdateElementResponse!
  createDocument(
    # Id of the origin element. When specified the coordinates of a new element will be treated as relative to the origin point of that element
    relativeToOriginOf: String
    workspaceId: String!
    input: CreateDocumentInput!
  ): CreateDocumentResponse!
  updateDocument(
    workspaceId: String!
    id: String!
    input: UpdateDocumentInput!
  ): UpdateElementResponse!
  createShape(
    # Id of the origin element. When specified the coordinates of a new element will be treated as relative to the origin point of that element
    relativeToOriginOf: String
    workspaceId: String!
    input: CreateShapeInput!
  ): Shape!
  updateShape(
    workspaceId: String!
    id: String!
    input: UpdateShapeInput!
  ): UpdateElementResponse!
  createLine(
    # Id of the origin element. When specified the coordinates of a new element will be treated as relative to the origin point of that element
    relativeToOriginOf: String
    workspaceId: String!
    input: CreateLineInput!
  ): Line!
  updateLine(
    workspaceId: String!
    id: String!
    input: UpdateLineInput!
  ): UpdateElementResponse!

  # Cancel subscription for an organization.
  cancelSelfServeSubscription(
    organizationId: String!
  ): SelfServeSubscriptionInfoEnt!

  # Forces end of a trial period. Charges the customer for selected billing period and moves subscription to the active status
  convertToSelfServeSubscription(
    organizationId: String!
    licenseQuantity: Int!
    interval: SubscriptionIntervalEnt!
  ): SelfServeSubscriptionInfoEnt!

  # Add payment card using token for an organization
  updatePaymentCard(
    organizationId: String!
    paymentCardTokenId: String!
  ): PaymentCardInfo!

  # Provisions new free trial organization
  createFreeTrial(
    organizationName: String!
    teamName: String!
    intent: Intent!

    # Hubspot Info
    hubSpot: HubSpotInput
    planType: PlanTypeEnt!
  ): CreateFreeTrialResponse!

  # Create a Paid Subscription directly
  createSelfServeSubscription(
    organizationName: String!
    teamName: String!
    intent: Intent!
    planType: PlanTypeEnt!
    interval: SubscriptionIntervalEnt!
    licenseQuantity: Int!
    paymentCardTokenId: String!
    billingAddress: AddressInput!
    shippingAddress: AddressInput

    # Hubspot Info
    hubSpot: HubSpotInput
  ): CreateSelfServeSubscriptionResponse!

  # Obtains subscription info from CB and updates it in ISAM
  sync(organizationId: String!): SubscriptionUnionTypeEnt!

  # Update billing and shipping addresses. If shipping address is not provided, it is filled by the same fields as a billing one. Returns billing address.
  updateAddress(
    organizationId: String!
    billingAddress: AddressInput!
    shippingAddress: AddressInput
  ): Address!

  # Update subscription [Deprecated] - please use updateSelfServeSubscriptionLicenseQuantity mutation instead
  updateSelfServeSubscription(
    organizationId: String!
    licenseQuantity: Int
  ): SelfServeSubscriptionInfoEnt!

  # Update subscription license quantity
  updateSelfServeSubscriptionLicenseQuantity(
    organizationId: String!
    licenseQuantity: Int!
  ): SelfServeSubscriptionInfoEnt!

  # Update subscription billing cycle
  updateSelfServeSubscriptionBillingCycle(
    organizationId: String!
    billingCycle: SubscriptionIntervalEnt!
  ): SelfServeSubscriptionInfoEnt!

  # Recovers a Free Trial by linking an ISAM subscription to an already created Org, and submits the necessary tracking info to CB/SF + Hubspot
  recoverFreeTrial(
    organizationId: String!
    organizationName: String!
    ownerId: String!

    # Hubspot Info
    hubSpot: HubSpotInput!
    planType: PlanTypeEnt!
  ): Boolean!

  # Reactivate subscription (only FreeTrial so far) for an organization.
  reactivateSubscription(organizationId: String!): SelfServeSubscriptionInfoEnt!
}

type Subscription {
  # public: Returns an event when an identity provider is created
  IdentityProviderCreated: IdentityProviderPayloadCreated!

  # public: Returns an event when an identity provider is deleted
  IdentityProviderDeleted: IdentityProviderPayloadDeleted!

  # public: Returns an event when an identity provider is updated
  IdentityProviderUpdated: IdentityProviderPayloadUpdated!

  # public: Collaborator added event.
  addCollaborator(
    # public: Collaborator Added Subscription Options
    subscriptionOptions: CollaboratorAddedSubscriptionOptions
  ): CollaboratorAdded!

  # public: Organization member added events.
  addMember(
    # public: Member added subscription
    subscriptionOptions: MemberAddedSubscriptionOptions
  ): MemberAdded!

  # public: Role created events
  createRole(
    # public: Create role subscription
    subscriptionOptions: RoleCreatedSubscriptionOptions
  ): RoleCreated!

  # public: Workspace created events.
  createWorkspace: WorkspaceCreated!

  # public: Create workspace access request events.
  createWorkspaceAccessRequest(
    # public: Subscription options for create workspace access request events.
    subscriptionOptions: WorkspaceAccessRequestCreatedSubscriptionOptions
  ): WorkspaceAccessRequestCreated!

  # public: Role deleted events.
  deleteRole(
    # public: Role delete subscription
    subscriptionOptions: RoleDeletedSubscriptionOptions
  ): RoleDeleted!

  # public: Workspace duplication events.
  duplicateWorkspace(
    # public: Workspace duplicated subscription
    subscriptionOptions: WorkspaceDuplicatedSubscriptionOptions
  ): WorkspaceDuplicated!

  # public: User login events.
  login(
    # public: Login event subscription
    subscriptionOptions: UserLoginSubscriptionOptions
  ): UserLogin!

  # public: Workspace reassigned events
  reassignWorkspace(
    # public: Workspace reassigned event
    subscriptionOptions: WorkspaceReassignedSubscriptionOptions
  ): WorkspaceReassigned!

  # public: User registration events.
  registerUser: UserRegistered!

  # public: Collaborator Removed
  removeCollaborator(
    # public: collaborator Removed Event
    subscriptionOptions: CollaboratorRemovedSubscriptionOptions
  ): CollaboratorRemoved!

  # public: Organization member removed events.
  removeMember(
    # public: Member removed event subscription
    subscriptionOptions: MemberRemovedSubscriptionOptions
  ): MemberRemoved!

  # public: User resend activation events.
  resendActivation: UserResendActivation!

  # public: User passwors reset events.
  resetPassword: UserResetPassword!

  # public: Token revoke events.
  tokenRevoke: TokenRevoked!

  # public: Update collaborator role events
  updateCollaboratorRole(
    # public: subscriptionOptions
    subscriptionOptions: CollaboratorRoleChangedSubscriptionOptions
  ): CollaboratorRoleChanged!

  # public: Organization member role updated events.
  updateMemberRole(
    # public: Member role updated event
    subscriptionOptions: MemberRoleUpdatedSubscriptionOptions
  ): MemberRoleUpdated!

  # public: Role updated events.
  updateRole(
    # public: Role update subsription
    subscriptionOptions: RoleUpdatedSubscriptionOptions
  ): RoleUpdated!

  # public: User update events.
  updateUser(
    # public: Role Created Event Subscription
    subscriptionOptions: UserUpdatedSubscriptionOptions
  ): UserUpdated!

  # public: Workspace updated events
  updateWorkspace(
    # public: Workspace updated event
    subscriptionOptions: WorkspaceUpdatedSubscriptionOptions
  ): WorkspaceUpdated!

  # public: Update workspace access request events.
  updateWorkspaceAccessRequest(
    # public: Subscription options for update workspace access request events.
    subscriptionOptions: WorkspaceAccessRequestUpdateSubscriptionOptions
  ): WorkspaceAccessRequestUpdate!
  commands(
    workspaceId: String!

    # the cursor ID of last known command
    cursor: ID
    elementId: String
    elementType: [ElementType!]
  ): HistoryCommand!
  rawHistory(
    workspaceId: String!

    # the cursor ID of last known command
    cursor: ID
  ): RawCommand!
  changeMeetingHost(
    subscriptionOptions: MeetingHostChangedSubscriptionOptions
  ): MeetingHostChanged!
  workspaceMeetingAttendanceChange(
    subscriptionOptions: WorkspaceMeetingAttendanceChangedSubscriptionOptions
  ): WorkspaceMeetingAttendanceChanged!
  updateWaitingRoomStatus(
    subscriptionOptions: WaitingRoomStatusUpdatedSubscriptionOptions
  ): WaitingRoomStatusUpdated!
  reachRecordingFileLimit(
    subscriptionOptions: RecordingFileLimitReachedSubscriptionOptions
  ): RecordingFileLimitReached!
  recordingError(
    subscriptionOptions: RecordingErrorOccurredSubscriptionOptions
  ): RecordingErrorOccurred!
}

# public: Add collaborator input
input AddCollaboratorInput {
  # public: The Id of the User or Group to be added to this workspace
  id: String!

  # public: The role Id the of User to be added to this workspace
  workspaceRoleId: String!
}

# public: Add Member Input
input AddMemberInput {
  # public: The User Id of the Organization member
  id: ID!

  # public: Organization Role Id
  organizationRoleId: ID!

  # public: The Role Type of the Organization member
  type: String
}

# public: Add Permission group role input
input AddPermissionGroupsToRoleInput {
  # display order of the role
  displayOrder: Int

  # public: Permission GroupIds
  permissionGroupIds: [ID!]!
}

# public: BluescapeGroupJoinType
enum BluescapeGroupJoinType {
  # public: Any user can join the group.
  Anyone

  # public: New group members must be invited by the group owner.
  ByInvite

  # public: Users that want to join a group can request that the group owner add them.
  OnRequest
}

# public: Boolean Filter
input BooleanFilter {
  # public: equals
  eq: Boolean

  # public: not equals
  ne: Boolean
}

# The type reflecting a broadcast message
type BroadcastMessage {
  # The body of the broadcast message
  body: String!
  createdAt: DateTime
  endAt: DateTime
  id: ID!

  # Is the broadcast message can be dismissible
  isDismissable: Boolean!
  startAt: DateTime

  # The type of broadcast message
  type: BroadcastMessageType!
  updatedAt: DateTime

  # User details
  user: User
}

input BroadcastMessageFilters {
  and: [BroadcastMessageFilters!]
  not: [BroadcastMessageFilters!]
  or: [BroadcastMessageFilters!]
  type: StringFilter
}

enum BroadcastMessageOrderByField {
  updatedAt
}

input BroadcastMessageOrdering {
  field: BroadcastMessageOrderByField!
  order: OrderBy = Asc
}

# Type of broadcast message
enum BroadcastMessageType {
  # Internal broadcast message
  Internal

  # Public broadcast message
  Public
}

union BroadcastMessageUnion = BroadcastMessage | SimpleBroadcastMessage

# A paginated collection of broadcast messages.
type BroadcastMessagesPaged {
  next: String
  prev: String
  results: [BroadcastMessageUnion!]
  totalItems: Int
}

# Subscription cancellation reason.
enum CancellationReason {
  # Currency incompatible with Gateway.
  CurrencyIncompatibleWithGateway

  # Fraud Review Failed.
  FraudReviewFailed

  # No Card.
  NoCard

  # Non Compliant Customer.
  NonCompliantCustomer

  # Non Compliant EU Customer.
  NonCompliantEuCustomer

  # Not Paid.
  NotPaid

  # Client has chosen not to renew their subscription.
  NotRenewing

  # Tax Calculation Failed.
  TaxCalculationFailed
}

# public: A collaborator is user who can access a workspace.
type Collaborator {
  # public: The User or Group this workspace is associated with
  collaborator: CollaboratorUnion!

  # public: The Role this workspace is associated with
  workspaceRole: Role!
}

# public: Collaborator added event.
type CollaboratorAdded {
  # public: actorId
  actorId: ID!

  # public: actorType
  actorType: String!

  # public: category
  category: String!

  # public: containsConfidential
  containsConfidential: Boolean!

  # public: containsPII
  containsPII: Boolean!

  # public: Data
  data: CollaboratorAddedPayload!

  # public: date
  date: String

  # public: eventVersion
  eventVersion: String!

  # public: organizationId
  organizationId: ID

  # public: type
  type: String!

  # public: workspaceId
  workspaceId: ID
}

# public: Collaborator added event payload.
type CollaboratorAddedPayload {
  # public: Id
  id: ID!

  # public: Type
  type: String!

  # public: Workspace role
  workspaceRole: CollaboratorRolePayload!
}

# public: Collaborator Added Subscription
input CollaboratorAddedSubscriptionOptions {
  # public: Collaborator Id
  collaboratorId: ID!

  # public: Workspace Id
  workspaceId: ID!
}

# public: Collaborator filter
input CollaboratorFilters {
  # public: and filter
  and: [CollaboratorFilters!]

  # public: group filter
  group: CollaboratorGroupFilters

  # public: not filter
  not: [CollaboratorFilters!]

  # public: or filter
  or: [CollaboratorFilters!]

  # public: user filter
  user: CollaboratorUserFilters

  # public: workspace role filter
  workspaceRole: CollaboratorRoleFilters
}

# public: Collaborator group filter
input CollaboratorGroupFilters {
  # public: and filter
  and: [CollaboratorGroupFilters!]

  # public: Bluescape join type
  bluescapeGroupJoinType: GroupJoinTypeFilter

  # public: Description
  description: StringFilter

  # public: Id
  id: StringFilter

  # public: Name
  name: StringFilter

  # public: not filter
  not: [CollaboratorGroupFilters!]

  # public: or filter
  or: [CollaboratorGroupFilters!]

  # public: type
  type: StringFilter
}

# public: CollaboratorOrderByField
enum CollaboratorOrderByField {
  # public: Order by the creation date
  createdAt

  # public: Order by name
  name

  # public: Order by the date of the last update
  updatedAt
}

# public: Collaborator ordering
input CollaboratorOrdering {
  # public: sort field
  field: CollaboratorOrderByField!

  # public: order field
  order: OrderBy = Asc
}

# public: Collaborator removal event payload.
type CollaboratorRemovalPayload {
  # public: Id
  id: ID!

  # public: type
  type: String!

  # public: Workspace role
  workspaceRole: CollaboratorRolePayload!
}

# public: Collaborator removed event.
type CollaboratorRemoved {
  # public: actorId
  actorId: ID!

  # public: actorType
  actorType: String!

  # public: category
  category: String!

  # public: containsConfidential
  containsConfidential: Boolean!

  # public: containsPII
  containsPII: Boolean!

  # public: Collaborator Removed
  data: CollaboratorRemovalPayload!

  # public: date
  date: String

  # public: eventVersion
  eventVersion: String!

  # public: organizationId
  organizationId: ID

  # public: type
  type: String!

  # public: workspaceId
  workspaceId: ID
}

# public: Collaborator Remove Subscription
input CollaboratorRemovedSubscriptionOptions {
  # public: Collaborator Id
  collaboratorId: ID!

  # public: Workspace Id
  workspaceId: ID!
}

# public: Collaborator role changed event
type CollaboratorRoleChanged {
  # public: actorId
  actorId: ID!

  # public: actorType
  actorType: String!

  # public: category
  category: String!

  # public: containsConfidential
  containsConfidential: Boolean!

  # public: containsPII
  containsPII: Boolean!

  # public: data
  data: RolePayloadChanged!

  # public: date
  date: String

  # public: eventVersion
  eventVersion: String!

  # public: organizationId
  organizationId: ID

  # public: type
  type: String!

  # public: workspaceId
  workspaceId: ID
}

# public: Collaborator changed subscription
input CollaboratorRoleChangedSubscriptionOptions {
  # public: User Id
  userId: ID!

  # public: Workspace Id
  workspaceId: ID!
}

# public: Collaborator Role Filter
input CollaboratorRoleFilters {
  # public: and filter
  and: [CollaboratorRoleFilters!]

  # public: description
  description: StringFilter

  # public: Id
  id: StringFilter

  # public: is custom role
  isCustom: BooleanFilter

  # public: Name
  name: StringFilter

  # public: not filter
  not: [CollaboratorRoleFilters!]

  # public: or filter
  or: [CollaboratorRoleFilters!]

  # public: resource type
  resourceType: StringFilter

  # public: type
  type: StringFilter
}

# public: Collaborator role event payload.
type CollaboratorRolePayload {
  # public: Id
  id: ID!

  # public: name
  name: String!
}

# public: Collaborator Union
union CollaboratorUnion = Group | User

# public: Collaborator User Filters
input CollaboratorUserFilters {
  # public: and filter
  and: [CollaboratorUserFilters!]

  # public: Avatar URL
  avatarUrl: StringFilter

  # public: Email
  email: StringFilter

  # public: First name
  firstName: StringFilter

  # public: Id
  id: StringFilter

  # public: Last name
  lastName: StringFilter

  # public: not filter
  not: [CollaboratorUserFilters!]

  # public: or filter
  or: [CollaboratorUserFilters!]
}

# public: A paginated collection of collaborators.
type CollaboratorsPaged {
  # public: next
  next: String

  # public: prev
  prev: String

  # public: results
  results: [Collaborator!]

  # public: totalItems
  totalItems: Int
}

input CreateBroadcastMessageInput {
  # The body of the broadcast message
  body: String!
  endAt: String

  # Is the broadcast message can be dismissible
  isDismissable: Boolean
  startAt: String

  # The type of broadcast message
  type: BroadcastMessageType = Public
}

input CreateHelpMenuInput {
  # Display order of the menu
  displayOrder: Int

  # Help Menu link/URL
  link: String!

  # Title of the Help menu
  title: String!
}

# public: create identity provider input
input CreateIdentityProviderInput {
  # public: The email address of the provider administrator
  adminEmail: String

  # public: State of sp-initiated SAML single logout support
  isSamlSpSloEnabled: Boolean

  # public: URL of the SAML metadata file. It is required if the new identity provider is one of the SAML types
  metadataUrl: String

  # public: The name for the identity provider
  name: String!

  # public: The type of identity provider
  type: IDPTypeCreate!

  # public: Attribute name of User Guid in SAML assertion
  userGuidAttributeName: String
}

# public: CreateOrgDomainFilterInput
input CreateOrgDomainFilterInput {
  # public: allowedDomains
  allowedDomains: [String!]

  # public: deniedDomains
  deniedDomains: [String!]
}

# public: Create organization input
input CreateOrganizationInput {
  # public: Account Id
  accountId: ID

  # public: True if IDP user is to be auto associated
  autoAssociateIdentityProviderUser: Boolean = true

  # public: True if the organization allows guests
  canHaveGuests: Boolean = true

  # public: Default Organization User RoleId
  defaultOrganizationUserRoleId: ID

  # public: Default Public Workspace RoleId
  defaultPublicWorkspaceRoleId: ID

  # public: True if custom roles are enabled for the organization
  isCustomRolesEnabled: Boolean = false

  # public: True if the organization requires admin approval for users to invite guest
  isGuestInviteApprovalRequired: Boolean = false

  # API user definable types stored in a key value collection
  metadata: JSON

  # public: The name of the organization or company
  name: String!

  # public: Owner Id
  ownerId: ID

  # public: The name of the team or organizational unit.
  secondaryName: String = null
}

# public: Create role input
input CreateRoleInput {
  # public: description of the role
  description: String

  # public: The name for the role. It should be unique
  name: String!

  # public: Organization Id
  organizationId: ID!

  # public: Permission GroupIds
  permissionGroupIds: [ID!]

  # public: The resource type this role applies to
  resourceType: ResourceType!

  # public: The type of role
  type: RoleType!
}

input CreateTemplateInput {
  # Template category
  category: String

  # Template description
  description: String

  # Template elements
  elements: JSON

  # Template icon
  icon: String

  # Template id comes from UI
  masterId: String!

  # Template metadata
  metadata: JSON

  # Template name
  name: String!

  # Template organization id
  organizationId: ID!

  # Template parameters
  parameters: JSON
  templateCollaborators: [TemplateMember!]

  # Template type - User/Organization
  type: TemplateType!
}

# public: Create user input
input CreateUserInput {
  # public: Application Role Id
  applicationRoleId: String

  # public: email id of the user
  email: String!

  # A JSON-like key-value store. Valid keys are valid GraphQL property names. Valid values are any JSON encodable values.
  #  The values can be up 1024 bytes when JSON encoded.
  #  An ascii string 1022 characters in length become 1024 characters when encoded. Be aware of multi-byte characters.
  metadata: JSON
}

input CreateVerficationCodeInput {
  # email of the self serve user
  email: String!

  # query string EG:{tier: 'basic'}
  qs: JSON
}

# public: Type for wall creation
input CreateWallInput {
  # The assetId of the wall
  assetId: String!

  # A unchanging uniquely generated random string used for caching
  cacheKey: String

  # The default area to show on the default workspace on loading the workspace
  defaultViewport: DefaultViewportInput

  # The ID of wall default workspace
  defaultWorkspaceId: ID

  # The location of the wall
  location: String

  # A JSON-like key-value store. Valid keys are valid GraphQL property names. Valid values are any JSON encodable values.
  #  The values can be up 1024 bytes when JSON encoded.
  #  An ascii string 1022 characters in length become 1024 characters when encoded. Be aware of multi-byte characters.
  metadata: JSON

  # The name of the wall
  name: String!

  # The ID of the organization that owns the wall
  organizationId: String!

  # The publicKey of the wall
  publicKey: String!
}

# public: Created workspace input
input CreateWorkspaceInput {
  # public: Archived Date
  archivedAt: DateTime

  # public: The classification of workspace.
  classification: String

  # public: Copy From
  copyFrom: String

  # public: The default workspace role for a public workspace
  defaultRoleId: String

  # public: The description for the workspace.
  description: String

  # public: true: this workspace can be accessed by any member of the organization, false: this workspace can only be accessed by the workspace's collaborators
  isPublic: Boolean!

  # A JSON-like key-value store. Valid keys are valid GraphQL property names. Valid values are any JSON encodable values.
  #  The values can be up 1024 bytes when JSON encoded.
  #  An ascii string 1022 characters in length become 1024 characters when encoded. Be aware of multi-byte characters.
  metadata: JSON

  # public: The name for the workspace. It should be unique
  name: String!

  # public: The organization Id this workspace is associated with
  organizationId: String!

  # public: The id of the member who will own this workspace
  ownerId: String
}

# Currency of all pricing related fields.
enum Currency {
  # United States Dollars.
  USD
}

# Date scalar
scalar Date

# public: Date Filter
input DateFilter {
  # public: equals
  eq: DateTime

  # public: greater equal
  ge: DateTime

  # public: greater than
  gt: DateTime

  # public: less than equal
  le: DateTime

  # public: less than
  lt: DateTime

  # public: not equals
  ne: DateTime
}

# The javascript `Date` as string. Type represents date and time as the ISO Date string.
scalar DateTime

# [deprecated] The default view port for the wall. To become to Viewport when gql-gateway can deal with conflict with Elementary Viewport
type DefaultViewport {
  h: Float!
  w: Float!
  x: Float!
  y: Float!
}

input DefaultViewportInput {
  h: Float!
  w: Float!
  x: Float!
  y: Float!
}

# public: Delete member input
input DeleteMemberInput {
  # public: The User Id or the Group Id to be deleted from the Organization
  memberId: ID!

  # public: When changing an organization member to be a "guest", sets any workspaces owned by that member to a new workspace owner.
  newWorkspaceOwnerId: ID = null
}

# public: Delete Org Domain Filter Input
input DeleteOrgDomainFilterInput {
  # public: domains
  domains: [String!]!
}

# public: Group info used for synchronization.
type ExternalGroupInfo {
  # public: Auto-invite inviter or null if the previous sync did not use auto-invite
  autoInviteInviter: String!

  # public: The ID of the External Group Info.
  id: ID!

  # public: Identifier for the group in the external provider. Example: "e06eebc1-32fb-4971-b633-nnnnnnnnnnnn"
  identity: String!

  # public: Determines whether auto nested sync is enabled for the group
  isAutoNestedSync: Boolean!

  # public: Error message from the most recent incremental or full sync failure. This
  #     message is not removed when the sync completes successfully.<br/>
  lastSyncError: String!

  # public: The name of the group in the external provider
  name: String!

  # public: State of the last incremental or full sync.
  syncState: ExternalGroupInfoSyncState!
}

# public: External Group sync state
enum ExternalGroupInfoSyncState {
  # public: The previously attempted full or incremental sync has successfully completed
  Complete

  # public: The previously attempted full or incremental sync has failed. See also the sync error field
  Failure

  # public: A full or incremental sync is currently in process
  InProcess

  # public: No sync has yet been attempted
  NeverInitiated
}

# public: Workspaces marked as favorites
type Favorites {
  # public: Workspaces
  workspaces(
    # public: cursor
    cursor: String

    # public: filtering
    filtering: WorkspaceFilters

    # public: ordering
    ordering: [WorkspaceOrdering!]

    # public: pagination
    pagination: PaginationArgs
  ): WorkspacesPaged
}

# Free trial Subscription.
type FreeTrialSubscriptionInfo {
  # Reason the subscription was cancelled
  cancelReason: CancellationReason

  # The date the current term will end at and the subscription will be cancelled.
  cancelledAt: Date

  # Date the subscription was created at. Will be the same as the organization's creation date
  createdAt: Date

  # End date of the current term for Free Trial or Self Serve.
  currentTermEnd: Date

  # Start date of the current term for Free Trial or Self Serve.
  currentTermStart: Date

  # The date at which the organization's subscription expired
  expiredAt: Date

  # The number of licenses currently in use.
  licensesCurrentlyInUse: Int

  # Mode.
  mode: SubscriptionMode

  # Plan name.
  planName: String

  # Plan type.
  planType: PlanType

  # Date the subscription was last updated at. Will be the last update from the external subscription once it has been created with createOrganization.
  updatedAt: Date

  # Workspace count limit.
  workspaceCountLimit: Int

  # Workspace storage limit in Mb
  workspaceStorageLimitMb: Int
}

# public: A group of users.
type Group {
  # public: This field determines how a group members are added to a Bluescape Group. Note: doesn't apply to External groups.
  bluescapeGroupJoinType: BluescapeGroupJoinType

  # public: Created Date
  createdAt: DateTime!

  # public: Description of the purpose of this group along with any notes relating to it
  description: String!

  # public: externalGroupInfo
  externalGroupInfo: ExternalGroupInfo

  # public: The Id of the Group
  id: ID!

  # public: The name of the Group
  name: String!

  # public: The Id of the organization this group will belong to
  organizationId: ID!

  # public: Whether this group is a Bluescape Group (internal) managed group or and externally synced group
  type: GroupType!

  # public: Updated Date
  updatedAt: DateTime!
}

# public: Group join filter
input GroupJoinTypeFilter {
  # public: equals filter
  eq: BluescapeGroupJoinType

  # public: not equals filter
  ne: BluescapeGroupJoinType
}

# public: GroupType
enum GroupType {
  # public: A group defined within Bluescape.
  Bluescape

  # public: A group defined outside of Bluescape.
  External
}

# The help menu type.
type HelpMenu {
  createdAt: DateTime!

  # Display order of the help menu
  displayOrder: Int!

  # The Id of the help menu
  id: ID!

  # The URL of the help menu
  link: String!

  # The title of the help menu
  title: String!
  updatedAt: DateTime!
}

input HelpMenuFilters {
  and: [HelpMenuFilters!]
  not: [HelpMenuFilters!]
  or: [HelpMenuFilters!]
  title: StringFilter
}

enum HelpMenuOrderByField {
  createdAt
  displayOrder
  title
  updatedAt
}

input HelpMenuOrdering {
  field: HelpMenuOrderByField!
  order: OrderBy = Asc
}

# A paginated collection of help menu items.
type HelpMenuPaged {
  next: String
  prev: String
  results: [HelpMenu!]
  totalItems: Int
}

# public: IdentityProvider types
enum IDPType {
  # public: Active Directory Federation Serivces
  Adfs

  # public: Common Access Card
  Cac

  # public: F5 SAML Provider
  F5

  # public: Okta SAML Provider
  Okta

  # public: Onelogin cloud-based SAML Provider
  Onelogin

  # public: Internal, default, Bluescape Identity Provider
  Password

  # public: PingFederate is an enterprise SAML Provider
  PingFederate
}

# public: IdentityProviders that can be created for use
enum IDPTypeCreate {
  # public: Active Directory Federation Serivces
  Adfs

  # public: Common Access Card
  Cac

  # public: F5 SAML Provider
  F5

  # public: Okta SAML Provider
  Okta

  # public: Onelogin cloud-based SAML Provider
  Onelogin

  # public: PingFederate is an enterprise SAML Provider
  PingFederate
}

# public: An identity provider is a service that defines the identity of a user, it can be external, e.g. SAML, or internal, e.g. Bluescape password
type IdentityProvider {
  # public: The email address of the provider administrator
  adminEmail: String

  # public: Created Date
  createdAt: DateTime!

  # public: Identity Provider Id
  id: ID!

  # public: State of sp-initiated SAML single logout support
  isSamlSpSloEnabled: Boolean

  # public: URL of the SAML metadata file. It is required if the new identity provider is one of the SAML types
  metadataUrl: String

  # public: The name for the identity provider
  name: String!

  # public: Organizations
  organizations: [Organization!]!

  # public: The type of identity provider
  type: IDPType!

  # public: Updated Date
  updatedAt: DateTime!

  # public: Attribute name of User Guid in SAML assertion
  userGuidAttributeName: String
}

# public: A base type for other identity provider events.
type IdentityProviderEventPayload {
  # public: The email address of the provider administrator
  adminEmail: String

  # public: Created Date
  createdAt: DateTime!

  # public: Identity provider id
  id: ID!

  # public: The url that provides SAML metadata
  metadataUrl: String

  # public: The name for the identity provider
  name: String!

  # public: The type of identity provider
  type: IDPType!

  # public: Updated Date
  updatedAt: DateTime!
}

# public: Identity Provider Filters
input IdentityProviderFilters {
  # public: admin email
  adminEmail: StringFilter

  # public: and filter
  and: [IdentityProviderFilters!]

  # public: created date
  createdAt: DateFilter

  # public: metadata url
  metadataUrl: StringFilter

  # public: name of the idp
  name: StringFilter

  # public: not filter
  not: [IdentityProviderFilters!]

  # public: or filter
  or: [IdentityProviderFilters!]

  # public: type
  type: IdentityProviderTypeFilter

  # public: updated date
  updatedAt: DateFilter
}

# public: Order by fields.
enum IdentityProviderOrderByField {
  # public: Order by creation date.
  createdAt

  # public: Order by name.
  name

  # public: Order by type.
  type

  # public: Order by update date.
  updatedAt
}

# public: Identity provider ordering.
input IdentityProviderOrdering {
  # public: Order by field.
  field: IdentityProviderOrderByField!

  # public: Ordering direction.
  order: OrderBy = Asc
}

# public: Event raised when an identity provider is created.
type IdentityProviderPayloadCreated {
  # public: actorId
  actorId: ID!

  # public: actorType
  actorType: String!

  # public: category
  category: String!

  # public: containsConfidential
  containsConfidential: Boolean!

  # public: containsPII
  containsPII: Boolean!

  # public: data
  data: IdentityProviderEventPayload!

  # public: date
  date: String

  # public: eventVersion
  eventVersion: String!

  # public: organizationId
  organizationId: ID

  # public: type
  type: String!

  # public: workspaceId
  workspaceId: ID
}

# public: Event raised when an identity provider is deleted.
type IdentityProviderPayloadDeleted {
  # public: actorId
  actorId: ID!

  # public: actorType
  actorType: String!

  # public: category
  category: String!

  # public: containsConfidential
  containsConfidential: Boolean!

  # public: containsPII
  containsPII: Boolean!

  # public: data
  data: IdentityProviderEventPayload!

  # public: date
  date: String

  # public: eventVersion
  eventVersion: String!

  # public: organizationId
  organizationId: ID

  # public: type
  type: String!

  # public: workspaceId
  workspaceId: ID
}

# public: Event raised when an identity provider is updated.
type IdentityProviderPayloadUpdated {
  # public: actorId
  actorId: ID!

  # public: actorType
  actorType: String!

  # public: category
  category: String!

  # public: containsConfidential
  containsConfidential: Boolean!

  # public: containsPII
  containsPII: Boolean!

  # public: data
  data: IdentityProviderEventPayload!

  # public: date
  date: String

  # public: eventVersion
  eventVersion: String!

  # public: organizationId
  organizationId: ID

  # public: type
  type: String!

  # public: workspaceId
  workspaceId: ID
}

# public: A type to filter identity providers.
input IdentityProviderTypeFilter {
  # public: equals
  eq: IDPType

  # public: not equals
  ne: IDPType
}

# public: A type for paginated identity providers.
type IdentityProvidersPaged {
  # public: next
  next: String

  # public: prev
  prev: String

  # public: results
  results: [IdentityProvider!]

  # public: totalItems
  totalItems: Int
}

# The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
scalar JSON

# Legacy Subscription.
type LegacySubscriptionInfo {
  # Date the subscription was created at. Will be the same as the organization's creation date
  createdAt: Date

  # The date at which the organization's subscription expired
  expiredAt: Date

  # Subscription interval - YEAR/MONTH.
  interval: SubscriptionInterval

  # The number of licenses currently in use.
  licensesCurrentlyInUse: Int

  # Mode.
  mode: SubscriptionMode

  # Date the subscription was last updated at. Will be the last update from the external subscription once it has been created with createOrganization.
  updatedAt: Date
}

input LinkExternalFreeTrialSubscriptionInput {
  currency: Currency = USD

  # End date of the current term for Free Trial or Self Serve.
  currentTermEnd: Date!

  # Start date of the current term for Free Trial or Self Serve.
  currentTermStart: Date!

  # External subscription ID.
  externalSubscriptionId: String!

  # Version of external subscription. Changes (increases) with every update.
  externalSubscriptionVersion: Long!

  # Plan type.
  futurePlanType: PlanType!

  # The same plan will have multiple versions as it evolves over time.
  planVersion: Int!

  # Cost per license in the smallest unit of currency (e.g. USD cents). Note: does not include taxes.
  pricePerLicense: Int!
}

input LinkExternalSelfServeSubscriptionInput {
  currency: Currency = USD

  # End date of the current term for Free Trial or Self Serve.
  currentTermEnd: Date!

  # Start date of the current term for Free Trial or Self Serve.
  currentTermStart: Date!

  # External subscription ID.
  externalSubscriptionId: String!

  # Version of external subscription. Changes (increases) with every update.
  externalSubscriptionVersion: Long!

  # Subscription interval - YEAR/MONTH.
  interval: SubscriptionInterval!

  # The number of licenses available for the current term.
  licenseQuantity: Int!

  # The number of licenses purchased for next term.
  licenseQuantityInNextTerm: Int!

  # Date at which the next billing for the subscription will occur.
  nextBillingAt: Date!

  # Total amount that will be charged on `nextBillingAt` in the smallest unit of currency (e.g. USD cents). Note: does not include taxes.
  nextBillingPeriodAmount: Int!

  # Start date of the next term.
  nextTermStart: Date!

  # Plan type.
  planType: PlanType!

  # The same plan will have multiple versions as it evolves over time.
  planVersion: Int!

  # Cost per license in the smallest unit of currency (e.g. USD cents). Note: does not include taxes.
  pricePerLicense: Int!
}

# The `Long` scalar type represents 52-bit integers
scalar Long

# public: Get the current user.
type Me {
  # public: Favorites
  favorites: Favorites!

  # public: Organizations specifically associated to the user
  organizations(
    # public: cursor
    cursor: String

    # public: filtering
    filtering: OrganizationFilters

    # public: ordering
    ordering: [OrganizationOrdering!]

    # public: pagination
    pagination: PaginationArgs
  ): OrganizationsPaged!

  # public: User profile
  profile: User!

  # public: public: Wall specifically associated to the user
  walls(
    # public: cursor
    cursor: String

    # public: filtering
    filtering: WallFilters

    # public: ordering
    ordering: [WallOrdering!]

    # public: pagination
    pagination: PaginationArgs
  ): WallsPaged!

  # public: workspces specifically associated to the user
  workspaces(
    # public: cursor
    cursor: String

    # public: filtering
    filtering: UserWorkspaceFilters

    # public: ordering
    ordering: [WorkspaceOrdering!]

    # public: pagination
    pagination: PaginationArgs
  ): UserWorkspacesPaged!
}

# public: A member of an organization.
type Member {
  # public: The User or Group this organization is associated with
  member: MemberUnion!

  # public: The organization this Member is associated with
  organization: Organization!

  # public: The Role this Member is associated in the Organization
  organizationRole: Role!
}

# public: Organization member added event.
type MemberAdded {
  # public: actorId
  actorId: ID!

  # public: actorType
  actorType: String!

  # public: category
  category: String!

  # public: containsConfidential
  containsConfidential: Boolean!

  # public: containsPII
  containsPII: Boolean!

  # public: data
  data: MemberAddedPayload!

  # public: date
  date: String

  # public: eventVersion
  eventVersion: String!

  # public: organizationId
  organizationId: ID

  # public: type
  type: String!

  # public: workspaceId
  workspaceId: ID
}

# public: Organization member added event payload.
type MemberAddedPayload {
  # public: The User Id of the Organization member
  id: ID!

  # public: The Role details the Member in Organization
  organizationRole: MemberRolePayload!

  # public: The Role Type of the Organization member
  type: String!
}

# public: Member added subscription
input MemberAddedSubscriptionOptions {
  # public: Organization Id
  organizationId: ID!
}

# public: member filters
input MemberFilters {
  # public: and filter
  and: [MemberFilters!]

  # public: group filter
  group: MemberGroupFilters

  # public: not filter
  not: [MemberFilters!]

  # public: or filter
  or: [MemberFilters!]

  # public: organization role
  organizationRole: MemberRoleFilters

  # public: user filter
  user: MemberUserFilters
}

# public: Member group filter
input MemberGroupFilters {
  # public: and filter
  and: [MemberGroupFilters!]

  # public: Bluescape group join type
  bluescapeGroupJoinType: GroupJoinTypeFilter

  # public: description
  description: StringFilter

  # public: id
  id: StringFilter

  # public: name
  name: StringFilter

  # public: not filter
  not: [MemberGroupFilters!]

  # public: or filter
  or: [MemberGroupFilters!]

  # public: type
  type: StringFilter
}

# public: Member ordering.
enum MemberOrderByField {
  # public: Order by email.
  email
}

# public: Member ordering.
input MemberOrdering {
  # public: sort field
  field: MemberOrderByField!

  # public: sort order
  order: OrderBy = Asc
}

# public: Organization member removed event.
type MemberRemoved {
  # public: actorId
  actorId: ID!

  # public: actorType
  actorType: String!

  # public: category
  category: String!

  # public: containsConfidential
  containsConfidential: Boolean!

  # public: containsPII
  containsPII: Boolean!

  # public: data
  data: MemberRemovedPayload!

  # public: date
  date: String

  # public: eventVersion
  eventVersion: String!

  # public: organizationId
  organizationId: ID

  # public: type
  type: String!

  # public: workspaceId
  workspaceId: ID
}

# public: Organization member removed event payload.
type MemberRemovedPayload {
  # public: The email of the Organization member
  email: String!

  # public: The User Id of the Organization member
  id: ID!

  # public: The name of the Organization member
  name: String!

  # public: The organization Id this this Member is associated with
  organizationId: ID!

  # public: The Role details of the Organization member
  organizationRole: MemberRolePayload!

  # public: The type of the Organization member, can be user/group
  type: String!
}

# public: Member Removed subscription
input MemberRemovedSubscriptionOptions {
  # public: Organization Id
  organizationId: ID!
}

# public: Member Role filters
input MemberRoleFilters {
  # public: and filter
  and: [MemberRoleFilters!]

  # public: description
  description: StringFilter

  # public: id
  id: StringFilter

  # public: is custom
  isCustom: BooleanFilter

  # public: name
  name: StringFilter

  # public: not filter
  not: [MemberRoleFilters!]

  # public: or filter
  or: [MemberRoleFilters!]

  # public: resource type
  resourceType: StringFilter

  # public: type
  type: StringFilter
}

# public: Organization member role event payload.
type MemberRolePayload {
  # public: The Role Id of the Organization member
  id: ID!

  # public: The Role Name of the Organization member
  name: String!

  # public: The display order of the role
  order: Float!

  # public: The Role Type of the Organization member
  type: String!
}

# public: Organization member role updated event.
type MemberRoleUpdated {
  # public: actorId
  actorId: ID!

  # public: actorType
  actorType: String!

  # public: category
  category: String!

  # public: containsConfidential
  containsConfidential: Boolean!

  # public: containsPII
  containsPII: Boolean!

  # public: data
  data: MemberRoleUpdatedPayload!

  # public: date
  date: String

  # public: eventVersion
  eventVersion: String!

  # public: organizationId
  organizationId: ID

  # public: type
  type: String!

  # public: workspaceId
  workspaceId: ID
}

# public: Organization member role updated event payload.
type MemberRoleUpdatedPayload {
  # public: The User Id of the Organization member
  id: ID!

  # public: The Role details the Member in Organization
  newOrganizationRole: MemberRolePayload!

  # public: The Role details the Member in Organization
  previousOrganizationRole: MemberRolePayload!

  # public: The Role Type of the Organization member
  type: String!
}

# public: Member role updated subscription
input MemberRoleUpdatedSubscriptionOptions {
  # public: Member Id
  memberId: ID!

  # public: Organization Id
  organizationId: ID!
}

# public: Member Union
union MemberUnion = Group | User

# public: Member user filters
input MemberUserFilters {
  # public: and filter
  and: [MemberUserFilters!]

  # public: avatar URL
  avatarUrl: StringFilter

  # public: email
  email: StringFilter

  # public: first name
  firstName: StringFilter

  # public: Id
  id: StringFilter

  # public: last name
  lastName: StringFilter

  # public: not filter
  not: [MemberUserFilters!]

  # public: or filter
  or: [MemberUserFilters!]
}

# public: A paginated collection of organization members.
type MembersPaged {
  # public: next
  next: String

  # public: prev
  prev: String

  # public: results
  results: [Member!]

  # public: totalItems
  totalItems: Int
}

# Associations between the requester and the resource in context
type My {
  # The resolved permissions of the requester on this organization
  permissions(
    # A list of permission keys to filter by
    contains: [String!]

    # which permissions to include
    include: [String!]
  ): [String!]!
}

# public: OrderBy
enum OrderBy {
  # public: Ascending order
  Asc

  # public: Descending order
  Desc
}

# public: The organizaiton domain filter type expresses what domains guest invites can be made to.
type OrgDomainFilter {
  # public: The domain that will be either denied or allowed in the org
  domain: String!

  # public: Is the domian allowed
  isAllowed: Boolean!

  # public: Is the domain denied
  isDenied: Boolean!

  # public: The organization where the domain is filtered
  organization: Organization
}

# public: The response of a organization domain filter request.
type OrgDomainFiltersResponse {
  # public: allowedDomains
  allowedDomains: [String!]!

  # public: deniedDomains
  deniedDomains: [String!]!
}

# public: The organization type.
type Organization {
  # public: True if IDP user is to be auto associated
  autoAssociateIdentityProviderUser: Boolean!

  # public: True if the organization allows guests
  canHaveGuests: Boolean

  # public: Created Date
  createdAt: DateTime!

  # public: The role to apply when a user is added to an organization, but has no role has been assigned
  defaultOrganizationUserRole: Role

  # public: The Id of the role to apply when a user accesses a public workspace, but has no role specified for that workspace
  defaultPublicWorkspaceRole: Role

  # Get domain filters in the organization
  domainFilters: OrgDomainFiltersResponse!

  # public: Id of the organization
  id: ID!

  # The identity provider that the organization uses
  identityProvider: IdentityProvider

  # public: True if custom roles are enabled for the organization
  isCustomRolesEnabled: Boolean

  # Whether this organization has Enhanced User Authorization enabled. Note: will be false for Bluescape instances that don't support the EUA feature.
  isEnhancedUserAuthorizationEnabled: Boolean!

  # public: True if the organization requires admin approval for users to invite guest
  isGuestInviteApprovalRequired: Boolean

  # The date the organization was locked at
  lockedAt: DateTime

  # public: Members
  members(
    # public: cursor
    cursor: String

    # public: filtering
    filtering: MemberFilters

    # public: ordering
    ordering: [MemberOrdering!]

    # public: pagination
    pagination: PaginationArgs
  ): MembersPaged!

  # A JSON-like key-value store. Valid keys are valid GraphQL property names. Valid values are any JSON encodable values.
  #  The values can be up 1024 bytes when JSON encoded.
  #  An ascii string 1022 characters in length become 1024 characters when encoded. Be aware of multi-byte characters.
  metadata(
    # Select a subset of fields to include in the output.
    include: [String!]
  ): JSON

  # associations between the requester and the organization
  my: My

  # public: The name of the organization or company
  name: String!

  # public: The owner of the organization
  owner: User!

  # public: The name of the team or organizational unit
  secondaryName: String

  # Subscription
  subscription: SubscriptionUnionType

  # public: Updated Date
  updatedAt: DateTime!

  # public: Walls
  walls(
    # public: pagination
    pagination: PaginationArgs
  ): WallsPaged!
}

# public: Organization Filters
input OrganizationFilters {
  # public: and filter
  and: [OrganizationFilters!]

  # public: can have guests
  canHaveGuests: BooleanFilter

  # public: is custom role enalbed
  isCustomRolesEnabled: BooleanFilter

  # public: is guest invite approval required
  isGuestInviteApprovalRequired: BooleanFilter

  # public: name
  name: StringFilter

  # public: not filter
  not: [OrganizationFilters!]

  # public: or filter
  or: [OrganizationFilters!]

  # public: Secondary name
  secondaryName: StringFilter

  # A filter for subscription mode
  subscriptionMode: SubscriptionModeFilter
}

# public: Organization Order by field
enum OrganizationOrderByField {
  # public: Order by the creation date
  createdAt

  # public: Order by name
  name

  # public: Order by secondaryName
  secondaryName

  # public: Order by subscriptionMode
  subscriptionMode

  # public: Order by the last updated date
  updatedAt
}

# public: Organization Ordering
input OrganizationOrdering {
  # public: sort fields
  field: OrganizationOrderByField!

  # public: order fields
  order: OrderBy = Asc
}

# public: A paginated collection of organizations.
type OrganizationsPaged {
  # public: next
  next: String

  # public: prev
  prev: String

  # public: results
  results: [Organization!]

  # public: totalItems
  totalItems: Int
}

# public: OwnedBy
enum OwnedBy {
  # public: Owned by me
  me

  # public: Owned by other users
  others
}

# public: Owned By Filter
input OwnedByFilter {
  # public: equals
  eq: OwnedBy

  # public: not equals
  ne: OwnedBy
}

# public: Pagination Args
input PaginationArgs {
  # public: pageSize
  pageSize: Int = 25
}

# public: The permission object reflects the access rights needed or attributed to an entity
type Permission {
  # public: Created Date
  createdAt: DateTime!

  # public: Permission Id
  id: ID!

  # public: The Key this permission gets identified with.
  key: String

  # public: The name of the Permission. It should be unique
  name: String!

  # public: The resource type of the Permission
  resourceType: ResourceType!

  # public: Updated Date
  updatedAt: DateTime!
}

# public: Permission Filter
input PermissionFilters {
  # public: and filter
  and: [PermissionFilters!]

  # public: name
  name: StringFilter

  # public: nor filter
  not: [PermissionFilters!]

  # public: or filter
  or: [PermissionFilters!]
}

# public: A management mechanism to bulk manage permissions.
type PermissionGroup {
  # public:
  createdAt: DateTime!

  # public: The description for the Permission Group.
  description: String

  # public: The ID of the permission group.
  id: ID!

  # public: True if not hidden
  isVisible: Boolean!

  # public: The Key this Permission Group gets identified with.
  key: String

  # public: The name of the Permission Group. It should be unique
  name: String!

  # public: The permission groups that belong to this permission group.
  permissionGroups: [PermissionGroup!]!

  # public: The permissions that belong to this permissions group.
  permissions: [Permission!]!

  # public: The resource type of the Permission Group
  resourceType: ResourceType!

  # public:
  updatedAt: DateTime!
}

# public: Filters for filtering paginated collections of permission groups
input PermissionGroupFilters {
  # public:
  and: [PermissionGroupFilters!]

  # public:
  name: StringFilter

  # public:
  not: [PermissionGroupFilters!]

  # public:
  or: [PermissionGroupFilters!]
}

# public: Fields that can be specified for ordering criteria on paginated collections of permission groups.
enum PermissionGroupOrderByField {
  # public: The name of the permission group.
  name

  # public: The resource type of the permission group.
  resourceType
}

# public: A type to specify the ordering of paginated collections of permission groups
input PermissionGroupOrdering {
  # public:
  field: PermissionGroupOrderByField!

  # public:
  order: OrderBy = Asc
}

# public: A paginated collection of permission groups.
type PermissionGroupsPaged {
  # public: next
  next: String

  # public: prev
  prev: String

  # public: results
  results: [PermissionGroup!]

  # public: totalItems
  totalItems: Int
}

# public: Permission Fields
enum PermissionOrderByField {
  # public: Order by name
  name

  # public: Order by resourceType
  resourceType
}

# public: Permission ordering
input PermissionOrdering {
  # public: field
  field: PermissionOrderByField!

  # public: order
  order: OrderBy = Asc
}

# public: A paginated collection of permissions.
type PermissionsPaged {
  # public: next
  next: String

  # public: prev
  prev: String

  # public: results
  results: [Permission!]

  # public: totalItems
  totalItems: Int
}

# The current plan the client is subscribed to.
enum PlanType {
  # Business plan.
  Business

  # Team plan.
  Team
}

# A user provision object.
type Provisioning {
  # Verfication code
  code: String!

  # Message of the code
  message: String!

  # The verificationId
  verificationId: ID
}

type ResendVerificationCodeExchange {
  # Message of the code
  message: String!

  # The verificationId
  verificationId: ID!
}

input ResendVerificationCodeExchangeInput {
  # query string EG:{tier: 'basic'}
  qs: JSON

  # redirect url provided when the type is SSOEmailVerification
  redirectUrl: String

  # Verification Id
  verificationId: String!
}

# public: Available types of resource
enum ResourceType {
  # public: Accounts are entities for billing and associated to one or more organizations
  Account

  # public: Application refers to the entire Bluescape instance
  Application

  # public: Groups a mechanism to bulk manage users associations to organizations and workspaces
  Group

  # public: Organizations are entities for the coordination of users and workspaces
  Organization

  # public: Templates a set of predefined workspace elements
  Template

  # public: Workspaces are the principle unit that reflects a digital container
  Workspace
}

# public: Resource filter
input ResourceTypeFilter {
  # public: Equal
  eq: ResourceType

  # public: Not Equal
  ne: ResourceType
}

# public: The role used in the management and association of permissions for access control.
type Role {
  # public: Created Date
  createdAt: DateTime!

  # public: The description for the role.
  description: String

  # display order of the role
  displayOrder: Int!

  # public: Role Id
  id: ID!

  # public: True if it is a custom role
  isCustom: Boolean!

  # public: The name for the role. It should be unique
  name: String!

  # public: The organization this role is associated with
  organization: Organization

  # public: Permission groups associated to the role.
  permissionGroups(
    # public: cursor
    cursor: String

    # public: filtering
    filtering: PermissionGroupFilters

    # public: ordering
    ordering: [PermissionGroupOrdering!]

    # public: pagination
    pagination: PaginationArgs
  ): PermissionGroupsPaged!

  # public:
  permissions: [String!]

  # public: The resource type this role applies to
  resourceType: ResourceType!

  # public: The type of role
  type: RoleType!

  # public: Updated Date
  updatedAt: DateTime!
}

# public: Event produced when a role is created.
type RoleCreated {
  # public: actorId
  actorId: ID!

  # public: actorType
  actorType: String!

  # public: category
  category: String!

  # public: containsConfidential
  containsConfidential: Boolean!

  # public: containsPII
  containsPII: Boolean!

  # public: data
  data: RoleEventPayload!

  # public: date
  date: String

  # public: eventVersion
  eventVersion: String!

  # public: organizationId
  organizationId: ID

  # public: type
  type: String!

  # public: workspaceId
  workspaceId: ID
}

# public: Subscription options for role create events
input RoleCreatedSubscriptionOptions {
  # public: organization Id
  organizationId: ID!
}

# public: Event produced when a role is deleted.
type RoleDeleted {
  # public: actorId
  actorId: ID!

  # public: actorType
  actorType: String!

  # public: category
  category: String!

  # public: containsConfidential
  containsConfidential: Boolean!

  # public: containsPII
  containsPII: Boolean!

  # public: data
  data: RoleEventPayload!

  # public: date
  date: String

  # public: eventVersion
  eventVersion: String!

  # public: organizationId
  organizationId: ID

  # public: type
  type: String!

  # public: workspaceId
  workspaceId: ID
}

# public: Subscription options for role delete events
input RoleDeletedSubscriptionOptions {
  # public: Organization Id
  organizationId: ID!

  # public: Role Id
  roleId: ID!
}

# public: Role event payload
type RoleEventPayload {
  # public: Role
  role: RolePayload!
}

# public: Role Filter
input RoleFilters {
  # public: and filter
  and: [RoleFilters!]

  # public: is custom
  isCustom: BooleanFilter

  # public: name of the role
  name: StringFilter

  # public: not filter
  not: [RoleFilters!]

  # public: or filter
  or: [RoleFilters!]

  # public: Organization Id
  organizationId: StringFilter

  # public: Resource filter
  resourceType: ResourceTypeFilter

  # public: Filter Type
  type: RoleTypeFilter
}

# public: Role order
enum RoleOrderByField {
  # public: Order by name
  name
}

# public: Role ordering
input RoleOrdering {
  # public: field
  field: RoleOrderByField

  # public: order
  order: OrderBy = Asc
}

# public: Role event payload
type RolePayload {
  # public: Created Date
  createdAt: String!

  # public: description
  description: String

  # public: Role Id
  id: ID!

  # public: Role Name
  name: String!

  # public: Organization Id
  organizationId: String!

  # public: Resource Type
  resourceType: ResourceType!

  # public: Role Type
  type: RoleType!

  # public: Updated Date
  updatedAt: String!
}

# public: Role changed event payload
type RolePayloadChanged {
  # public: Id
  id: ID!

  # public: The workspace this new role is associated with
  newWorkspaceRole: WorkspaceRolePayload

  # public: The workspace this previous role is associated with
  previousWorkspaceRole: WorkspaceRolePayload

  # public: Role Type
  type: String!
}

# public: Expresses various levels of user access
enum RoleType {
  # public: The Admin roleType is used to categorize roles for association with admins
  Admin

  # public: The App roleType is used to categorize roles that can be assoiated to apps
  App

  # public: The Visitor roleType is used to categorize roles for association with workspace visitors
  Guest

  # public: The Owner roleType is used to categorize roles for the owner of a resource
  Owner

  # public: The User roleType is used to categorize roles for association with users
  User
}

# public: RoleTypeFilter
input RoleTypeFilter {
  # public: Equal
  eq: RoleType

  # public: Not Equal
  ne: RoleType
}

# public: Event produced when a role is updated.
type RoleUpdated {
  # public: actorId
  actorId: ID!

  # public: actorType
  actorType: String!

  # public: category
  category: String!

  # public: containsConfidential
  containsConfidential: Boolean!

  # public: containsPII
  containsPII: Boolean!

  # public: data
  data: RoleEventPayload!

  # public: date
  date: String

  # public: eventVersion
  eventVersion: String!

  # public: organizationId
  organizationId: ID

  # public: type
  type: String!

  # public: workspaceId
  workspaceId: ID
}

# public: Subscription options for role update events
input RoleUpdatedSubscriptionOptions {
  # public: Organization Id
  organizationId: ID!

  # public: Role Id
  roleId: ID!
}

# public: A paginated collection of roles
type RolesPaged {
  # public: next
  next: String

  # public: prev
  prev: String

  # public: results
  results: [Role!]

  # public: totalItems
  totalItems: Int
}

# The ScratchWorkspace type
type ScratchWorkspace {
  # The id of the actor that created the scratch workspace. Only that actor can update it
  actorId: String!

  # When the scratch workspace was created
  createdAt: DateTime!

  # The email for the user who can claim or delete the scratch workspace
  email: String

  # Scratch workspace Id
  id: ID!

  # The name for the scratch workspace
  name: String

  # When the scratch workspace was last updated
  updatedAt: DateTime!
}

# Scratch workspace filters
input ScratchWorkspaceFilters {
  # and filter
  and: [ScratchWorkspaceFilters!]

  # Id
  id: StringFilter

  # name
  name: StringFilter

  # not filter
  not: [ScratchWorkspaceFilters!]

  # or filter
  or: [ScratchWorkspaceFilters!]
}

# ScratchWorkspace orderBy Field
enum ScratchWorkspaceOrderByField {
  # Actor that created the scratch workspace
  actorId

  # Order by creation date
  createdAt
  id

  # Order by name
  name

  # Order by last update date
  updatedAt
}

# Scratch workspace ordering
input ScratchWorkspaceOrdering {
  # Field
  field: ScratchWorkspaceOrderByField!

  # Order
  order: OrderBy = Asc
}

# A paginated collection of scratch workspaces
type ScratchWorkspacesPaged {
  # public: next
  next: String

  # public: prev
  prev: String

  # public: results
  results: [ScratchWorkspace!]

  # public: totalItems
  totalItems: Int
}

# Self serve Subscription.
type SelfServeSubscriptionInfo {
  # Reason the subscription was cancelled
  cancelReason: CancellationReason

  # The date the current term will end at and the subscription will be cancelled.
  cancelledAt: Date

  # Date the subscription was created at. Will be the same as the organization's creation date
  createdAt: Date
  currency: Currency

  # End date of the current term for Free Trial or Self Serve.
  currentTermEnd: Date

  # Start date of the current term for Free Trial or Self Serve.
  currentTermStart: Date

  # The date at which the organization's subscription expired
  expiredAt: Date

  # Subscription interval - YEAR/MONTH.
  interval: SubscriptionInterval

  # The number of licenses available for the current term.
  licenseQuantity: Int

  # The number of licenses purchased for next term.
  licenseQuantityInNextTerm: Int

  # The number of licenses currently in use.
  licensesCurrentlyInUse: Int

  # Mode.
  mode: SubscriptionMode

  # Date at which the next billing for the subscription will occur.
  nextBillingAt: Date

  # Total amount that will be charged on `nextBillingAt` in the smallest unit of currency (e.g. USD cents). Note: does not include taxes.
  nextBillingPeriodAmount: Int

  # Start date of the next term.
  nextTermStart: Date

  # Plan name.
  planName: String

  # Plan type.
  planType: PlanType

  # Cost per license in the smallest unit of currency (e.g. USD cents). Note: does not include taxes.
  pricePerLicense: Int

  # Date the subscription was last updated at. Will be the last update from the external subscription once it has been created with createOrganization.
  updatedAt: Date
}

# A broadcast message with user, createdAt,updatedAt, startAt, endAt properties removed.
type SimpleBroadcastMessage {
  # The body of the broadcast message
  body: String!
  id: ID!

  # Is the broadcast message can be dismissible
  isDismissable: Boolean!

  # The type of broadcast message
  type: BroadcastMessageType!
}

# public: StringFilter
input StringFilter {
  # public: contains
  contains: String

  # public: equals
  eq: String

  # public: not equal
  ne: String

  # public: starts with
  startsWith: String
}

# Subscription renewal interval.
enum SubscriptionInterval {
  Monthly
  Yearly
}

# The current plan the client is subscribed to.
enum SubscriptionMode {
  # Trial mode.
  FreeTrial

  # Legacy mode.
  LegacyEnterprise

  # Self serve mode.
  SelfServe
}

# public: Subscription mode filter
input SubscriptionModeFilter {
  # public: equals
  eq: SubscriptionMode

  # public: not equals
  ne: SubscriptionMode
}

enum SubscriptionState {
  # A paid subscription is active.
  Active

  # The subscription was been cancelled and the current term has ended.
  Cancelled
}

# Subscription Union
union SubscriptionUnionType =
    FreeTrialSubscriptionInfo
  | LegacySubscriptionInfo
  | SelfServeSubscriptionInfo

# The type reflecting a template
type Template {
  # Template category
  category: String
  createdAt: DateTime

  # Template creator id
  creatorId: ID!
  deletedAt: DateTime

  # Template description
  description: String

  # Template elements
  elements: JSON

  # Template icon
  icon: String
  id: ID!

  # Is the template active or expired
  isActive: Boolean!

  # Template id comes from UI
  masterId: String!

  # Template metadata
  metadata: JSON

  # Template name
  name: String!

  # Template organization id
  organizationId: ID!

  # Template parameters
  parameters: JSON

  # Template members
  templateCollaborators: [UserTemplate!]

  # Template type - User/Organization
  type: TemplateType!
  updatedAt: DateTime
}

input TemplateFilters {
  and: [TemplateFilters!]
  category: StringFilter
  isActive: BooleanFilter
  masterId: StringFilter
  name: StringFilter
  not: [TemplateFilters!]
  or: [TemplateFilters!]
  type: StringFilter
}

input TemplateMember {
  # Member template Role id
  templateRoleId: ID!

  # Member userId
  userId: ID!
}

enum TemplateOrderByField {
  category
  createdAt
  icon
  isActive
  name
  updatedAt
}

input TemplateOrdering {
  field: TemplateOrderByField!
  order: OrderBy = Asc
}

# A paginated collection of templates.
type TemplatePaged {
  next: String
  prev: String
  results: [Template!]
  totalItems: Int
}

# Template types
enum TemplateType {
  # Organization Template
  Organization

  # User template
  User
}

# public: User token revoked event.
type TokenRevoked {
  # public: actorId
  actorId: ID!

  # public: actorType
  actorType: String!

  # public: category
  category: String!

  # public: containsConfidential
  containsConfidential: Boolean!

  # public: containsPII
  containsPII: Boolean!

  # public: Token Revoked Data
  data: TokenRevokedData!

  # public: date
  date: String

  # public: eventVersion
  eventVersion: String!

  # public: organizationId
  organizationId: ID

  # public: type
  type: String!

  # public: workspaceId
  workspaceId: ID
}

# public: Token revoked data type.
type TokenRevokedData {
  # public: Identity Provider Id
  identityProviderId: ID

  # public: Token Id
  tokenId: ID
}

input UpdateBroadcastMessageInput {
  # The body of the broadcast message
  body: String
  endAt: String

  # Is the broadcast message can be dismissible
  isDismissable: Boolean
  startAt: String

  # The type of broadcast message
  type: BroadcastMessageType
}

input UpdateHelpMenuInput {
  displayOrder: Int
  link: String
  title: String
}

# public: updated indetity provider input
input UpdateIdentityProviderInput {
  # public: The email address of the provider administrator
  adminEmail: String

  # public: State of sp-initiated SAML single logout support
  isSamlSpSloEnabled: Boolean

  # public: URL of the SAML metadata file. It is required if the new identity provider is one of the SAML types
  metadataUrl: String

  # public: The name for the identity provider
  name: String

  # public: The type of identity provider
  type: IDPTypeCreate

  # public: Attribute name of User Guid in SAML assertion
  userGuidAttributeName: String
}

# public: Update member role input
input UpdateMemberRoleInput {
  # public: Organization Role Id
  organizationRoleId: ID!
}

# public: Update Organization input
input UpdateOrganizationInput {
  # public: Auto Associate Identity Provider User
  autoAssociateIdentityProviderUser: Boolean

  # public: Can have guests
  canHaveGuests: Boolean

  # public: Default Public Organization RoleId
  defaultOrganizationUserRoleId: ID

  # public: Default Public Workspace RoleId
  defaultPublicWorkspaceRoleId: ID

  # public: Expire Date
  expiredAt: DateTime

  # public: Custom Roles Enabled
  isCustomRolesEnabled: Boolean

  # public: Guest Invite Approval Required
  isGuestInviteApprovalRequired: Boolean

  # The date the organization was locked at
  lockedAt: DateTime

  # API user definable types stored in a key value collection
  metadata: JSON

  # public: The name of the organization or company
  name: String

  # public: Owner Id
  ownerId: ID

  # public: The name of the team or organizational unit
  secondaryName: String
}

# public: Update role input
input UpdateRoleInput {
  # public: The description for the role.
  description: String

  # public: The name for the role. It should be unique
  name: String

  # public: Permission GroupIds
  permissionGroupIds: [ID!]

  # public: The type of role
  type: RoleType
}

input UpdateSubscriptionInput {
  # Reason the subscription was cancelled
  cancelReason: CancellationReason

  # The date the current term will end at and the subscription will be cancelled.
  cancelledAt: Date
  currency: Currency = USD

  # End date of the current term for Free Trial or Self Serve.
  currentTermEnd: Date

  # Start date of the current term for Free Trial or Self Serve.
  currentTermStart: Date

  # Version of external subscription. Changes (increases) with every update.
  externalSubscriptionVersion: Long!

  # Subscription interval - YEAR/MONTH.
  interval: SubscriptionInterval

  # The number of licenses available for the current term.
  licenseQuantity: Int

  # The number of licenses purchased for next term.
  licenseQuantityInNextTerm: Int

  # Date at which the next billing for the subscription will occur.
  nextBillingAt: Date

  # Total amount that will be charged on `nextBillingAt` in the smallest unit of currency (e.g. USD cents). Note: does not include taxes.
  nextBillingPeriodAmount: Int

  # Start date of the next term.
  nextTermStart: Date

  # Plan type.
  planType: PlanType

  # The same plan will have multiple versions as it evolves over time.
  planVersion: Int

  # Cost per license in the smallest unit of currency (e.g. USD cents). Note: does not include taxes.
  pricePerLicense: Int

  # Subscription state.
  state: SubscriptionState
}

input UpdateTemplateInput {
  # Template category
  category: String

  # Template description
  description: String

  # Template elements
  elements: JSON

  # Template icon
  icon: String

  # Is the template active or expired
  isActive: Boolean

  # Template metadata
  metadata: JSON

  # Template name
  name: String

  # Template parameters
  parameters: JSON
  templateCollaborators: [TemplateMember!]

  # Template type - User/Organization
  type: TemplateType
}

# public: Update user input
input UpdateUserInput {
  # public: Application Role Id
  applicationRoleId: String

  # public: The email address of the user
  email: String

  # public: The first name of the user
  firstName: String

  # public: The status of the user's invitation
  invitationStatus: String

  # public: The date when they last logged in
  lastLoggedInAt: DateTime

  # public: The last name of the user
  lastName: String

  # A JSON-like key-value store. Valid keys are valid GraphQL property names. Valid values are any JSON encodable values.
  #  The values can be up 1024 bytes when JSON encoded.
  #  An ascii string 1022 characters in length become 1024 characters when encoded. Be aware of multi-byte characters.
  metadata: JSON
}

# Input type allow for the updating of walls
input UpdateWallInput {
  archived: Boolean

  # The assetId for the wall
  assetId: String

  # A unchanging uniquely generated random string used for caching
  cacheKey: String

  # The default area to show on the default workspace on loading the workspace
  defaultViewport: DefaultViewportInput

  # The ID of wall default workspace
  defaultWorkspaceId: ID
  location: String

  # A JSON-like key-value store. Valid keys are valid GraphQL property names. Valid values are any JSON encodable values.
  #  The values can be up 1024 bytes when JSON encoded.
  #  An ascii string 1022 characters in length become 1024 characters when encoded. Be aware of multi-byte characters.
  metadata: JSON
  name: String

  # The ID of the organization that owns the wall
  organizationId: ID

  # The private key of the wall
  publicKey: String
}

# public: Update workspace input
input UpdateWorkspaceInput {
  # public: Archived Date
  archivedAt: DateTime

  # public: The classification of workspace.
  classification: String

  # public: Default Role Id
  defaultRoleId: String

  # public: The description for the workspace.
  description: String

  # public: True means that all users in the organization have access to this workspace
  isPublic: Boolean

  # A JSON-like key-value store. Valid keys are valid GraphQL property names. Valid values are any JSON encodable values.
  #  The values can be up 1024 bytes when JSON encoded.
  #  An ascii string 1022 characters in length become 1024 characters when encoded. Be aware of multi-byte characters.
  metadata: JSON

  # public: The name for the workspace. It should be unique
  name: String
}

# public: A type representing a user.
type User {
  # public: The user's role with respect to the application
  applicationRole: Role!

  # public: The avatar url for the user
  avatarUrl: String

  # public: The date the was created
  createdAt: DateTime!

  # public: The email address of the user
  email: String

  # public: The first name of the user
  firstName: String

  # public: The Id of the user
  id: ID!

  # public: The status of the user's invitation
  invitationStatus: String

  # public: The date when they last logged in
  lastLoggedInAt: DateTime

  # public: The last name of the user
  lastName: String

  # A JSON-like key-value store. Valid keys are valid GraphQL property names. Valid values are any JSON encodable values.
  #  The values can be up 1024 bytes when JSON encoded.
  #  An ascii string 1022 characters in length become 1024 characters when encoded. Be aware of multi-byte characters.
  metadata(
    # which fields to include
    include: [String!]
  ): JSON

  # public: The date the user was last updated
  updatedAt: DateTime
}

# public: User event payload.
type UserEventPayload {
  # public: User Id
  userId: ID!
}

# public: User Filters
input UserFilters {
  # public: and filter
  and: [UserFilters!]

  # public: Avatar URL
  avatarUrl: StringFilter

  # public: Email
  email: StringFilter

  # public: First Name
  firstName: StringFilter

  # public: Last Logged Date
  lastLoggedInAt: DateFilter

  # public: Last Name
  lastName: StringFilter

  # public: not filter
  not: [UserFilters!]

  # public: or filter
  or: [UserFilters!]
}

# public: User login event.
type UserLogin {
  # public: actorId
  actorId: ID!

  # public: actorType
  actorType: String!

  # public: category
  category: String!

  # public: containsConfidential
  containsConfidential: Boolean!

  # public: containsPII
  containsPII: Boolean!

  # public: User Login Data
  data: UserLoginData!

  # public: date
  date: String

  # public: eventVersion
  eventVersion: String!

  # public: organizationId
  organizationId: ID

  # public: type
  type: String!

  # public: workspaceId
  workspaceId: ID
}

# public: User login data.
type UserLoginData {
  # public: Identity Provider Id
  identityProviderId: ID
}

# public: User Login Subscription
input UserLoginSubscriptionOptions {
  # public: User Id
  userId: ID
}

# public: Sort fields
enum UserOrderByField {
  # public: Order by email.
  email

  # public: Order by firstName.
  firstName

  # public: Order by last login date.
  lastLoggedInAt

  # public: Order by lastName.
  lastName
}

# public: User Ordering
input UserOrdering {
  # public: sort fields
  field: UserOrderByField!

  # public: order fields
  order: OrderBy = Asc
}

# public: User registered event.
type UserRegistered {
  # public: actorId
  actorId: ID!

  # public: actorType
  actorType: String!

  # public: category
  category: String!

  # public: containsConfidential
  containsConfidential: Boolean!

  # public: containsPII
  containsPII: Boolean!

  # public: User Registered Data
  data: UserResendActivationData!

  # public: date
  date: String

  # public: eventVersion
  eventVersion: String!

  # public: organizationId
  organizationId: ID

  # public: type
  type: String!

  # public: workspaceId
  workspaceId: ID
}

# public: User resend activation event.
type UserResendActivation {
  # public: actorId
  actorId: ID!

  # public: actorType
  actorType: String!

  # public: category
  category: String!

  # public: containsConfidential
  containsConfidential: Boolean!

  # public: containsPII
  containsPII: Boolean!

  # public: data
  data: UserResendActivationData!

  # public: date
  date: String

  # public: eventVersion
  eventVersion: String!

  # public: organizationId
  organizationId: ID

  # public: type
  type: String!

  # public: workspaceId
  workspaceId: ID
}

# public: User resend activation data.
type UserResendActivationData {
  # public: State of the user
  state: UserStateChange!

  # public: Id of the User
  userId: ID
}

# public: User password reset event.
type UserResetPassword {
  # public: actorId
  actorId: ID!

  # public: actorType
  actorType: String!

  # public: category
  category: String!

  # public: containsConfidential
  containsConfidential: Boolean!

  # public: containsPII
  containsPII: Boolean!

  # public: data
  data: UserEventPayload!

  # public: date
  date: String

  # public: eventVersion
  eventVersion: String!

  # public: organizationId
  organizationId: ID

  # public: type
  type: String!

  # public: workspaceId
  workspaceId: ID
}

# public: User state change event.
type UserStateChange {
  # public: Current state of the user
  current: String!

  # public: Previous state of the user
  previous: String!
}

# The type reflecting a user template
type UserTemplate {
  # Template member id
  collaborator: User!

  # Template member role id
  templateRole: Role!
}

# public: User updated event.
type UserUpdated {
  # public: actorId
  actorId: ID!

  # public: actorType
  actorType: String!

  # public: category
  category: String!

  # public: containsConfidential
  containsConfidential: Boolean!

  # public: containsPII
  containsPII: Boolean!

  # public: Update user event data
  data: UserUpdatedEventPayload!

  # public: date
  date: String

  # public: eventVersion
  eventVersion: String!

  # public: organizationId
  organizationId: ID

  # public: type
  type: String!

  # public: workspaceId
  workspaceId: ID
}

# public: User update event payload.
type UserUpdatedEventPayload {
  # public: Email of the user
  email: String!

  # public: First name of the user
  firstName: String!

  # public: Id of the user
  id: ID!

  # public: Last name of the user
  lastName: String!
}

# public: Subscription User Updated
input UserUpdatedSubscriptionOptions {
  # public: Id of the User
  userId: ID!
}

# public: Workspace associated to the user.
type UserWorkspace {
  # public: Archived Date
  archivedAt: DateTime

  # public: The classification of workspace.
  classification: String

  # public: Collaborators
  collaborators(
    # public: cursor
    cursor: String

    # public: filtering
    filtering: CollaboratorFilters

    # public: ordering
    ordering: [CollaboratorOrdering!]

    # public: pagination
    pagination: PaginationArgs
  ): CollaboratorsPaged!

  # public: Content Updated Date
  contentUpdatedAt: DateTime

  # public: Created Date
  createdAt: DateTime!

  # public: Default Role
  defaultRole: Role!

  # public: The description for the workspace.
  description: String

  # public: Workspace Id
  id: ID!

  # True when the user favorited the workspace
  isFavorite: Boolean!

  # public: True means that all users in the organization have access to this workspace
  isPublic: Boolean!

  # A JSON-like key-value store. Valid keys are valid GraphQL property names. Valid values are any JSON encodable values.
  #  The values can be up 1024 bytes when JSON encoded.
  #  An ascii string 1022 characters in length become 1024 characters when encoded. Be aware of multi-byte characters.
  metadata(
    # which fields to include
    include: [String!]
  ): JSON

  # public: The name for the workspace. It should be unique
  name: String!

  # public: Organization
  organization: Organization!

  # public: Owner
  owner: User!

  # public: Updated Date
  updatedAt: DateTime!
}

# public: User Workspace Filters
input UserWorkspaceFilters {
  # public: and filter
  and: [UserWorkspaceFilters!]

  # public: This filter will soon be removed. *false*: return private(collaborator/owner) and includes all public workspaces list that are in the session user organization. <br />
  #       *true*: return excludes all public workspaces to which the session user has NOT been explicitly invited to collaborate and all private workspaces to which the session user is a collaborator/owner
  associatedWorkspaces: BooleanFilter

  # public: Created Date
  createdAt: DateFilter

  # public: Id
  id: StringFilter

  # public: is public
  isPublic: BooleanFilter

  # public: name
  name: StringFilter

  # public: not filter
  not: [UserWorkspaceFilters!]

  # public: or filter
  or: [UserWorkspaceFilters!]

  # public: Organization Id
  organizationId: StringFilter

  # public: Owned by filter
  ownedBy: OwnedByFilter

  # public: updated date
  updatedAt: DateFilter
}

# public: A paginated collection of workspaces associated to the user.
type UserWorkspacesPaged {
  # public: next
  next: String

  # public: prev
  prev: String

  # public: results
  results: [UserWorkspace!]

  # public: totalItems
  totalItems: Int
}

# public: A paginated collection of users.
type UsersPaged {
  # public: next
  next: String

  # public: prev
  prev: String

  # public: results
  results: [User!]

  # public: totalItems
  totalItems: Int
}

type VerificationCodeExchange {
  # Registered Email Id
  email: ID!

  # Activation Token
  token: String!
}

input VerificationCodeExchangeInput {
  # Verfication code
  code: String!

  # Verification Id
  verificationId: String!
}

# public: The wall type.
type Wall {
  # public: The boolean value of active or inactive wall information
  archived: Boolean!

  # The assetId of the wall
  assetId: String!

  # A unchanging uniquely generated random string used for caching
  cacheKey: String

  # public: The date the wall was created
  createdAt: DateTime!

  # User who created the wall
  creator: User

  # The viewport to display on loading the default workspace
  defaultViewport: DefaultViewport

  # public: The workspace the wall loads on boot
  defaultWorkspace: Workspace

  # public: The Id of the wall
  id: ID!

  # The location of the wall
  location: String

  # A JSON-like key-value store. Valid keys are valid GraphQL property names. Valid values are any JSON encodable values.
  #  The values can be up 1024 bytes when JSON encoded.
  #  An ascii string 1022 characters in length become 1024 characters when encoded. Be aware of multi-byte characters.
  metadata(
    # which fields to include
    include: [String!]
  ): JSON

  # public: The name of the wall
  name: String!

  # public: Organization information based on specific wall
  organization: Organization!

  # The publicKey of the wall
  publicKey: String

  # User who sent a workspace the current workspace to the wall
  sender: User

  # public: The date when the wall was last updated
  updatedAt: DateTime!
}

# public: Filters for wall listing queries
input WallFilters {
  # public:
  and: [WallFilters!]

  # public:
  archived: BooleanFilter

  # The assetId for the wall
  assetId: StringFilter

  # public:
  name: StringFilter

  # public:
  not: [WallFilters!]

  # public:
  or: [WallFilters!]

  # public:
  organizationId: StringFilter
}

# public:  Types for ordering wall listings
input WallOrdering {
  # public:
  field: WallsOrderByField!

  # public:
  order: OrderBy = Asc
}

# public: Walls Orderby Field
enum WallsOrderByField {
  # public: True if the wall is archived.
  archived

  # The assetId of the wall.
  assetId

  # public: The date the wall was created.
  createdAt

  # public: The id of the wall.
  id

  # public: The name of the wall.
  name

  # public: The data the wall was last updated.
  updatedAt
}

# public: A paginated collection of walls.
type WallsPaged {
  # public: next
  next: String

  # public: prev
  prev: String

  # public: results
  results: [Wall!]

  # public: totalItems
  totalItems: Int
}

# public: The type expressing workspace management state.
type Workspace {
  # public: Archived Date
  archivedAt: DateTime

  # public: The classification of workspace.
  classification: String

  # public: Collaborators on the workspace.
  collaborators(
    # public: cursor
    cursor: String

    # public: filtering by fields
    filtering: CollaboratorFilters

    # public: ordering
    ordering: [CollaboratorOrdering!]

    # public: pagination
    pagination: PaginationArgs
  ): CollaboratorsPaged!

  # public: Content Updated Date
  contentUpdatedAt: DateTime

  # public: Created Date
  createdAt: DateTime!

  # public: The Role this workspace is associated with
  defaultRole: Role

  # public: The description for the workspace.
  description: String

  # public: Workspace Id
  id: ID!

  # public: True means that all users in the organization have access to this workspace
  isPublic: Boolean!

  # A JSON-like key-value store. Valid keys are valid GraphQL property names. Valid values are any JSON encodable values.
  #  The values can be up 1024 bytes when JSON encoded.
  #  An ascii string 1022 characters in length become 1024 characters when encoded. Be aware of multi-byte characters.
  metadata(
    # which fields to include
    include: [String!]
  ): JSON

  # public: The name for the workspace. It should be unique
  name: String!

  # public: The organization this workspace is associated with
  organization: Organization!

  # public: Owner data
  owner: User

  # public: Updated Date
  updatedAt: DateTime!
  elements: [Element]
}

# public: Workspace access request.
type WorkspaceAccessRequest {
  # public:
  createdAt: DateTime!

  # public:
  deletedAt: DateTime

  # public:
  expiredAt: DateTime!

  # public:
  id: ID!

  # public:
  requestedAt: DateTime!

  # public: The status for the workspace access request
  status: String!

  # public:
  updatedAt: DateTime!

  # public:
  user: User
}

# public: Workspace access request created event.
type WorkspaceAccessRequestCreated {
  # public: actorId
  actorId: ID!

  # public: actorType
  actorType: String!

  # public: category
  category: String!

  # public: containsConfidential
  containsConfidential: Boolean!

  # public: containsPII
  containsPII: Boolean!

  # public:
  data: WorkspaceAccessRequestPayload!

  # public: date
  date: String

  # public: eventVersion
  eventVersion: String!

  # public: organizationId
  organizationId: ID

  # public: type
  type: String!

  # public: workspaceId
  workspaceId: ID
}

# public: WorkspaceAccessRequestCreatedSubscriptionOptions
input WorkspaceAccessRequestCreatedSubscriptionOptions {
  # public:
  workspaceId: ID!
}

# public: Workspace access request filters
input WorkspaceAccessRequestFilters {
  # public:
  and: [WorkspaceAccessRequestFilters!]

  # public:
  email: StringFilter

  # public:
  firstName: StringFilter

  # public:
  lastName: StringFilter

  # public:
  not: [WorkspaceAccessRequestFilters!]

  # public:
  or: [WorkspaceAccessRequestFilters!]

  # public:
  status: StringFilter
}

# public: WorkspaceAccessRequestOrderByField
enum WorkspaceAccessRequestOrderByField {
  # public: email address
  email

  # public: first name
  firstName

  # public: family name
  lastName

  # public: access request status.
  status
}

# public: Ordering fields
input WorkspaceAccessRequestOrdering {
  # public:
  field: WorkspaceAccessRequestOrderByField!

  # public:
  order: OrderBy = Asc
}

# public: A paged collection of workspace access requests.
type WorkspaceAccessRequestPaged {
  # public: next
  next: String

  # public: prev
  prev: String

  # public: results
  results: [WorkspaceAccessRequest!]

  # public: totalItems
  totalItems: Int
}

# public: Workspace access request payload.
type WorkspaceAccessRequestPayload {
  # public:
  id: ID!

  # public: The status for the workspace access request
  status: String!

  # public:
  userId: ID!
}

# public: Workspace access request update event.
type WorkspaceAccessRequestUpdate {
  # public: actorId
  actorId: ID!

  # public: actorType
  actorType: String!

  # public: category
  category: String!

  # public: containsConfidential
  containsConfidential: Boolean!

  # public: containsPII
  containsPII: Boolean!

  # public:
  data: WorkspaceAccessRequestPayload!

  # public: date
  date: String

  # public: eventVersion
  eventVersion: String!

  # public: organizationId
  organizationId: ID

  # public: type
  type: String!

  # public: workspaceId
  workspaceId: ID
}

# public: WorkspaceAccessRequestUpdateSubscriptionOptions
input WorkspaceAccessRequestUpdateSubscriptionOptions {
  # public:
  requestId: ID!

  # public:
  userId: ID!
}

# public: Workspace created event.
type WorkspaceCreated {
  # public: actorId
  actorId: ID!

  # public: actorType
  actorType: String!

  # public: category
  category: String!

  # public: containsConfidential
  containsConfidential: Boolean!

  # public: containsPII
  containsPII: Boolean!

  # public: Workspace Created
  data: WorkspaceEventPayload!

  # public: date
  date: String

  # public: eventVersion
  eventVersion: String!

  # public: organizationId
  organizationId: ID

  # public: type
  type: String!

  # public: workspaceId
  workspaceId: ID
}

# public: Workspace duplicated event.
type WorkspaceDuplicated {
  # public: actorId
  actorId: ID!

  # public: actorType
  actorType: String!

  # public: category
  category: String!

  # public: containsConfidential
  containsConfidential: Boolean!

  # public: containsPII
  containsPII: Boolean!

  # public: Workspace Duplicated
  data: WorkspaceDuplicatedEventPayload!

  # public: date
  date: String

  # public: eventVersion
  eventVersion: String!

  # public: organizationId
  organizationId: ID

  # public: type
  type: String!

  # public: workspaceId
  workspaceId: ID
}

# public: Workspace duplicated event payload.
type WorkspaceDuplicatedEventPayload {
  # public: New Workspace
  newWorkspace: WorkspacePayload!

  # public: Organization Id
  organizationId: String!
}

# public: Workspace duplicated subscription
input WorkspaceDuplicatedSubscriptionOptions {
  # public: Workspace Id
  workspaceId: ID!
}

# public: The workspace event payload.
type WorkspaceEventPayload {
  # public: Organization Id
  organizationId: String!

  # public: Workspace Event Payload
  workspace: WorkspacePayload!
}

# public: Workspace filters
input WorkspaceFilters {
  # public: and filter
  and: [WorkspaceFilters!]

  # public: Created Date
  createdAt: DateFilter

  # public: Id
  id: StringFilter

  # public: is public
  isPublic: BooleanFilter

  # public: name
  name: StringFilter

  # public: not filter
  not: [WorkspaceFilters!]

  # public: or filter
  or: [WorkspaceFilters!]

  # public: Organization Id
  organizationId: StringFilter

  # public: updated date
  updatedAt: DateFilter
}

# public: Work space orderBy Field
enum WorkspaceOrderByField {
  # public: Order by last date the content was updated.
  contentUpdatedAt

  # public: Order by creation date.
  createdAt

  # public: Order by name.
  name

  # public: Order by last update date.
  updatedAt
}

# public: Workspace ordering
input WorkspaceOrdering {
  # public: Field
  field: WorkspaceOrderByField!

  # public: Order
  order: OrderBy = Asc
}

# public: The workspace type for a workspace event payload.
type WorkspacePayload {
  # public: Created Date
  createdAt: String!

  # public: Default Role Id
  defaultRoleId: String!

  # public: Description
  description: String

  # public: Workspace Id
  id: ID!

  # public: isPublic
  isPublic: Boolean!

  # public: The name for the workspace
  name: String!

  # public: Owner Id
  ownerId: String

  # public: Updated Date
  updatedAt: String!
}

# public: Workspace reassigned event.
type WorkspaceReassigned {
  # public: actorId
  actorId: ID!

  # public: actorType
  actorType: String!

  # public: category
  category: String!

  # public: containsConfidential
  containsConfidential: Boolean!

  # public: containsPII
  containsPII: Boolean!

  # public: Workspace Reassigned
  data: WorkspaceReassignedPayload!

  # public: date
  date: String

  # public: eventVersion
  eventVersion: String!

  # public: organizationId
  organizationId: ID

  # public: type
  type: String!

  # public: workspaceId
  workspaceId: ID
}

# public: Workspace reassign event payload.
type WorkspaceReassignedPayload {
  # public: The id of the user to whom this workspace is reassigned now
  newOwnerId: String!

  # public: The id of the user who owned this workspace previously
  oldOwnerId: String!

  # public: The workspace ids which are reassigned
  workspaceIds: [ID!]!
}

# public: Workspace Reassigned subscription
input WorkspaceReassignedSubscriptionOptions {
  # public: Old Workspace OwnerId
  oldWorkspaceOwnerId: ID!

  # public: Organization Id
  organizationId: ID!
}

# public: Workspace role event payload
type WorkspaceRolePayload {
  # public: Organization Id
  id: ID!

  # public: Workspace Role Name
  name: String!

  # public: order
  order: Float!

  # public: Workspace Role Type
  type: String!
}

# public: Workspace updated event.
type WorkspaceUpdated {
  # public: actorId
  actorId: ID!

  # public: actorType
  actorType: String!

  # public: category
  category: String!

  # public: containsConfidential
  containsConfidential: Boolean!

  # public: containsPII
  containsPII: Boolean!

  # public: Workspace Updated
  data: WorkspaceUpdatedEventPayload!

  # public: date
  date: String

  # public: eventVersion
  eventVersion: String!

  # public: organizationId
  organizationId: ID

  # public: type
  type: String!

  # public: workspaceId
  workspaceId: ID
}

# public: Workspace updated event payload.
type WorkspaceUpdatedEventPayload {
  # public: Work space Updated Event Payload
  workspace: WorkspacePayload!
}

# public: Workspace updated subscription
input WorkspaceUpdatedSubscriptionOptions {
  # public: Organization Id
  organizationId: String!

  # public: Workspace Id
  workspaceId: ID!
}

# public: A paginated collection of workspaces.
type WorkspacesPaged {
  # public: next
  next: String

  # public: prev
  prev: String

  # public: results
  results: [Workspace!]

  # public: totalItems
  totalItems: Int
}

type UpdateBrowser implements UpdateAttachable & UpdateElement {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateSimilitude
  style: UpdateBrowserStyle
  url: String
}

interface UpdateAttachable {
  pinned: Boolean
  zIndex: Int
  surface: String
}

interface UpdateElement {
  pinned: Boolean
  zIndex: Int
}

# translation relative to origin and uniform scaling. The object is translated and then scaled with the origin at the top left corner of its bounding box
type UpdateSimilitude {
  # x coordinate
  x: Float

  # y coordinate
  y: Float

  # uniform scaling factor
  scale: Float
}

type UpdateBrowserStyle {
  width: Float
  height: Float
}

type UpdateCanvas implements UpdateElement {
  pinned: Boolean
  zIndex: Int
  transform: UpdateTranslation
  style: UpdateCanvasStyle
  name: String
}

# translation relative to origin
type UpdateTranslation {
  # x coordinate
  x: Float

  # y coordinate
  y: Float
}

type UpdateCanvasStyle {
  width: Float
  height: Float

  # Beta (now accepts any RGBA color): This is a Beta feature that is still in development, the documentation and features are subject to change before their GA release. We welcome any feedback you may have that we can use to improve the final version. While we will do our best to communicate breaking changes, think careful about where you deploy integrations using them.
  borderColor: Color

  # Beta: This is a Beta feature that is still in development, the documentation and features are subject to change before their GA release. We welcome any feedback you may have that we can use to improve the final version. While we will do our best to communicate breaking changes, think careful about where you deploy integrations using them.
  fillColor: Color

  # Beta: This is a Beta feature that is still in development, the documentation and features are subject to change before their GA release. We welcome any feedback you may have that we can use to improve the final version. While we will do our best to communicate breaking changes, think careful about where you deploy integrations using them.
  showName: Boolean
}

type Color {
  r: Int!
  g: Int!
  b: Int!
  a: Float!
}

type UpdateDocument implements UpdateAssetElement & UpdateAttachable & UpdateElement {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateSimilitude
}

interface UpdateAssetElement {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateSimilitude
}

type UpdateGrid implements UpdateElement {
  pinned: Boolean
  zIndex: Int
  transform: UpdateTranslation
  rowCount: Int
  columnCount: Int

  # replacement grid cell list
  cells: [Cell!]
  style: UpdateGridStyle
}

type Cell {
  # id of the element occupying this cell
  elementId: String!
  row: Int!
  column: Int!
}

type UpdateGridStyle {
  horizontalCellMargin: Float
  verticalCellMargin: Float
  cellWidth: Float
  cellHeight: Float
}

type UpdateImage implements UpdateAssetElement & UpdateAttachable & UpdateElement {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateSimilitude
}

type UpdateLegacyNote implements UpdateAttachable & UpdateElement {
  pinned: Boolean
  zIndex: Int
  surface: String
  text: String
  transform: Similitude
  style: UpdateLegacyNoteStyle
}

# translation relative to origin and uniform scaling. The object is translated and then scaled with the origin at the top left corner of its bounding box
type Similitude {
  # x coordinate
  x: Float

  # y coordinate
  y: Float

  # x-coordinate scaling factor
  scale: Float
}

type UpdateLegacyNoteStyle {
  fontWeight: FontWeight
  textTransform: TextTransform
  backgroundColor: Color
}

# Font weight (boldness).
enum FontWeight {
  normal
  bold
}

# Text transform. The non-default value of `uppercase` may only occur in legacy text.
enum TextTransform {
  none
  uppercase
}

type UpdateLine implements UpdateAttachable & UpdateElement {
  pinned: Boolean
  zIndex: Int
  surface: String
  style: UpdateLineStyle
  routing: LineRouting
  controlPoints: [LinePoint!]
  start: LinePoint
  end: LinePoint
}

type UpdateLineStyle {
  strokeColor: Color
  strokeStyle: LineStrokeStyle
  strokeWidth: Float
  startCap: LineCapStyle
  endCap: LineCapStyle
}

# one of Solid, Dot, DashShort, DashLong
enum LineStrokeStyle {
  Solid
  Dot
  DashShort
  DashLong
}

# one of None, ArrowFill, ArrowStroke, Tee, Circle
enum LineCapStyle {
  None
  ArrowFill
  ArrowStroke
  Tee
  Circle
}

# one of Direct, Orthogonal
enum LineRouting {
  Direct
  Orthogonal
}

# A line point, which can be either an anchor or an absolute workspace coordinate
union LinePoint = AbsoluteLinePoint | AnchorLinePoint

type AbsoluteLinePoint {
  # workspace x coordinate
  x: Float!

  # workspace y coordinate
  y: Float!
}

type AnchorLinePoint {
  # element ID of anchor
  id: String!

  # position along element's horizontal
  u: Float!

  # position along element's vertical
  v: Float!
}

type UpdateRegularShapeStyle implements UpdateShapeStyle {
  width: Float
  height: Float
  strokeWidth: Float
  strokeColor: Color
  fillColor: Color
}

interface UpdateShapeStyle {
  width: Float
  height: Float
  fillColor: Color
}

type UpdateStickyShapeStyle implements UpdateShapeStyle {
  width: Float
  fillColor: Color
  height: Float
}

type UpdateShape implements UpdateAttachable & UpdateElement {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateTranslation
  style: UpdateShapeStyle
  kind: ShapeKind

  # text on shape
  text: String
  blocks: [ToplevelBlockTextContent!]
  textStyle: UpdateShapeTextStyle
  mirrorX: Boolean
  mirrorY: Boolean
}

enum ShapeKind {
  Rectangle
  Ellipse
  TriangleUp
  TriangleRight
  Diamond
  Cylinder
  ArrowUp
  ArrowRight
  ArrowUpDown
  ArrowLeftRight
  ArrowAll
  Star5
  Hexagon
  Octagon
  StickySquare
}

# Block text content that does not have to be nested inside other block content.
interface ToplevelBlockTextContent {
  align: HorizontalAlign!
}

enum HorizontalAlign {
  left
  right
  center
  justify
}

type UpdateShapeTextStyle {
  # font size in pixels. Set to "auto" to adjust font size to a shape.
  fontSize: FontSize
  verticalAlign: VerticalAlign
}

# The `FontSize` scalar type can be either integer value representing font size in pixels or "auto".
scalar FontSize

enum VerticalAlign {
  top
  center
  bottom
}

type UpdateStroke implements UpdateElement {
  pinned: Boolean
  zIndex: Int
  transform: UpdateSimilitude
}

type UpdateText implements UpdateAttachable & UpdateElement {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateTransform
  text: String @deprecated(reason: "please use \"blocks\" instead")
  blocks: [ToplevelBlockTextContent!]
  style: UpdateTextStyle
}

# translation relative to origin and scaling. The object is translated and then scaled with the origin at the top left corner of its bounding box
type UpdateTransform {
  # x coordinate
  x: Float

  # y coordinate
  y: Float

  # x-coordinate scaling factor
  scaleX: Float

  # y-coordinate scaling factor
  scaleY: Float
}

type UpdateTextStyle {
  width: Float
  height: Float
  fontSize: Int

  # Font family name.
  fontFamily: String
  color: Color
  backgroundColor: Color
  verticalAlign: VerticalAlign
}

type UpdateVideo implements UpdateAssetElement & UpdateAttachable & UpdateElement {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateSimilitude
}

type UpdateWindow implements UpdateAttachable & UpdateElement {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateSimilitude
}

input UpdateBrowserInput {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateSimilitudeInput
  style: UpdateBrowserStyleInput
  url: String
}

# translation relative to origin and uniform scaling. The object is translated and then scaled with the origin at the top left corner of its bounding box
input UpdateSimilitudeInput {
  # x coordinate
  x: Float

  # y coordinate
  y: Float

  # uniform scaling factor
  scale: Float
}

input UpdateBrowserStyleInput {
  width: Float
  height: Float
}

input UpdateCanvasInput {
  pinned: Boolean
  zIndex: Int
  transform: UpdateTranslationInput
  style: UpdateCanvasStyleInput
  name: String
}

# translation relative to origin
input UpdateTranslationInput {
  # x coordinate
  x: Float

  # y coordinate
  y: Float
}

input UpdateCanvasStyleInput {
  width: Float
  height: Float

  # Beta (now accepts any RGBA color): This is a Beta feature that is still in development, the documentation and features are subject to change before their GA release. We welcome any feedback you may have that we can use to improve the final version. While we will do our best to communicate breaking changes, think careful about where you deploy integrations using them.
  borderColor: ColorInput

  # Beta: This is a Beta feature that is still in development, the documentation and features are subject to change before their GA release. We welcome any feedback you may have that we can use to improve the final version. While we will do our best to communicate breaking changes, think careful about where you deploy integrations using them.
  fillColor: ColorInput

  # Beta: This is a Beta feature that is still in development, the documentation and features are subject to change before their GA release. We welcome any feedback you may have that we can use to improve the final version. While we will do our best to communicate breaking changes, think careful about where you deploy integrations using them.
  showName: Boolean
}

input ColorInput {
  r: Int = 0
  g: Int = 0
  b: Int = 0
  a: Float = 1
}

input UpdateDocumentInput {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateSimilitudeInput = {}
}

input UpdateGridInput {
  pinned: Boolean
  zIndex: Int
  transform: UpdateTranslationInput
  rowCount: Int
  columnCount: Int

  # replacement grid cell list
  cells: [CellInput!]
  style: UpdateGridStyleInput
}

input CellInput {
  # id of the element occupying this cell
  elementId: String!
  row: Int!
  column: Int!
}

input UpdateGridStyleInput {
  horizontalCellMargin: Float
  verticalCellMargin: Float
  cellWidth: Float
  cellHeight: Float
}

input UpdateImageInput {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateSimilitudeInput = {}
}

input UpdateStrokeInput {
  pinned: Boolean
  zIndex: Int
  transform: UpdateSimilitudeInput
}

input UpdateVideoInput {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateSimilitudeInput = {}
}

input UpdateWindowInput {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateSimilitudeInput
}

# web browser
type Browser implements Element & Attachable & Surface & Selectable {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  attachments(type: [AttachableType!]): [Attachable!]!
  surface: Surface
  url: String
  style: BrowserStyle!
}

# Basic workspace building block
interface Element {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
}

# translation relative to origin and scaling. The object is translated and then scaled with the origin at the top left corner of its bounding box
type Transform {
  # x coordinate
  x: Float!

  # y coordinate
  y: Float!

  # x-coordinate scaling factor
  scaleX: Float!

  # y-coordinate scaling factor
  scaleY: Float!
}

# Comment
type Comment {
  id: ID!

  # Parent comment id.
  parentId: String
  createdAt: DateTime!

  # Identity of commenter.
  actorId: ID!
  actorType: String!

  # Text contents of `.blocks`, extracted without structure and joined by newline characters.
  text: String!

  # First and last name of the commenter.
  commenterName: String!

  # JSON-LD-conforming document representing arbitrary persistent metadata of the comment.
  traits: JSONObject

  # Blocks of comment text.
  blocks: [CommentBlock!]!
}

# The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
scalar JSONObject

# Comment block
type CommentBlock {
  # Structured comment content.
  content: [InlineCommentContentJSON!]!
}

# Comment content as JSON, conforming to the GraphQL SDL definition of `InlineCommentContent`. See the SDL definition for details.
scalar InlineCommentContentJSON

# Bounding box of an element, relative to the origin
type Box {
  # x-coordinate of the top left corner
  x: Float!

  # y-coordinate of the top left corner
  y: Float!

  # width
  width: Float!

  # height
  height: Float!
}

# Element that can be attached to other elements
interface Attachable {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  surface: Surface
}

# Element to which other elements can be attached
interface Surface {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  attachments(type: [AttachableType!]): [Attachable!]!
}

# Attachable Element type
enum AttachableType {
  Text
  LegacyNote
  Image
  Document
  Browser
  Video
  Stroke
  Shape
  Line
  Window
  Whiteboard
  LinkedDocument
}

# Element that can be selected/grouped
interface Selectable {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
}

type BrowserStyle {
  frameless: Boolean!
  width: Float!
  height: Float!
}

# Rectangular area of the workspace
type Canvas implements Element {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  name: String!
  style: CanvasStyle!
}

type CanvasStyle {
  width: Float!
  height: Float!

  # Beta (now accepts any RGBA color): This is a Beta feature that is still in development, the documentation and features are subject to change before their GA release. We welcome any feedback you may have that we can use to improve the final version. While we will do our best to communicate breaking changes, think careful about where you deploy integrations using them.
  borderColor: Color!

  # Beta: This is a Beta feature that is still in development, the documentation and features are subject to change before their GA release. We welcome any feedback you may have that we can use to improve the final version. While we will do our best to communicate breaking changes, think careful about where you deploy integrations using them.
  fillColor: Color!

  # Beta: This is a Beta feature that is still in development, the documentation and features are subject to change before their GA release. We welcome any feedback you may have that we can use to improve the final version. While we will do our best to communicate breaking changes, think careful about where you deploy integrations using them.
  showName: Boolean!
}

# multipage document with navigation capabilities
type Document implements Element & Attachable & Surface & Selectable & AssetBacked {
  # Intrinsic asset width
  width: Float!

  # Intrinsic asset height
  height: Float!

  # Asset title
  title: String!

  # Original filename, if the asset was uploaded directly by the client (as opposed to from URL)
  filename: String

  # Source URL, if the asset was uploaded via URL
  sourceUrl: String

  # asset url, provided if asset download is allowed and asset format
  preview: ImageAsset
  ingestionState: AssetIngestionState!

  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  attachments(type: [AttachableType!]): [Attachable!]!
  surface: Surface

  # asset url, provided if asset download is allowed and asset format
  asset: DocumentAsset!
}

# Elements backed by immutable assets
interface AssetBacked {
  # Intrinsic asset width
  width: Float!

  # Intrinsic asset height
  height: Float!

  # Asset title
  title: String!

  # Original filename, if the asset was uploaded directly by the client (as opposed to from URL)
  filename: String

  # Source URL, if the asset was uploaded via URL
  sourceUrl: String

  # asset url, provided if asset download is allowed and asset format
  preview: ImageAsset
  ingestionState: AssetIngestionState!
}

# Image asset information
type ImageAsset {
  imageFormat: ImageFormat!

  # asset url, provided if asset download is allowed
  url(scale: AssetScale): String
}

enum ImageFormat {
  jpeg
  gif
  png
  tiff
  unknown
}

enum AssetScale {
  Original
  High
  Medium
  Low
}

# Ingestion state
enum AssetIngestionState {
  processing
  complete_success
  complete_failure
  transferring
}

# Document asset information
type DocumentAsset {
  documentFormat: DocumentFormat!

  # asset url, provided if asset download is allowed
  url(scale: AssetScale): String
}

enum DocumentFormat {
  doc
  docx
  ppt
  pptx
  xls
  xlsx
  pdf
  unknown
}

# Element grid
type Grid implements Element {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  rowCount: Int!
  columnCount: Int!
  cells: [Cell!]!
  style: GridStyle!
}

type GridStyle {
  horizontalCellMargin: Float!
  verticalCellMargin: Float!
  cellWidth: Float!
  cellHeight: Float!
}

# Image
type Image implements Element & Attachable & Surface & Selectable & AssetBacked {
  # Intrinsic asset width
  width: Float!

  # Intrinsic asset height
  height: Float!

  # Asset title
  title: String!

  # Original filename, if the asset was uploaded directly by the client (as opposed to from URL)
  filename: String

  # Source URL, if the asset was uploaded via URL
  sourceUrl: String

  # asset url, provided if asset download is allowed and asset format
  preview: ImageAsset
  ingestionState: AssetIngestionState!

  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  attachments(type: [AttachableType!]): [Attachable!]!
  surface: Surface

  # asset url, provided if asset download is allowed and asset format
  asset: ImageAsset!
}

# Legacy Note card
type LegacyNote implements Element & Attachable & Surface & Selectable {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  attachments(type: [AttachableType!]): [Attachable!]!
  surface: Surface
  width: Float!
  height: Float!

  # LegacyNote content
  text: String!
  style: LegacyNoteStyle!
}

type LegacyNoteStyle {
  # Font size in pixels.
  fontSize: Int!
  fontWeight: FontWeight!
  textTransform: TextTransform!
  backgroundColor: Color!
}

# Predefined shape
type Line implements Element & Attachable & Selectable {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  surface: Surface
  start: LinePoint!
  end: LinePoint!
  controlPoints: [LinePoint!]
  routing: LineRouting!
  style: LineStyle!
}

type LineStyle {
  strokeColor: Color!
  strokeStyle: LineStrokeStyle!
  strokeWidth: Float!
  startCap: LineCapStyle!
  endCap: LineCapStyle!
}

# linked document (OneDrive)
type LinkedDocument implements Element & Attachable & Surface & Selectable {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  attachments(type: [AttachableType!]): [Attachable!]!
  surface: Surface
  url: String
  style: LinkedDocumentStyle!
}

type LinkedDocumentStyle {
  width: Float!
  height: Float!
}

# Selection of elements
type Selection implements Element {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  selected: [Element!]!
}

# List of items.
type TextList implements BlockTextContent & ToplevelBlockTextContent {
  align: HorizontalAlign!
  kind: TextListKind!
  items: [TextListItem!]!
}

# Range of text content that starts on a new line and takes up the full width available.
interface BlockTextContent {
  align: HorizontalAlign!
}

enum TextListKind {
  ordered
  bullet
}

# List item nested in a list.
type TextListItem implements BlockTextContent {
  align: HorizontalAlign!

  # Indentation level of a list item, as a non-negative number.
  indent: Int!

  # Structured inline text content.
  content: [InlineTextContentJSON!]!
}

# Inline Text content as JSON, conforming to the GraphQL SDL definition `InlineTextContent`. See the SDL definition for details.
scalar InlineTextContentJSON

# Structured block of text.
type TextBlock implements BlockTextContent & ToplevelBlockTextContent {
  align: HorizontalAlign!

  # Structured inline text content.
  content: [InlineTextContentJSON!]!
}

type RegularShapeStyle implements ShapeStyle {
  width: Float!
  height: Float!
  strokeWidth: Float!
  strokeColor: Color!
  fillColor: Color!
}

interface ShapeStyle {
  width: Float!
  height: Float!
  fillColor: Color!
}

type StickyShapeStyle implements ShapeStyle {
  width: Float!
  fillColor: Color!
  height: Float!
}

# Predefined shape
type Shape implements Element & Attachable & Surface & Selectable {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  attachments(type: [AttachableType!]): [Attachable!]!
  surface: Surface
  style: ShapeStyle!

  # predefined shape geometry
  kind: ShapeKind!

  # text on shape
  text: String
  blocks: [ToplevelBlockTextContent!]
  textStyle: ShapeTextStyle!

  # if true, flip the predefined shape around the X-axis
  mirrorX: Boolean!

  # if true, flip the predefined shape around the Y-axis
  mirrorY: Boolean!

  # if true, the shape will maintain its initial aspect ratio
  aspectRatioFixed: Boolean!
}

# style of text on shape
type ShapeTextStyle {
  # font size in pixels. Set to "auto" to adjust font size to a shape.
  fontSize: FontSize!
  verticalAlign: VerticalAlign!

  # font family
  fontFamily: String!
}

# freehand stroke
type Stroke implements Element & Attachable & Selectable {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  surface: Surface

  # stroke locations as a list of pairs,
  #   where coordinates are paired '[x, y, x, y, x, y, ...]' in an array,
  #   in the coordinate space of the containing object
  points: [Float!]!
  style: StrokeStyle!
}

type StrokeStyle {
  color: Color!
  strokeWidth: Float!
  brushType: StrokeBrush!
}

enum StrokeBrush {
  Pen
  Eraser
}

# Rich text.
type Text implements Element & Attachable & Selectable {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  surface: Surface

  # text content of this text element
  text: String!
  style: TextStyle!
  blocks: [ToplevelBlockTextContent!]!
}

type TextStyle {
  textTransform: TextTransform!

  # Font size in pixels.
  fontSize: Int!

  # Font family name.
  fontFamily: String!
  verticalAlign: VerticalAlign!
  color: Color!
  backgroundColor: Color!
  width: Float!
  height: Float!
}

# Video file asset asset
type Video implements Element & Attachable & Surface & Selectable & AssetBacked {
  # Intrinsic asset width
  width: Float!

  # Intrinsic asset height
  height: Float!

  # Asset title
  title: String!

  # Original filename, if the asset was uploaded directly by the client (as opposed to from URL)
  filename: String

  # Source URL, if the asset was uploaded via URL
  sourceUrl: String

  # asset url, provided if asset download is allowed and asset format
  preview: ImageAsset
  ingestionState: AssetIngestionState!

  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  attachments(type: [AttachableType!]): [Attachable!]!
  surface: Surface

  # asset url, provided if asset download is allowed and asset format
  asset: VideoAsset!
}

# Video asset information
type VideoAsset {
  videoFormat: VideoFormat!

  # asset url, provided if asset download is allowed
  url(scale: AssetScale): String
}

enum VideoFormat {
  mp4
  quicktime
  unknown
}

# whiteboard
type Whiteboard implements Element & Attachable & Surface & Selectable {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  attachments(type: [AttachableType!]): [Attachable!]!
  surface: Surface
  style: WhiteboardStyle!
  preview: String
}

type WhiteboardStyle {
  width: Float!
  height: Float!
}

# Generic rectangular element with possibly custom content
type Window implements Element & Attachable & Surface & Selectable {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  attachments(type: [AttachableType!]): [Attachable!]!
  surface: Surface
  style: WindowStyle!
}

type WindowStyle {
  # Extrinsic window width
  width: Float!

  # Extrinsic window height
  height: Float!
}

type CreateElementCommand implements Command & HistoryCommand {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!

  # Unique idenfitier of the client instance issuing the command
  clientId: ID!
  element: Element!
}

interface Command {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!
}

interface HistoryCommand {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!

  # Unique idenfitier of the client instance issuing the command
  clientId: ID!
}

type UpdateElementCommand implements Command & HistoryCommand {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!

  # Unique idenfitier of the client instance issuing the command
  clientId: ID!

  # Workspace-unique element id
  elementId: ID!
  data: UpdateElement!
}

type DeleteElementCommand implements Command & HistoryCommand {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!

  # Unique idenfitier of the client instance issuing the command
  clientId: ID!

  # Workspace-unique element id
  elementId: ID!
  elementType: ElementType!
}

# Element type
enum ElementType {
  Text
  LegacyNote
  Image
  Document
  Grid
  Browser
  Video
  Stroke
  Shape
  Line
  LinkedDocument
  Canvas
  Selection
  Window
  Whiteboard
}

type UpdateTraitsCommand implements Command & HistoryCommand {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!

  # Unique idenfitier of the client instance issuing the command
  clientId: ID!

  # Workspace-unique element id
  elementId: ID!
  elementType: ElementType!

  # JSON-LD-conforming document representing arbitrary persistent metadata of the element
  traits: JSONObject!
}

type CreateCommentCommand implements Command & HistoryCommand {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!

  # Unique idenfitier of the client instance issuing the command
  clientId: ID!

  # Workspace-unique element id
  elementId: ID!
  elementType: ElementType!
  comment: Comment!
}

type AttachCommand implements Command & HistoryCommand & AdhesionCommand {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!

  # Unique idenfitier of the client instance issuing the command
  clientId: ID!

  # id of attachable element
  elementId: ID!
  zIndex: Int
  transform: Transform
  elementType: ElementType!

  # id of the target surface
  surfaceId: String
}

interface AdhesionCommand {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!

  # Unique idenfitier of the client instance issuing the command
  clientId: ID!

  # id of attachable element
  elementId: ID!
  zIndex: Int
  transform: Transform
  elementType: ElementType!
}

type DetachCommand implements Command & HistoryCommand & AdhesionCommand {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!

  # Unique idenfitier of the client instance issuing the command
  clientId: ID!

  # id of attachable element
  elementId: ID!
  zIndex: Int
  transform: Transform
  elementType: ElementType!
}

type UploadAssetCommand implements Command & HistoryCommand {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!

  # Unique idenfitier of the client instance issuing the command
  clientId: ID!

  # Workspace-unique element id
  elementId: ID!
  elementType: ElementType!
  ingestionState: AssetIngestionState!

  # JSON-LD-conforming document representing arbitrary persistent metadata of the element
  traits: JSONObject
}

type UpdateWorkspaceCommand implements Command & HistoryCommand {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!

  # Unique idenfitier of the client instance issuing the command
  clientId: ID!
  style: UpdateWorkspaceStyle
}

type UpdateWorkspaceStyle {
  backgroundTheme: BackgroundTheme
}

# one of dark, light
enum BackgroundTheme {
  dark
  light
}

type WorkspaceState {
  # a cursor ID for commands subscription
  cursor: ID!
  style: WorkspaceStyle!
  elements: [Element!]!
}

type WorkspaceStyle {
  backgroundTheme: BackgroundTheme!
}

# Open-ended metadata properties attached to an element, based on JSON-LD
input TraitInput {
  # JSON-LD context specified as a JSON object, an URL pointing to the location of a JSON-LD context document, or an array of either
  context: JSON

  # JSON-LD document describing element traits
  content: JSONObject!

  # Common prefix used to expand short property names to URIs, whenever a more specific expansion is not defined in the context.
  vocab: String
}

input Viewport {
  x: Float!
  y: Float!
  width: Float!
  height: Float!
}

# Bounding box of an element, relative to the origin
input BoxInput {
  # x-coordinate of the top left corner
  x: Float = 0

  # y-coordinate of the top left corner
  y: Float = 0

  # width
  width: Float = 0

  # height
  height: Float = 0
}

# Find Availabile Area search order direction
enum FindAvailableAreaDirection {
  left
  right
  up
  down
}

input TransferCompleteInput {
  errorCode: String
  errorMessage: String
}

type UpdateWorkspaceStyleResponse {
  # id of modified workspace.
  workspaceId: String!
}

input UpdateWorkspaceStyleInput {
  backgroundTheme: BackgroundTheme
}

# Comment creation input.
input CommentInput {
  blocks: [CommentBlockInput!]!

  # Parent comment id.
  parentId: String

  # JSON-LD-conforming document representing arbitrary persistent metadata of the comment.
  traits: JSONObject
}

# Comment block input
input CommentBlockInput {
  content: [InlineCommentContent!]!
}

# Input union of either plain text or mention.
input InlineCommentContent {
  mention: TextMention

  # Plain text content. Newline characters are ignored.
  text: String
}

# User, group or all workspace collaborators mention.
input TextMention {
  # User or group id. Must be absent or `null` if `.targetType` is `all`.
  targetId: String
  targetType: MentionTargetType!
}

enum MentionTargetType {
  group
  user
  all
}

input CreateCanvasInput {
  traits: TraitInput
  pinned: Boolean = false
  zIndex: Int
  transform: TranslationInput = { x: 0, y: 0 }
  style: CanvasStyleInput
  name: String!
}

# translation relative to origin
input TranslationInput {
  # x coordinate
  x: Float = 0

  # y coordinate
  y: Float = 0
}

input CanvasStyleInput {
  width: Float = 1000
  height: Float = 1000

  # Beta (now accepts any RGBA color): This is a Beta feature that is still in development, the documentation and features are subject to change before their GA release. We welcome any feedback you may have that we can use to improve the final version. While we will do our best to communicate breaking changes, think careful about where you deploy integrations using them.
  borderColor: ColorInput = { r: 238, g: 85, b: 80, a: 1 }

  # Beta: This is a Beta feature that is still in development, the documentation and features are subject to change before their GA release. We welcome any feedback you may have that we can use to improve the final version. While we will do our best to communicate breaking changes, think careful about where you deploy integrations using them.
  fillColor: ColorInput = { r: 0, g: 0, b: 0, a: 0 }

  # Beta: This is a Beta feature that is still in development, the documentation and features are subject to change before their GA release. We welcome any feedback you may have that we can use to improve the final version. While we will do our best to communicate breaking changes, think careful about where you deploy integrations using them.
  showName: Boolean = false
}

type UpdateElementResponse {
  id: String!
}

input CreateStrokeInput {
  traits: TraitInput
  pinned: Boolean = false
  zIndex: Int

  # Id of the surface to which this element is attached
  surface: String
  transform: SimilitudeInput = { x: 0, y: 0, scale: 1 }
  style: StrokeStyleInput
  points: [Float!]!
}

# translation relative to origin and uniform scaling. The object is translated and then scaled with the origin at the top left corner of its bounding box
input SimilitudeInput {
  # x coordinate
  x: Float = 0

  # y coordinate
  y: Float = 0

  # x-coordinate scaling factor
  scale: Float = 1
}

input StrokeStyleInput {
  color: ColorInput = { r: 255, g: 255, b: 255, a: 1 }
  strokeWidth: Float = 1
  brushType: StrokeBrush = Pen
}

input CreateTextInput {
  traits: TraitInput
  pinned: Boolean = false
  zIndex: Int
  surface: String
  transform: TransformInput = { x: 0, y: 0, scaleX: 1, scaleY: 1 }
  style: TextStyleInput

  # Plain multiline text, exclusive with `.blocks`. A shorthand alternative for producing a sequence of left-aligned blocks of text with no additional styling.
  text: String

  # A list of blocks of structured text content, exclusive with `.text`.
  blocks: [ToplevelBlockTextContentInput!]
}

# translation relative to origin and scaling. The object is translated and then scaled with the origin at the top left corner of its bounding box
input TransformInput {
  # x coordinate
  x: Float = 0

  # y coordinate
  y: Float = 0

  # x-coordinate scaling factor
  scaleX: Float = 1

  # y-coordinate scaling factor
  scaleY: Float = 1
}

input TextStyleInput {
  textTransform: TextTransform = none

  # Font size in pixels.
  fontSize: Int = 64

  # Font family name.
  fontFamily: String = "Dosis"
  verticalAlign: VerticalAlign = top
  color: ColorInput = { r: 255, g: 255, b: 255, a: 1 }
  backgroundColor: ColorInput = { r: 0, g: 0, b: 0, a: 0 }

  # if omitted, width will be computed based on text content
  width: Float

  # if omitted, height will be computed based on text content
  height: Float
}

# Input union of block text content input.
input ToplevelBlockTextContentInput {
  block: TextBlockInput
  list: TextListInput

  # Plain text. A shorthand alternative to the `.block` property, producing a single, left-aligned block of text with no additional styling. Newlines are ignored.
  text: String
}

# Structured block of text.
input TextBlockInput {
  align: HorizontalAlign

  # Plain text, exclusive with `.content`. A shorthand alternative to specifying block content, producing a single, left-aligned block of text with no additional styling. Newlines are ignored.
  text: String

  # Structured inline text content, exclusive with `.text`.
  content: [InlineTextContent!]
}

# Input union of inline text content input.
input InlineTextContent {
  link: TextLink
  text: String
  span: TextSpan
}

input TextLink {
  url: String!

  # Plain text, exclusive with `.content`. A shorthand alternative to specifying inline content, producing a single range of text with no additional styling. Newlines are ignored.
  text: String

  # Structured inline text content, exclusive with `.text`.
  content: [InlineTextContent!]
}

# Adds attributes to nested text content.
input TextSpan {
  # Font family name.
  fontFamily: String

  # Font size in pixels.
  fontSize: Int

  # Normal or bold font weight. If absent, implies that the actual value is inherited from ancestor spans, or `normal` if no ancestor specifies it.
  fontWeight: FontWeight

  # Normal or italic font style. If absent, implies that the actual value is inherited from ancestor spans, or `normal` if no ancestor specifies it.
  fontStyle: FontStyle
  textDecoration: [TextDecoration!]
  color: ColorInput
  backgroundColor: ColorInput

  # Plain text, exclusive with `.content`. A shorthand alternative to specifying inline content, producing a single range of text with no additional styling. Newlines are ignored.
  text: String

  # Structured inline text content, exclusive with `.text`.
  content: [InlineTextContent!]
}

# Italicization.
enum FontStyle {
  normal
  italic
}

# Appearance of decorative lines on text.
enum TextDecoration {
  underline
  lineThrough
}

# List of items.
input TextListInput {
  kind: TextListKind!
  items: [TextListItemInput!]!
}

input TextListItemInput {
  # Indentation level of a list item, as a non-negative number.
  indent: Int = 0

  # Plain text, exclusive with `.content`. A shorthand alternative to specifying block content, producing a single, left-aligned block of text with no additional styling. Newlines are ignored.
  text: String

  # Structured inline text content, exclusive with `.text`.
  content: [InlineTextContent!]
}

input UpdateTextInput {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateTransformInput

  # Plain multiline text, exclusive with `.blocks`. A shorthand alternative for producing a sequence of left-aligned blocks of text with no additional styling.
  text: String

  # A list of blocks of structured text content, exclusive with `.text`.
  blocks: [ToplevelBlockTextContentInput!]
  style: UpdateTextStyleInput
}

# translation relative to origin and scaling. The object is translated and then scaled with the origin at the top left corner of its bounding box
input UpdateTransformInput {
  # x coordinate
  x: Float

  # y coordinate
  y: Float

  # x-coordinate scaling factor
  scaleX: Float

  # y-coordinate scaling factor
  scaleY: Float
}

input UpdateTextStyleInput {
  width: Float
  height: Float
  fontSize: Int

  # Font family name.
  fontFamily: String
  color: ColorInput
  backgroundColor: ColorInput
  verticalAlign: VerticalAlign
}

input CreateWindowInput {
  traits: TraitInput
  pinned: Boolean = false
  zIndex: Int
  surface: String
  transform: SimilitudeInput = { x: 0, y: 0, scale: 1 }
  style: WindowStyleInput
}

input WindowStyleInput {
  # Extrinsic window width
  width: Float = 0

  # Extrinsic window height
  height: Float = 0
}

input CreateGridInput {
  traits: TraitInput
  pinned: Boolean = false
  zIndex: Int
  transform: TranslationInput = { x: 0, y: 0 }
  style: GridStyleInput
  rowCount: Int = 5
  columnCount: Int = 5
  cells: [CellInput!]!
}

input GridStyleInput {
  horizontalCellMargin: Float = 5
  verticalCellMargin: Float = 5
  cellWidth: Float = 1000
  cellHeight: Float = 1000
}

# Return value for the creation of a video call.
type CreateVideoResponse {
  # Upload form data for use when uploading asset to storage. If the input has provided a sourceUrl instead, this field will be null.
  content: UploadData

  # Upload form data for use when uploading asset preview to storage. If the input has provided a sourceUrl instead, this field will be null.
  preview: UploadData

  # Video entity that has been created.
  video: Video!
}

# Describes data about how to upload something to storage (an image, a document, a video preview image, etc)
type UploadData {
  # upload ID
  uploadId: String!

  # URL for uploading asset data, valid for a limited time
  url: String!

  # POST form data to supply on upload
  fields: JSONObject!
}

# If the dimensions of the asset to be uploaded are known and are provided as width/height the transform can be used to position and scale the asset. If the dimensions of the asset to be uploaded are unknown then width and height will specify the bounding box for the asset, and the transform will be used to position and or scale it. Once uploaded, the asset will be positioned in the center of the bounding box and scaled to fit it.
input CreateVideoInput {
  traits: TraitInput
  pinned: Boolean = false
  zIndex: Int
  surface: String

  # The transform of an asset bounding box. The asset position, size and scale may be automatically adjusted once the asset is uploaded.
  transform: SimilitudeInput = { x: 0, y: 0, scale: 1 }

  # Original filename of the uploaded asset, without a path. Do not use this field if you are doing an upload by URL.
  filename: String

  # URL of the source data of an image. This is optional; either the client can perform the upload to storage (typically for locally stored assets) and not provide this url or, given this url, the system will perform the upload (typically signed urls for cloud stored data).
  sourceUrl: String
  title: String

  # The width of a bounding box that an asset should fit into.
  width: Float = 1000

  # The height of a bounding box that an asset should fit into.
  height: Float = 1000

  # Format type of preview image (optional).
  previewFormat: ImageFormatInput
  videoFormat: VideoFormatInput!
}

enum ImageFormatInput {
  jpeg
  jpg
  gif
  png
  tiff
  tif
  jpegMime
  gifMime
  pngMime
  tiffMime
}

enum VideoFormatInput {
  mp4
  mov
  m4v
  quicktime
  mp4Mime
  m4vMime
  quicktimeMime
}

input CreateBrowserInput {
  traits: TraitInput
  pinned: Boolean = false
  zIndex: Int
  surface: String
  transform: SimilitudeInput = { x: 0, y: 0, scale: 1 }
  style: BrowserStyleInput
  url: String
}

input BrowserStyleInput {
  frameless: Boolean = false
  width: Float = 800
  height: Float = 600
}

# Return value for the creation of an image call.
type CreateImageResponse {
  # Upload form data for use when uploading asset to storage. If the input has provided a sourceUrl instead, this field will be null.
  content: UploadData

  # Upload form data for use when uploading asset preview to storage. If the input has provided a sourceUrl instead, this field will be null.
  preview: UploadData

  # Image entity that has been created.
  image: Image!
}

# If the dimensions of the asset to be uploaded are known and are provided as width/height the transform can be used to position and scale the asset. If the dimensions of the asset to be uploaded are unknown then width and height will specify the bounding box for the asset, and the transform will be used to position and or scale it. Once uploaded, the asset will be positioned in the center of the bounding box and scaled to fit it.
input CreateImageInput {
  traits: TraitInput
  pinned: Boolean = false
  zIndex: Int
  surface: String

  # The transform of an asset bounding box. The asset position, size and scale may be automatically adjusted once the asset is uploaded.
  transform: SimilitudeInput = { x: 0, y: 0, scale: 1 }

  # Original filename of the uploaded asset, without a path. Do not use this field if you are doing an upload by URL.
  filename: String

  # URL of the source data of an image. This is optional; either the client can perform the upload to storage (typically for locally stored assets) and not provide this url or, given this url, the system will perform the upload (typically signed urls for cloud stored data).
  sourceUrl: String
  title: String

  # The width of a bounding box that an asset should fit into.
  width: Float = 1000

  # The height of a bounding box that an asset should fit into.
  height: Float = 1000

  # Format type of preview image (optional).
  previewFormat: ImageFormatInput
  imageFormat: ImageFormatInput!
}

# Return value for the creation of a document call.
type CreateDocumentResponse {
  # Upload form data for use when uploading asset to storage. If the input has provided a sourceUrl instead, this field will be null.
  content: UploadData

  # Upload form data for use when uploading asset preview to storage. If the input has provided a sourceUrl instead, this field will be null.
  preview: UploadData

  # Document entity that has been created.
  document: Document!
}

# If the dimensions of the asset to be uploaded are known and are provided as width/height the transform can be used to position and scale the asset. If the dimensions of the asset to be uploaded are unknown then width and height will specify the bounding box for the asset, and the transform will be used to position and or scale it. Once uploaded, the asset will be positioned in the center of the bounding box and scaled to fit it.
input CreateDocumentInput {
  traits: TraitInput
  pinned: Boolean = false
  zIndex: Int
  surface: String

  # The transform of an asset bounding box. The asset position, size and scale may be automatically adjusted once the asset is uploaded.
  transform: SimilitudeInput = { x: 0, y: 0, scale: 1 }

  # Original filename of the uploaded asset, without a path. Do not use this field if you are doing an upload by URL.
  filename: String

  # URL of the source data of an image. This is optional; either the client can perform the upload to storage (typically for locally stored assets) and not provide this url or, given this url, the system will perform the upload (typically signed urls for cloud stored data).
  sourceUrl: String
  title: String

  # The width of a bounding box that an asset should fit into.
  width: Float = 1000

  # The height of a bounding box that an asset should fit into.
  height: Float = 1000

  # Format type of preview image (optional).
  previewFormat: ImageFormatInput
  documentFormat: DocumentFormatInput!
}

enum DocumentFormatInput {
  doc
  docx
  ppt
  pptx
  xls
  xlsx
  pdf
  docMime
  docxMime
  pptMime
  pptxMime
  xlsMime
  xlsxMime
  pdfMime
}

input CreateShapeInput {
  traits: TraitInput
  pinned: Boolean = false
  zIndex: Int
  surface: String
  transform: TranslationInput = { x: 0, y: 0 }
  style: ShapeStyleInputUnion!

  # text on shape
  text: String

  # Structured text content on shape, exclusive with `.text`. Does not support fontSize, fontFamily, color and backgroundColor styles.
  blocks: [ToplevelBlockTextContentInput!]
  textStyle: ShapeTextStyleInput
  mirrorX: Boolean = false
  mirrorY: Boolean = false
}

# Input union of shape styles.
input ShapeStyleInputUnion {
  regularShape: RegularShapeStyleInput
  stickyShape: StickyShapeStyleInput
}

input RegularShapeStyleInput {
  width: Float = 600
  height: Float = 600
  strokeWidth: Float = 8
  strokeColor: ColorInput = { r: 255, g: 255, b: 255, a: 1 }
  fillColor: ColorInput = { r: 0, g: 0, b: 0, a: 1 }

  # predefined shape geometry
  kind: RegularShapeKind!
}

enum RegularShapeKind {
  Rectangle
  Ellipse
  TriangleUp
  TriangleRight
  Diamond
  Cylinder
  ArrowUp
  ArrowRight
  ArrowUpDown
  ArrowLeftRight
  ArrowAll
  Star5
  Hexagon
  Octagon
}

# Sticky shapes have a fixed aspect ratio. The height will be calculated based on the width
input StickyShapeStyleInput {
  width: Float = 600
  fillColor: ColorInput = { r: 0, g: 0, b: 0, a: 1 }

  # predefined shape geometry
  kind: StickyShapeKind!
}

enum StickyShapeKind {
  StickySquare
}

# style of text on shape
input ShapeTextStyleInput {
  # font size in pixels. Set to "auto" to adjust font size to a shape.
  fontSize: FontSize = "auto"
  verticalAlign: VerticalAlign = center
}

input UpdateShapeInput {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateTranslationInput
  style: UpdateShapeStyleInputUnion

  # text on shape
  text: String

  # Structured text content on shape, exclusive with `.text`. Does not support fontSize, fontFamily, color and backgroundColor styles.
  blocks: [ToplevelBlockTextContentInput!]
  textStyle: UpdateShapeTextStyleInput
  mirrorX: Boolean
  mirrorY: Boolean
}

# Input union of shape styles.
input UpdateShapeStyleInputUnion {
  regularShape: UpdateRegularShapeStyleInput
  stickyShape: UpdateStickyShapeStyleInput
}

input UpdateRegularShapeStyleInput {
  width: Float
  height: Float
  strokeWidth: Float
  strokeColor: ColorInput
  fillColor: ColorInput

  # predefined shape geometry
  kind: RegularShapeKind
}

# Sticky shapes have a fixed aspect ratio. The height will be calculated based on the width
input UpdateStickyShapeStyleInput {
  width: Float
  fillColor: ColorInput

  # predefined shape geometry
  kind: StickyShapeKind
}

input UpdateShapeTextStyleInput {
  # font size in pixels. Set to "auto" to adjust font size to a shape.
  fontSize: FontSize
  verticalAlign: VerticalAlign
}

input CreateLineInput {
  traits: TraitInput
  pinned: Boolean = false
  zIndex: Int
  surface: String
  style: LineStyleInput
  routing: LineRouting = Direct
  controlPoints: [LinePointInput!]
  start: LinePointInput!
  end: LinePointInput!
}

input LineStyleInput {
  strokeColor: ColorInput = { r: 255, g: 255, b: 255, a: 1 }
  strokeStyle: LineStrokeStyle = Solid
  strokeWidth: Float = 0
  startCap: LineCapStyle = None
  endCap: LineCapStyle = None
}

input LinePointInput {
  anchor: AnchorLinePointInput
  absolute: AbsoluteLinePointInput
}

input AnchorLinePointInput {
  # element ID of anchor
  id: String!

  # position along element's horizontal
  u: Float!

  # position along element's vertical
  v: Float!
}

input AbsoluteLinePointInput {
  # workspace x coordinate
  x: Float = 0

  # workspace y coordinate
  y: Float = 0
}

input UpdateLineInput {
  pinned: Boolean
  zIndex: Int
  surface: String
  style: UpdateLineStyleInput
  routing: LineRouting
  controlPoints: [LinePointInput!]
  start: LinePointInput
  end: LinePointInput
}

input UpdateLineStyleInput {
  strokeColor: ColorInput
  strokeStyle: LineStrokeStyle
  strokeWidth: Float
  startCap: LineCapStyle
  endCap: LineCapStyle
}

type RawCommand implements Command {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!
  data: JSON!
}

input MeetingHostChangedSubscriptionOptions {
  sessionId: ID!
}

type MeetingHostChangedPayload {
  sessionId: ID!
}

type MeetingHostChanged {
  data: MeetingHostChangedPayload!
  date: String
  eventVersion: String!
}

input WorkspaceMeetingAttendanceChangedSubscriptionOptions {
  workspaceId: ID!
}

type WorkspaceMeetingAttendanceChangedPayload {
  sessionId: ID!
  workspaceId: ID!
  attendeeCount: Int!
  startTime: String!
}

type WorkspaceMeetingAttendanceChanged {
  data: WorkspaceMeetingAttendanceChangedPayload!
  date: String
  eventVersion: String!
}

input WaitingRoomStatusUpdatedSubscriptionOptions {
  sessionId: ID!
  userId: ID
}

type WaitingRoomStatusUpdatedPayload {
  sessionId: ID!
  userId: ID!
  status: String!
}

type WaitingRoomStatusUpdated {
  data: WaitingRoomStatusUpdatedPayload!
  date: String
  eventVersion: String!
}

input RecordingFileLimitReachedSubscriptionOptions {
  meetingSessionId: ID!
}

type RecordingFileLimitReachedPayload {
  meetingSessionId: ID!
}

type RecordingFileLimitReached {
  data: RecordingFileLimitReachedPayload!
  date: String
  eventVersion: String!
}

input RecordingErrorOccurredSubscriptionOptions {
  meetingSessionId: ID!
}

type RecordingErrorOccurredPayload {
  meetingSessionId: ID!
}

type RecordingErrorOccurred {
  data: RecordingErrorOccurredPayload!
  date: String
  eventVersion: String!
}

enum CacheControlScope {
  PUBLIC
  PRIVATE
}

# The `Upload` scalar type represents a file upload.
scalar Upload

type InvoiceInfo {
  invoiceId: String!
  status: InvoiceStatus!
  amount: Int
  date: DateTime
  currency: CurrencyEnt!
}

# The status of an invoice
enum InvoiceStatus {
  Paid
  Posted
  PaymentDue
  NotPaid
  Voided
  Pending
}

# Currency of all pricing related fields
enum CurrencyEnt {
  USD
}

# The sort order
enum SortOrder {
  Asc
  Desc
}

type InvoicePDF {
  url: String!
}

type PaymentCardInfo {
  status: CardStatus!
  gateway: String
  last4: String
  cardType: CardType
  expiryMonth: Int
  expiryYear: Int
  maskedNumber: String
  billingAddress: Address!
  shippingAddress: Address
}

# Status of credit card
enum CardStatus {
  Valid
  Expiring
  Expired
  Invalid
  PendingVerification
}

# Type of credit card
enum CardType {
  Visa
  MasterCard
  AmericanExpress
  Discover
  JCB
  DinersClub
  PaypalExpressCheckout
  AmazonPayments
  DirectDebit
  Generic
  AliPay
  UnionPay
  ApplePay
  WeChatPay
  Ideal
  GooglePay
  Sofort
  Bancontact
  GiroPay
  DotPay
}

type Address {
  firstName: String!
  lastName: String!
  country: String!
  zip: String!
  state: String!
  city: String!
  line1: String!
  line2: String
}

type PlanInfo {
  # Monthly price per license in cents
  monthlyPrice: Int!

  # Yearly price per license in cents
  yearlyPrice: Int!
  currency: CurrencyEnt!
}

# The type of plan. Same as ISAM PlanType.
enum PlanTypeEnt {
  Business
  Team
}

type PriceEstimateResponse {
  immediateEstimate: PriceEstimateInfo
  nextTermEstimate: PriceEstimateInfo!
}

type PriceEstimateInfo {
  subtotal: Int!
  taxes: Int!
  total: Int!
  currency: CurrencyEnt!
}

# The billing period. Same as ISAM SubscriptionInterval.
enum SubscriptionIntervalEnt {
  Monthly
  Yearly
}

type PriceEstimateNewOrganizationResponse {
  nextTermEstimate: PriceEstimateInfo!
}

input AddressInput {
  firstName: String!
  lastName: String!
  country: String!
  zip: String!
  state: String!
  city: String!
  line1: String!
  line2: String
}

type SelfServeSubscriptionInfoEnt {
  # Mode.
  mode: SubscriptionModeEnt

  # Date the subscription was created at. Will be the same as the organization's creation date
  createdAt: DateTime

  # Date the subscription was last updated at. Will be the last update from the external subscription once it has been created with createOrganization.
  updatedAt: DateTime

  # The date the current term will end at and the subscription will be cancelled.
  cancelledAt: DateTime

  # Reason the subscription was cancelled
  cancelReason: CancellationReasonEnt

  # Start date of the current term for Free Trial or Self Serve.
  currentTermStart: DateTime

  # End date of the current term for Free Trial or Self Serve.
  currentTermEnd: DateTime

  # The number of licenses currently in use.
  licensesCurrentlyInUse: Int

  # Plan name.
  planName: String

  # Plan type.
  planType: PlanTypeEnt

  # Start date of the next term.
  nextTermStart: DateTime

  # Date at which the next billing for the subscription will occur.
  nextBillingAt: DateTime

  # Subscription interval - YEAR/MONTH.
  interval: SubscriptionIntervalEnt

  # Total amount that will be charged on `nextBillingAt` in the smallest unit of currency (e.g. USD cents). Note: does not include taxes.
  nextBillingPeriodAmount: Int

  # Cost per license in the smallest unit of currency (e.g. USD cents). Note: does not include taxes.
  pricePerLicense: Int

  # The number of licenses available for the current term.
  licenseQuantity: Int

  # The number of licenses purchased for next term.
  licenseQuantityInNextTerm: Int
  currency: CurrencyEnt
}

# The subscription mode. Same as ISAM SubscriptionMode.
enum SubscriptionModeEnt {
  FreeTrial
  LegacyEnterprise
  SelfServe
}

# Subscription cancellation reasons. The same as ISAM CancellationReason.
enum CancellationReasonEnt {
  CurrencyIncompatibleWithGateway
  FraudReviewFailed
  NoCard
  NonCompliantCustomer
  NonCompliantEuCustomer
  NotPaid
  NotRenewing
  TaxCalculationFailed
}

type CreateFreeTrialResponse {
  organizationId: String!
}

# Usecase for starting the Free Trial
enum Intent {
  ProjectKickOff
  BrainstormWorkshop
  CreativeDesignReview
  CreativeProjectWarRoom
  RemoteHybridWork
}

input HubSpotInput {
  # Optional hubspot tracker GUID
  hutk: String!

  # Optional hubspot pageUri
  pageUri: String!

  # Optional hubspot pageName
  pageName: String!
}

type CreateSelfServeSubscriptionResponse {
  organizationId: String!
}

union SubscriptionUnionTypeEnt =
    SelfServeSubscriptionInfoEnt
  | FreeTrialSubscriptionInfoEnt
  | LegacySubscriptionInfoEnt

type FreeTrialSubscriptionInfoEnt {
  # Mode.
  mode: SubscriptionModeEnt

  # Date the subscription was created at. Will be the same as the organization's creation date
  createdAt: DateTime

  # Date the subscription was last updated at. Will be the last update from the external subscription once it has been created with createOrganization.
  updatedAt: DateTime

  # The date the current term will end at and the subscription will be cancelled.
  cancelledAt: DateTime

  # Reason the subscription was cancelled
  cancelReason: CancellationReasonEnt

  # Start date of the current term for Free Trial or Self Serve.
  currentTermStart: DateTime

  # End date of the current term for Free Trial or Self Serve.
  currentTermEnd: DateTime

  # The number of licenses currently in use.
  licensesCurrentlyInUse: Int

  # Plan name.
  planName: String

  # Plan type.
  planType: PlanTypeEnt
}

type LegacySubscriptionInfoEnt {
  # Mode.
  mode: SubscriptionModeEnt

  # Date the subscription was created at. Will be the same as the organization's creation date
  createdAt: DateTime

  # Date the subscription was last updated at. Will be the last update from the external subscription once it has been created with createOrganization.
  updatedAt: DateTime

  # Subscription interval - YEAR/MONTH.
  interval: SubscriptionIntervalEnt
}
