type Query {
  #  Get availability of custom link
  customLinkAvailability(
    #  Custom link availability
    input: CustomLinkAvailabilityInput!
  ): CustomLinkAvailability!

  #  Get custom link by name
  customLinkByName(
    #  Get custom link by name
    input: GetCustomLinkByNameInput!
  ): CustomLinkAnonymous!

  #  Gets a listing of custom links
  customLinks(
    #  cursor
    cursor: String

    #  filtering
    filtering: CustomLinkFilters

    #  ordering
    ordering: [CustomLinkOrdering!]

    #  pagination
    pagination: PaginationArgs
  ): CustomLinksPaged!

  #  Returns an identity provider by id.
  identityProvider(
    #  Identity provide id
    identityProviderId: String!
  ): IdentityProvider!

  #  Returns a paginated collection of identity providers.
  identityProviders(
    #  cursor
    cursor: String

    #  filtering
    filtering: IdentityProviderFilters

    #  ordering
    ordering: [IdentityProviderOrdering!]

    #  pagination
    pagination: PaginationArgs
  ): IdentityProvidersPaged!

  #  Get current user
  me: Me!

  #  Get organization by Id
  organization(
    #  Organization Id
    organizationId: String!
  ): Organization!

  #  Get Organization list
  organizations(
    #  cursor
    cursor: String

    #  filtering
    filtering: OrganizationFilters

    #  ordering
    ordering: [OrganizationOrdering!]

    #  pagination
    pagination: PaginationArgs
  ): OrganizationsPaged!

  #  A permission group selected by ID.
  permissionGroup(
    #  Permission group ID
    permissionGroupId: String!
  ): PermissionGroup!

  #  Pages list of permission groups.
  permissionGroups(
    #  Cursor
    cursor: String

    #  Filtering
    filtering: PermissionGroupFilters

    #  Ordering
    ordering: [PermissionGroupOrdering!]

    #  Pagination
    pagination: PaginationArgs
  ): PermissionGroupsPaged!

  #  Get a role by Id.
  role(
    #  Role Id
    roleId: String!
  ): Role!

  #  Gets a listing of roles
  roles(
    #  cursor
    cursor: String

    #  filtering
    filtering: RoleFilters

    #  ordering
    ordering: [RoleOrdering!]

    #  pagination
    pagination: PaginationArgs
  ): RolesPaged!

  #  Get a scratch workspace by id. Any authorized user who knows the id can use this
  scratchWorkspace(
    #  Scratch workspace id
    scratchWorkspaceId: ID!
  ): ScratchWorkspace!

  #  Get all scratch workspaces belonging to the current user
  scratchWorkspaces(
    #  cursor
    cursor: String

    #  filtering
    filtering: ScratchWorkspaceFilters

    #  ordering
    ordering: [ScratchWorkspaceOrdering!]

    #  pagination
    pagination: PaginationArgs
  ): ScratchWorkspacesPaged!

  #  Get user by Id or email
  user(
    #  Email
    email: String

    #  User Id
    userId: String
  ): User!

  #  Get users list
  users(
    #  cursor
    cursor: String

    #  last loggedin date
    filtering: UserFilters

    #  ordering
    ordering: [UserOrdering!]

    #  pagination
    pagination: PaginationArgs
  ): UsersPaged!

  #  A paginated list of walls.
  walls(
    #  cursor
    cursor: String

    #  filters
    filtering: WallFilters

    #  ordering options
    ordering: [WallOrdering!]

    #  pagination
    pagination: PaginationArgs
  ): WallsPaged!

  #  Get workspace by Id
  workspace(
    #  Workspace Id
    workspaceId: String!
  ): Workspace!

  #  Get workspace access request by ID
  workspaceAccessRequest(
    #  The access request ID
    requestId: String!

    #  The workspace ID
    workspaceId: String!
  ): WorkspaceAccessRequest!

  #  Get workspace access request as a paginated list
  workspaceAccessRequests(
    #  Cursor
    cursor: String

    #  Filters
    filtering: WorkspaceAccessRequestFilters

    #  Ordering
    ordering: [WorkspaceAccessRequestOrdering!]

    #  Pagination
    pagination: PaginationArgs

    #  The workspace ID
    workspaceId: String!
  ): WorkspaceAccessRequestPaged!

  #  Get workspace lists
  workspaces(
    #  archived
    archived: Boolean

    #  cursor
    cursor: String

    #  filtering Organization Id
    filtering: WorkspaceFilters

    #  ordering
    ordering: [WorkspaceOrdering!]

    #  pagination
    pagination: PaginationArgs
  ): WorkspacesPaged!
  workspaceState(
    workspaceId: String!

    # restrict output to elements with traits matching these traits
    traits: TraitInput

    # id of the canvas in which the elements are included
    canvasId: String

    # id of the element. When canvas is specified the element will exist in the bounds of the canvas
    id: String
    type: [ElementType!]
    overlaps: Viewport

    # retrieve element state as of the specified moment in time
    when: DateTime

    # include attachments in toplevel query results
    flatten: Boolean

    # id of the element. When specified, its origin point will be used to compute relative coordinates of other elements
    relativeToOriginOf: String
  ): WorkspaceState
  elementsWithMeta(
    workspaceId: String!

    # restrict output to elements with traits matching these traits
    traits: TraitInput

    # id of the canvas in which the elements are included
    canvasId: String

    # id of the element. When canvas is specified the element will exist in the bounds of the canvas
    id: String
    type: [ElementType!]
    overlaps: Viewport

    # retrieve element state as of the specified moment in time
    when: DateTime

    # include attachments in toplevel query results
    flatten: Boolean

    # id of the element. When specified, its origin point will be used to compute relative coordinates of other elements
    relativeToOriginOf: String
  ): WorkspaceState
    @deprecated(reason: "please use workspaceState query instead")
  elements(
    workspaceId: String!

    # restrict output to elements with traits matching these traits
    traits: TraitInput

    # id of the canvas in which the elements are included
    canvasId: String

    # id of the element. When canvas is specified the element will exist in the bounds of the canvas
    id: String
    type: [ElementType!]
    overlaps: Viewport

    # retrieve element state as of the specified moment in time
    when: DateTime

    # include attachments in toplevel query results
    flatten: Boolean

    # id of the element. When specified, its origin point will be used to compute relative coordinates of other elements
    relativeToOriginOf: String
  ): [Element]
  findAvailableArea(
    workspaceId: String!

    # Proposed starting area to begin search for available area in the workspace for a new object to be placed
    proposedArea: BoxInput!

    # Direction to move in during the search for available area (up, down, left, right)
    direction: FindAvailableAreaDirection = right
  ): Box
  getIconLibraries(cursor: String, pagination: PaginationArgs): LibrariesPaged
  searchIcons(
    cursor: String
    pagination: PaginationArgs
    queryString: String
    library: String
    category: String
    variantName: String
  ): IconsPaged
}

type Mutation {
  #  Add a member to Organization
  addMember(
    #  AddMemberInput
    input: AddMemberInput!

    #  Organization Id
    organizationId: String!
  ): Member!

  #  Add a permission group to the role.
  addPermissionGroupsToRole(
    #  Role Id
    RoleId: String!

    #  AddPermissionGroupsToRoleInput
    input: AddPermissionGroupsToRoleInput!
  ): Role!

  #  Add collaborator to workspace
  addWorkspaceCollaborator(
    #  Add collaborator input
    input: AddCollaboratorInput!

    #  workspaceId
    workspaceId: String!
  ): Collaborator!

  #  Turn a scratch workspace into a workspace. Requires can_create_workspace permission in the organization and the email in the JWT token must match the email in the database
  claimScratchWorkspace(
    #  Id of the organization to put the scratch workspace
    organizationId: ID!

    #  Scratch workspace id
    scratchWorkspaceId: ID!
  ): Workspace!

  #  Creates a new custom link.
  createCustomLink(
    #
    input: CreateCustomLinkInput!
  ): CustomLink!

  #  Create favorite workspace
  createFavoriteWorkspace(
    #  User Id
    userId: String!

    #  Workspace Id
    workspaceId: String!
  ): Workspace!

  #  Creates a new identity provider.
  createIdentityProvider(
    #  CreateIdentityProviderInput
    input: CreateIdentityProviderInput!
  ): IdentityProvider!

  #  Creates a new role.
  createRole(
    #  createRole
    input: CreateRoleInput!
  ): Role!

  #  Creates a new scratch workspace
  createScratchWorkspace(
    #  Scratch workspace name (can be optional)
    name: String
  ): ScratchWorkspace!

  #  Create a new user
  createUser(
    #  createUser
    input: CreateUserInput!
  ): User!

  #  Create new workspace
  createWorkspace(
    #  createWorkspace
    input: CreateWorkspaceInput!
  ): Workspace!

  #  Creates a workspace access request.
  createWorkspaceAccessRequest(
    #  The workspace ID
    workspaceId: String!
  ): WorkspaceAccessRequest!

  #  Delete custom link.
  deleteCustomLink(
    #  customLinkId
    customLinkId: String!
  ): Boolean!

  #  Delete favorite workspace
  deleteFavoriteWorkspace(
    #  User Id
    userId: String!

    #  Workspace Id
    workspaceId: String!
  ): Boolean!

  #  Deletes an identity provider.
  deleteIdentityProvider(
    #  Identity provider id
    identityProviderId: String!
  ): Boolean!

  #  Delete Organization
  deleteOrganization(
    #  When "isPermanentDelete" is true,
    #       1) A request to Collab to Delete Workspaces of the Organization is initiated
    #       2) The Organization and its relationships are Hard Deleted.
    #       When "isPermanentDelete" is false,
    #       1) Users who belong to only this organization are archived
    #       2) User Organization relationship is Soft deleted
    #       3) Organization is Soft Deleted.
    isPermanentDelete: Boolean!

    #  ID of organization to delete.
    organizationId: String!
  ): Boolean!

  #  Delete Organization Guests
  deleteOrganizationGuests(
    #  Organization ID of organization to delete
    organizationId: String!
  ): Boolean!

  #  Delete Organization Member
  deleteOrganizationMember(
    #  DeleteMemberInput
    input: DeleteMemberInput!

    #  ID of organization.
    organizationId: String!
  ): Boolean!

  #  Deletes a permission group from a role.
  deletePermissionGroupFromRole(
    #  Permission GroupId
    PermissionGroupId: String!

    #  Role Id
    RoleId: String!
  ): Boolean!

  #  Deletes a role.
  deleteRole(
    #  Role Id
    RoleId: String!
  ): Boolean!

  #  Delete the specified scratch workspace. The JWT actorId much match the actorId in the database or (if a user JWT and an email was set) the user's email must match
  deleteScratchWorkspace(
    #  permanent delete flag
    isPermanentDelete: Boolean

    #  Scratch workspace id
    scratchWorkspaceId: ID!
  ): Boolean!

  #  Delete the user
  deleteUser(
    #  Reassign the ownership of workspaces from the user being deleted to this user
    newWorkspaceOwnerId: ID

    #  Delete all references to the user. This cannot be undone
    permanentDelete: Boolean

    #  The id of the user to be deleted
    userId: ID!
  ): Boolean!

  #  Delete workspace
  deleteWorkspace(
    #  Providing false soft deletes the workspace. It is recoverable by support. Providing true deletes all aspects of the workspace. It is not recoverable by support.
    isPermanentDelete: Boolean!

    #  WorkspaceId
    workspaceId: ID!
  ): Boolean!

  #  Delete workspace collaborator
  deleteWorkspaceCollaborator(
    #  collaboratorId
    collaboratorId: String!

    #  WorkspaceId
    workspaceId: String!
  ): Boolean!

  #  Workspace access request denied.
  denyWorkspaceAccessRequest(
    #  The access request ID
    requestId: String!

    #  The workspace ID
    workspaceId: String!
  ): WorkspaceAccessRequest!

  #  Update Collaborator Role
  updateCollaboratorRole(
    #  Default Role Id
    defaultRoleId: String!

    #  User Id
    userId: String!

    #  Workspace Id
    workspaceId: String!
  ): Role!

  #  Update Custom Link
  updateCustomLink(
    #  customLinkId
    customLinkId: String!

    #  Update Custom Link Input
    input: UpdateCustomLinkInput!
  ): CustomLink!

  #  Updates an identity provider.
  updateIdentityProvider(
    #  Identity Provider Id
    identityProviderId: String!

    #  UpdateIdentityProviderInput
    input: UpdateIdentityProviderInput!
  ): IdentityProvider!

  #  Update member's role
  updateMemberRole(
    #  UpdateMemberRoleInput
    input: UpdateMemberRoleInput!

    #  Member Id
    memberId: ID!

    #  Organization Id
    organizationId: ID!
  ): Member!

  #  Update the Organization
  updateOrganization(
    #  UpdateOrganizationInput
    input: UpdateOrganizationInput!

    #  Organization Id
    organizationId: String!
  ): Organization!

  #  Add,Update,Delete Organization Avatar
  updateOrganizationAvatar(
    #  Organization unique ID
    organizationId: ID!
  ): Organization!

  #  Updates a role.
  updateRole(
    #  Role Id
    RoleId: String!

    #  UpdateRoleInput
    input: UpdateRoleInput!
  ): Role!

  #  Updates a scratch workspace with name (optional) and email. Only the actor that created the scratch workspaces can update it
  updateScratchWorkspace(
    #  Email of the user that is saving the scratch workspace)
    email: String!

    #  Scratch workspace name (can be optional)
    name: String

    #  Scratch workspace id
    scratchWorkspaceId: ID!
  ): ScratchWorkspace!

  #  Update the user
  updateUser(
    #  UpdateUserInput
    input: UpdateUserInput!

    #  User Id
    userId: String!
  ): User!

  #  Add or Update and Delete User Avatar
  updateUserAvatar: User!

  #  Update User Password
  updateUserPassword(
    #  UpdateUserPasswordInput
    input: UpdateUserPasswordInput!
  ): Boolean!

  #  Update workspace
  updateWorkspace(
    #  Update Workspace Input
    input: UpdateWorkspaceInput!

    #  WorkspaceId
    workspaceId: String!
  ): Workspace!
  delete(id: String!, workspaceId: String!): Boolean!

  # Update traits of a workspace element
  updateTraits(
    # use as playground to test trait handling, does not add traits to history
    dryRun: Boolean = false

    # use the JSON-LD context specified in the input to compact the output
    compactOutput: Boolean = true

    # trait to add to the element
    input: TraitInput!

    # target workspace element id
    id: String!
    workspaceId: String!
  ): JSONObject!

  # Progress asset upload to processing
  processAsset(
    input: TransferCompleteInput!

    # asset upload id
    id: String!
    workspaceId: String!
  ): Boolean!

  # Update style of a workspace
  updateWorkspaceStyle(
    # new style of workspace
    input: UpdateWorkspaceStyleInput!
    workspaceId: String!
  ): UpdateWorkspaceStyleResponse!

  # Experimental: trait matching playground. Runs the trait matching algorithm on input traits and output its result. Does not change the workspace.
  matchTraits(
    # use the JSON-LD context specified in the input to compact the output
    compactOutput: Boolean = true

    # A JSON-LD frame describing a pattern to be matched in the input
    frame: TraitInput!

    # A JSON-LD document to match against
    input: TraitInput!
    workspaceId: String!
  ): JSONObject!

  # Add a comment to a workspace element
  createComment(
    # comment to add to the element
    input: CommentInput!

    # target workspace element id
    id: ID!
    workspaceId: String!
  ): Comment!
  createCanvas(
    # Id of the origin element. When specified the coordinates of a new element will be treated as relative to the origin point of that element
    relativeToOriginOf: String
    workspaceId: String!
    input: CreateCanvasInput!
  ): Canvas!
  updateCanvas(
    workspaceId: String!
    id: String!
    input: UpdateCanvasInput!
  ): UpdateElementResponse!
  createStroke(
    # Id of the origin element. When specified the coordinates of a new element will be treated as relative to the origin point of that element
    relativeToOriginOf: String
    workspaceId: String!
    input: CreateStrokeInput!
  ): Stroke!
  updateStroke(
    workspaceId: String!
    id: String!
    input: UpdateStrokeInput!
  ): UpdateElementResponse!
  createText(
    # Id of the origin element. When specified the coordinates of a new element will be treated as relative to the origin point of that element
    relativeToOriginOf: String
    workspaceId: String!
    input: CreateTextInput!
  ): Text!
  updateText(
    workspaceId: String!
    id: String!
    input: UpdateTextInput!
  ): UpdateElementResponse!
  createWindow(
    # Id of the origin element. When specified the coordinates of a new element will be treated as relative to the origin point of that element
    relativeToOriginOf: String
    workspaceId: String!
    input: CreateWindowInput!
  ): Window!
  updateWindow(
    workspaceId: String!
    id: String!
    input: UpdateWindowInput!
  ): UpdateElementResponse!
  createGrid(
    # Id of the origin element. When specified the coordinates of a new element will be treated as relative to the origin point of that element
    relativeToOriginOf: String
    workspaceId: String!
    input: CreateGridInput!
  ): Grid!
  updateGrid(
    workspaceId: String!
    id: String!
    input: UpdateGridInput!
  ): UpdateElementResponse!
  createVideo(
    # Id of the origin element. When specified the coordinates of a new element will be treated as relative to the origin point of that element
    relativeToOriginOf: String
    workspaceId: String!
    input: CreateVideoInput!
  ): CreateVideoResponse!
  updateVideo(
    workspaceId: String!
    id: String!
    input: UpdateVideoInput!
  ): UpdateElementResponse!
  createBrowser(
    # Id of the origin element. When specified the coordinates of a new element will be treated as relative to the origin point of that element
    relativeToOriginOf: String
    workspaceId: String!
    input: CreateBrowserInput!
  ): Browser!
  updateBrowser(
    workspaceId: String!
    id: String!
    input: UpdateBrowserInput!
  ): UpdateElementResponse!
  createImage(
    # Id of the origin element. When specified the coordinates of a new element will be treated as relative to the origin point of that element
    relativeToOriginOf: String
    workspaceId: String!
    input: CreateImageInput!
  ): CreateImageResponse!
  updateImage(
    workspaceId: String!
    id: String!
    input: UpdateImageInput!
  ): UpdateElementResponse!
  createDocument(
    # Id of the origin element. When specified the coordinates of a new element will be treated as relative to the origin point of that element
    relativeToOriginOf: String
    workspaceId: String!
    input: CreateDocumentInput!
  ): CreateDocumentResponse!
  updateDocument(
    workspaceId: String!
    id: String!
    input: UpdateDocumentInput!
  ): UpdateElementResponse!
  createShape(
    # Id of the origin element. When specified the coordinates of a new element will be treated as relative to the origin point of that element
    relativeToOriginOf: String
    workspaceId: String!
    input: CreateShapeInput!
  ): Shape!
  updateShape(
    workspaceId: String!
    id: String!
    input: UpdateShapeInput!
  ): UpdateElementResponse!
  createLine(
    # Id of the origin element. When specified the coordinates of a new element will be treated as relative to the origin point of that element
    relativeToOriginOf: String
    workspaceId: String!
    input: CreateLineInput!
  ): Line!
  updateLine(
    workspaceId: String!
    id: String!
    input: UpdateLineInput!
  ): UpdateElementResponse!
  createIcon(
    # Id of the origin element. When specified the coordinates of a new element will be treated as relative to the origin point of that element
    relativeToOriginOf: String
    workspaceId: String!
    input: CreateIconInput!
  ): Icon!
  updateIcon(
    workspaceId: String!
    id: String!
    input: UpdateIconInput!
  ): UpdateElementResponse!
}

type Subscription {
  #  Returns an event when an identity provider is created
  IdentityProviderCreated: IdentityProviderPayloadCreated!

  #  Returns an event when an identity provider is deleted
  IdentityProviderDeleted: IdentityProviderPayloadDeleted!

  #  Returns an event when an identity provider is updated
  IdentityProviderUpdated: IdentityProviderPayloadUpdated!

  #  Collaborator added event.
  addCollaborator(
    #  Collaborator Added Subscription Options
    subscriptionOptions: CollaboratorAddedSubscriptionOptions
  ): CollaboratorAdded!

  #  Organization member added events.
  addMember(
    #  Member added subscription
    subscriptionOptions: MemberAddedSubscriptionOptions
  ): MemberAdded!

  #  Role created events
  createRole(
    #  Create role subscription
    subscriptionOptions: RoleCreatedSubscriptionOptions
  ): RoleCreated!

  #  Workspace created events.
  createWorkspace: WorkspaceCreated!

  #  Create workspace access request events.
  createWorkspaceAccessRequest(
    #  Subscription options for create workspace access request events.
    subscriptionOptions: WorkspaceAccessRequestCreatedSubscriptionOptions
  ): WorkspaceAccessRequestCreated!

  #  Role deleted events.
  deleteRole(
    #  Role delete subscription
    subscriptionOptions: RoleDeletedSubscriptionOptions
  ): RoleDeleted!

  #  Workspace duplication events.
  duplicateWorkspace(
    #  Workspace duplicated subscription
    subscriptionOptions: WorkspaceDuplicatedSubscriptionOptions
  ): WorkspaceDuplicated!

  #  User login events.
  login(
    #  Login event subscription
    subscriptionOptions: UserLoginSubscriptionOptions
  ): UserLogin!

  #  Workspace reassigned events
  reassignWorkspace(
    #  Workspace reassigned event
    subscriptionOptions: WorkspaceReassignedSubscriptionOptions
  ): WorkspaceReassigned!

  #  User registration events.
  registerUser: UserRegistered!

  #  Collaborator Removed
  removeCollaborator(
    #  collaborator Removed Event
    subscriptionOptions: CollaboratorRemovedSubscriptionOptions
  ): CollaboratorRemoved!

  #  Organization member removed events.
  removeMember(
    #  Member removed event subscription
    subscriptionOptions: MemberRemovedSubscriptionOptions
  ): MemberRemoved!

  #  User resend activation events.
  resendActivation: UserResendActivation!

  #  User passwors reset events.
  resetPassword: UserResetPassword!

  #  Token revoke events.
  tokenRevoke: TokenRevoked!

  #  Update collaborator role events
  updateCollaboratorRole(
    #  subscriptionOptions
    subscriptionOptions: CollaboratorRoleChangedSubscriptionOptions
  ): CollaboratorRoleChanged!

  #  Organization member role updated events.
  updateMemberRole(
    #  Member role updated event
    subscriptionOptions: MemberRoleUpdatedSubscriptionOptions
  ): MemberRoleUpdated!

  #  Role updated events.
  updateRole(
    #  Role update subsription
    subscriptionOptions: RoleUpdatedSubscriptionOptions
  ): RoleUpdated!

  #  User update events.
  updateUser(
    #  Role Created Event Subscription
    subscriptionOptions: UserUpdatedSubscriptionOptions
  ): UserUpdated!

  #  Workspace updated events
  updateWorkspace(
    #  Workspace updated event
    subscriptionOptions: WorkspaceUpdatedSubscriptionOptions
  ): WorkspaceUpdated!

  #  Update workspace access request events.
  updateWorkspaceAccessRequest(
    #  Subscription options for update workspace access request events.
    subscriptionOptions: WorkspaceAccessRequestUpdateSubscriptionOptions
  ): WorkspaceAccessRequestUpdate!
  commands(
    workspaceId: String!

    # the cursor ID of last known command
    cursor: ID
    elementId: String
    elementType: [ElementType!]
  ): HistoryCommand!
  rawHistory(
    workspaceId: String!

    # the cursor ID of last known command
    cursor: ID
  ): RawCommand!
}

#  Add collaborator input
input AddCollaboratorInput {
  #  The Id of the User or Group to be added to this workspace
  id: String!

  #  The role Id the of User to be added to this workspace
  workspaceRoleId: String!
}

#  Add Member Input
input AddMemberInput {
  #  The User Id of the Organization member
  id: ID!

  #  Organization Role Id
  organizationRoleId: ID

  #  The Role Type of the Organization member
  type: String
}

#  Add Permission group role input
input AddPermissionGroupsToRoleInput {
  #  Permission GroupIds
  permissionGroupIds: [ID!]!
}

#  BluescapeGroupJoinType
enum BluescapeGroupJoinType {
  #  Any user can join the group.
  Anyone

  #  New group members must be invited by the group owner.
  ByInvite

  #  Users that want to join a group can request that the group owner add them.
  OnRequest
}

#  Boolean Filter
input BooleanFilter {
  #  equals
  eq: Boolean

  #  not equals
  ne: Boolean
}

#  A collaborator is user who can access a workspace.
type Collaborator {
  #  The User or Group this workspace is associated with
  collaborator: CollaboratorUnion!

  #  The Role this workspace is associated with
  workspaceRole: Role!
}

#  Collaborator added event.
type CollaboratorAdded {
  #  actorId
  actorId: ID!

  #  actorType
  actorType: String!

  #  category
  category: String!

  #  containsConfidential
  containsConfidential: Boolean!

  #  containsPII
  containsPII: Boolean!

  #  Data
  data: CollaboratorAddedPayload!

  #  date
  date: String

  #  eventVersion
  eventVersion: String!

  #  organizationId
  organizationId: ID

  #  type
  type: String!

  #  workspaceId
  workspaceId: ID
}

#  Collaborator added event payload.
type CollaboratorAddedPayload {
  #  Id
  id: ID!

  #  Type
  type: String!

  #  Workspace role
  workspaceRole: CollaboratorRolePayload!
}

#  Collaborator Added Subscription
input CollaboratorAddedSubscriptionOptions {
  #  Collaborator Id
  collaboratorId: ID!

  #  Workspace Id
  workspaceId: ID!
}

#  Collaborator filter
input CollaboratorFilters {
  #  and filter
  and: [CollaboratorFilters!]

  #  group filter
  group: CollaboratorGroupFilters

  #  not filter
  not: [CollaboratorFilters!]

  #  or filter
  or: [CollaboratorFilters!]

  #  user filter
  user: CollaboratorUserFilters

  #  workspace role filter
  workspaceRole: CollaboratorRoleFilters
}

#  Collaborator group filter
input CollaboratorGroupFilters {
  #  and filter
  and: [CollaboratorGroupFilters!]

  #  Bluescape join type
  bluescapeGroupJoinType: GroupJoinTypeFilter

  #  Description
  description: StringFilter

  #  Id
  id: StringFilter

  #  Name
  name: StringFilter

  #  not filter
  not: [CollaboratorGroupFilters!]

  #  or filter
  or: [CollaboratorGroupFilters!]

  #  type
  type: StringFilter
}

#  CollaboratorOrderByField
enum CollaboratorOrderByField {
  #  Order by the creation date
  createdAt

  #  Order by name
  name

  #  Order by the date of the last update
  updatedAt
}

#  Collaborator ordering options.
input CollaboratorOrderedFields {
  #
  createdAt: OrderBy

  #
  name: OrderBy

  #
  updatedAt: OrderBy
}

#  Collaborator ordering
input CollaboratorOrdering {
  #  sort field
  field: CollaboratorOrderByField

  #  order field
  order: OrderBy = Asc

  #
  orderedField: CollaboratorOrderedFields
}

#  Collaborator removal event payload.
type CollaboratorRemovalPayload {
  #  Id
  id: ID!

  #  type
  type: String!

  #  Workspace role
  workspaceRole: CollaboratorRolePayload!
}

#  Collaborator removed event.
type CollaboratorRemoved {
  #  actorId
  actorId: ID!

  #  actorType
  actorType: String!

  #  category
  category: String!

  #  containsConfidential
  containsConfidential: Boolean!

  #  containsPII
  containsPII: Boolean!

  #  Collaborator Removed
  data: CollaboratorRemovalPayload!

  #  date
  date: String

  #  eventVersion
  eventVersion: String!

  #  organizationId
  organizationId: ID

  #  type
  type: String!

  #  workspaceId
  workspaceId: ID
}

#  Collaborator Remove Subscription
input CollaboratorRemovedSubscriptionOptions {
  #  Collaborator Id
  collaboratorId: ID!

  #  Workspace Id
  workspaceId: ID!
}

#  Collaborator role changed event
type CollaboratorRoleChanged {
  #  actorId
  actorId: ID!

  #  actorType
  actorType: String!

  #  category
  category: String!

  #  containsConfidential
  containsConfidential: Boolean!

  #  containsPII
  containsPII: Boolean!

  #  data
  data: RolePayloadChanged!

  #  date
  date: String

  #  eventVersion
  eventVersion: String!

  #  organizationId
  organizationId: ID

  #  type
  type: String!

  #  workspaceId
  workspaceId: ID
}

#  Collaborator changed subscription
input CollaboratorRoleChangedSubscriptionOptions {
  #  User Id
  userId: ID!

  #  Workspace Id
  workspaceId: ID!
}

#  Collaborator Role Filter
input CollaboratorRoleFilters {
  #  and filter
  and: [CollaboratorRoleFilters!]

  #  description
  description: StringFilter

  #  Id
  id: StringFilter

  #  is custom role
  isCustom: BooleanFilter

  #  Name
  name: StringFilter

  #  not filter
  not: [CollaboratorRoleFilters!]

  #  or filter
  or: [CollaboratorRoleFilters!]

  #  resource type
  resourceType: StringFilter

  #  type
  type: StringFilter
}

#  Collaborator role event payload.
type CollaboratorRolePayload {
  #  Id
  id: ID!

  #  name
  name: String!
}

#  Collaborator Union
union CollaboratorUnion = Group | User

#  Collaborator User Filters
input CollaboratorUserFilters {
  #  and filter
  and: [CollaboratorUserFilters!]

  #  Avatar URL
  avatarUrl: StringFilter

  #  Email
  email: StringFilter

  #  First name
  firstName: StringFilter

  #  Id
  id: StringFilter

  #  Invitation Status
  invitationStatus: InvitationStatusFilter

  #  Last name
  lastName: StringFilter

  #  not filter
  not: [CollaboratorUserFilters!]

  #  or filter
  or: [CollaboratorUserFilters!]
}

#  A paginated collection of collaborators.
type CollaboratorsPaged {
  #  next
  next: String

  #  prev
  prev: String

  #  results
  results: [Collaborator!]

  #  totalItems
  totalItems: Int
}

#  Create Custom link input
input CreateCustomLinkInput {
  #  The name for the custom link. It should be unique
  name: String!

  #  Owner data
  ownerId: ID

  #  ResourceId of the resource pointed by the customLink
  resourceId: ID

  #  ResourceType of the resource pointed by the customLink
  resourceType: CustomLinkResourceType!
}

#  create identity provider input
input CreateIdentityProviderInput {
  #  The email address of the provider administrator
  adminEmail: String

  #  State of sp-initiated SAML single logout support
  isSamlSpSloEnabled: Boolean

  #  URL of the SAML metadata file. It is required if the new identity provider is one of the SAML types
  metadataUrl: String

  #  The name for the identity provider
  name: String!

  #  The type of identity provider
  type: IDPTypeCreate!

  #  Attribute name of User Guid in SAML assertion
  userGuidAttributeName: String
}

#  Create role input
input CreateRoleInput {
  #  description of the role
  description: String

  #  The name for the role. It should be unique
  name: String!

  #  Organization Id
  organizationId: ID!

  #  Permission GroupIds
  permissionGroupIds: [ID!]

  #  The resource type this role applies to
  resourceType: ResourceType!

  #  The type of role
  type: RoleType!
}

#  Create user input
input CreateUserInput {
  #  Application Role Id
  applicationRoleId: String

  #  email id of the user
  email: String!
}

#  Created workspace input
input CreateWorkspaceInput {
  #  Archived Date
  archivedAt: DateTime

  #  The classification of workspace.
  classification: String

  #  Copy From
  copyFrom: String

  #  The default workspace role for a public workspace
  defaultRoleId: String

  #  The description for the workspace.
  description: String

  #  true: this workspace can be accessed by any member of the organization, false: this workspace can only be accessed by the workspace's collaborators
  isPublic: Boolean!

  #  The name for the workspace. It should be unique
  name: String!

  #  The organization Id this workspace is associated with
  organizationId: String!

  #  The id of the member who will own this workspace
  ownerId: String
}

#  The type expressing custom link.
type CustomLink {
  #  Created Date
  createdAt: DateTime!

  #  Custom link Id
  id: ID!

  #  The name for the custom link. It should be unique
  name: String!

  #  Owner data
  owner: User

  #  ResourceId of the resource pointed by the customLink
  resourceId: ID

  #  ResourceType of the resource pointed by the customLink
  resourceType: CustomLinkResourceType!

  #  Updated Date
  updatedAt: DateTime!
}

#  Get custom link by name
type CustomLinkAnonymous {
  #  ResourceId of the resource pointed by the customLink
  resourceId: ID!

  #  ResourceType of the resource pointed by the customLink
  resourceType: CustomLinkResourceType!
}

#  The type expressing custom link is available or not.
#   Given some valid suggestion if available.
type CustomLinkAvailability {
  #  Custom link is available
  isAvailable: Boolean!

  #  Alternative suggested names
  suggestions: [String!]!
}

#  Custom link availability
input CustomLinkAvailabilityInput {
  #  The name for the custom link. It should be unique
  name: String!
}

#  Custom link filters
input CustomLinkFilters {
  #  and filter
  and: [CustomLinkFilters!]

  #  Created Date
  createdAt: DateFilter

  #  Id
  id: StringFilter

  #  name
  name: StringFilter

  #  not filter
  not: [CustomLinkFilters!]

  #  or filter
  or: [CustomLinkFilters!]

  #  Owner id of the custom link. This should be used for instance admin. User get their own custom links only.
  ownerId: StringFilter

  #  updated date
  updatedAt: DateFilter
}

#  Custom link orderBy Field
enum CustomLinkOrderByField {
  #  Order by creation date.
  createdAt

  #  Order by name.
  name

  #  Order by last update date.
  updatedAt
}

#  Custom link ordering options.
input CustomLinkOrderedFields {
  #
  createdAt: OrderBy

  #
  name: OrderBy

  #
  updatedAt: OrderBy
}

#  Custom link, ordering
input CustomLinkOrdering {
  #  field
  field: CustomLinkOrderByField

  #  order
  order: OrderBy = Asc

  #
  orderedField: CustomLinkOrderedFields
}

#  Available types of resource
enum CustomLinkResourceType {
  #  Custom link blocked type. (Reserved by admin or taken by others)
  Blocked

  #  Custom link meeting type
  Meet
}

#  A paginated collection of custom links
type CustomLinksPaged {
  #  next
  next: String

  #  prev
  prev: String

  #  results
  results: [CustomLink!]

  #  totalItems
  totalItems: Int
}

#  Date Filter
input DateFilter {
  #  equals
  eq: DateTime

  #  greater equal
  ge: DateTime

  #  greater than
  gt: DateTime

  #  less than equal
  le: DateTime

  #  less than
  lt: DateTime

  #  not equals
  ne: DateTime
}

# The `DateTime` scalar type represents dates in RFC 3339 format (for example "2019-11-25T16:22:28.737Z").
scalar DateTime

#  Delete member input
input DeleteMemberInput {
  #  The User Id or the Group Id to be deleted from the Organization
  memberId: ID!

  #  When changing an organization member to be a "guest", sets any workspaces owned by that member to a new workspace owner.
  newWorkspaceOwnerId: ID = null
}

#  Group info used for synchronization.
type ExternalGroupInfo {
  #  Auto-invite inviter or null if the previous sync did not use auto-invite
  autoInviteInviter: String!

  #  The ID of the External Group Info.
  id: ID!

  #  Identifier for the group in the external provider. Example: "e06eebc1-32fb-4971-b633-nnnnnnnnnnnn"
  identity: String!

  #  Determines whether auto nested sync is enabled for the group
  isAutoNestedSync: Boolean!

  #  Error message from the most recent incremental or full sync failure. This
  #     message is not removed when the sync completes successfully.<br/>
  lastSyncError: String!

  #  The name of the group in the external provider
  name: String!

  #  State of the last incremental or full sync.
  syncState: ExternalGroupInfoSyncState!
}

#  External Group sync state
enum ExternalGroupInfoSyncState {
  #  The previously attempted full or incremental sync has successfully completed
  Complete

  #  The previously attempted full or incremental sync has failed. See also the sync error field
  Failure

  #  A full or incremental sync is currently in process
  InProcess

  #  No sync has yet been attempted
  NeverInitiated
}

#  Workspaces marked as favorites
type Favorites {
  #  Workspaces
  workspaces(
    #  cursor
    cursor: String

    #  filtering
    filtering: WorkspaceFilters

    #  ordering
    ordering: [WorkspaceOrdering!]

    #  pagination
    pagination: PaginationArgs
  ): WorkspacesPaged
}

#  Get availability by name
input GetCustomLinkByNameInput {
  #  The name for the custom link.
  name: String!
}

#  A group of users.
type Group {
  #  This field determines how a group members are added to a Bluescape Group. Note: doesn't apply to External groups.
  bluescapeGroupJoinType: BluescapeGroupJoinType

  #  Created Date
  createdAt: DateTime!

  #  Description of the purpose of this group along with any notes relating to it
  description: String!

  #  externalGroupInfo
  externalGroupInfo: ExternalGroupInfo

  #  The Id of the Group
  id: ID!

  #  The name of the Group
  name: String!

  #  The Id of the organization this group will belong to
  organizationId: ID!

  #  Whether this group is a Bluescape Group (internal) managed group or and externally synced group
  type: GroupType!

  #  Updated Date
  updatedAt: DateTime!
}

#  Group join filter
input GroupJoinTypeFilter {
  #  equals filter
  eq: BluescapeGroupJoinType

  #  not equals filter
  ne: BluescapeGroupJoinType
}

#  GroupType
enum GroupType {
  #  A group defined within Bluescape.
  Bluescape

  #  A group defined outside of Bluescape.
  External
}

#  IDFilter
input IDFilter {
  #  equals
  eq: ID

  #  not equal
  ne: ID
}

#  IdentityProvider types
enum IDPType {
  #  Active Directory Federation Serivces
  Adfs

  #  Common Access Card
  Cac

  #  F5 SAML Provider
  F5

  #  Okta SAML Provider
  Okta

  #  Onelogin cloud-based SAML Provider
  Onelogin

  #  Internal, default, Bluescape Identity Provider
  Password

  #  PingFederate is an enterprise SAML Provider
  PingFederate
}

#  IdentityProviders that can be created for use
enum IDPTypeCreate {
  #  Active Directory Federation Serivces
  Adfs

  #  Common Access Card
  Cac

  #  F5 SAML Provider
  F5

  #  Okta SAML Provider
  Okta

  #  Onelogin cloud-based SAML Provider
  Onelogin

  #  PingFederate is an enterprise SAML Provider
  PingFederate
}

#  An identity provider is a service that defines the identity of a user, it can be external, e.g. SAML, or internal, e.g. Bluescape password
type IdentityProvider {
  #  The email address of the provider administrator
  adminEmail: String

  #  Created Date
  createdAt: DateTime!

  #  Identity Provider Id
  id: ID!

  #  State of sp-initiated SAML single logout support
  isSamlSpSloEnabled: Boolean

  #  URL of the SAML metadata file. It is required if the new identity provider is one of the SAML types
  metadataUrl: String

  #  The name for the identity provider
  name: String!

  #  Organizations
  organizations: [Organization!]!

  #  The type of identity provider
  type: IDPType!

  #  Updated Date
  updatedAt: DateTime!

  #  Attribute name of User Guid in SAML assertion
  userGuidAttributeName: String
}

#  A base type for other identity provider events.
type IdentityProviderEventPayload {
  #  The email address of the provider administrator
  adminEmail: String

  #  Created Date
  createdAt: DateTime!

  #  Identity provider id
  id: ID!

  #  The url that provides SAML metadata
  metadataUrl: String

  #  The name for the identity provider
  name: String!

  #  The type of identity provider
  type: IDPType!

  #  Updated Date
  updatedAt: DateTime!
}

#  Identity Provider Filters
input IdentityProviderFilters {
  #  admin email
  adminEmail: StringFilter

  #  and filter
  and: [IdentityProviderFilters!]

  #  created date
  createdAt: DateFilter

  #  metadata url
  metadataUrl: StringFilter

  #  name of the idp
  name: StringFilter

  #  not filter
  not: [IdentityProviderFilters!]

  #  or filter
  or: [IdentityProviderFilters!]

  #  type
  type: IdentityProviderTypeFilter

  #  updated date
  updatedAt: DateFilter
}

#  Order by fields.
enum IdentityProviderOrderByField {
  #  Order by creation date.
  createdAt

  #  Order by name.
  name

  #  Order by type.
  type

  #  Order by update date.
  updatedAt
}

#  Identity provider ordering options.
input IdentityProviderOrderedFields {
  #
  createdAt: OrderBy

  #
  name: OrderBy

  #
  type: OrderBy

  #
  updatedAt: OrderBy
}

#  Identity provider ordering.
input IdentityProviderOrdering {
  #  Order by field.
  field: IdentityProviderOrderByField

  #  Ordering direction.
  order: OrderBy = Asc

  #  Field
  orderedField: IdentityProviderOrderedFields
}

#  Event raised when an identity provider is created.
type IdentityProviderPayloadCreated {
  #  actorId
  actorId: ID!

  #  actorType
  actorType: String!

  #  category
  category: String!

  #  containsConfidential
  containsConfidential: Boolean!

  #  containsPII
  containsPII: Boolean!

  #  data
  data: IdentityProviderEventPayload!

  #  date
  date: String

  #  eventVersion
  eventVersion: String!

  #  organizationId
  organizationId: ID

  #  type
  type: String!

  #  workspaceId
  workspaceId: ID
}

#  Event raised when an identity provider is deleted.
type IdentityProviderPayloadDeleted {
  #  actorId
  actorId: ID!

  #  actorType
  actorType: String!

  #  category
  category: String!

  #  containsConfidential
  containsConfidential: Boolean!

  #  containsPII
  containsPII: Boolean!

  #  data
  data: IdentityProviderEventPayload!

  #  date
  date: String

  #  eventVersion
  eventVersion: String!

  #  organizationId
  organizationId: ID

  #  type
  type: String!

  #  workspaceId
  workspaceId: ID
}

#  Event raised when an identity provider is updated.
type IdentityProviderPayloadUpdated {
  #  actorId
  actorId: ID!

  #  actorType
  actorType: String!

  #  category
  category: String!

  #  containsConfidential
  containsConfidential: Boolean!

  #  containsPII
  containsPII: Boolean!

  #  data
  data: IdentityProviderEventPayload!

  #  date
  date: String

  #  eventVersion
  eventVersion: String!

  #  organizationId
  organizationId: ID

  #  type
  type: String!

  #  workspaceId
  workspaceId: ID
}

#  A type to filter identity providers.
input IdentityProviderTypeFilter {
  #  equals
  eq: IDPType

  #  not equals
  ne: IDPType
}

#  A type for paginated identity providers.
type IdentityProvidersPaged {
  #  next
  next: String

  #  prev
  prev: String

  #  results
  results: [IdentityProvider!]

  #  totalItems
  totalItems: Int
}

#  Invitation status of the User
enum InvitationStatus {
  #
  ACCEPTED

  #
  CREATED

  #
  INVITED

  #
  PENDING_INVITE
}

#  Invitation Status filter
input InvitationStatusFilter {
  #  Equal
  eq: InvitationStatus

  #  Not Equal
  ne: InvitationStatus
}

#  Get the current user.
type Me {
  #  Favorites
  favorites: Favorites!

  #  Organizations specifically associated to the user
  organizations(
    #  cursor
    cursor: String

    #  filtering
    filtering: OrganizationFilters

    #  ordering
    ordering: [OrganizationOrdering!]

    #  pagination
    pagination: PaginationArgs
  ): OrganizationsPaged!

  #  User profile
  profile: User!

  #  public: Wall specifically associated to the user
  walls(
    #  cursor
    cursor: String

    #  filtering
    filtering: WallFilters

    #  ordering
    ordering: [WallOrdering!]

    #  pagination
    pagination: PaginationArgs
  ): WallsPaged!

  #  workspaces specifically associated to the user
  workspaces(
    #  cursor
    cursor: String

    #  filtering
    filtering: UserWorkspaceFilters

    #  ordering
    ordering: [WorkspaceOrdering!]

    #  pagination
    pagination: PaginationArgs
  ): UserWorkspacesPaged!
}

#  A member of an organization.
type Member {
  #  The User or Group this organization is associated with
  member: MemberUnion!

  #  The organization this Member is associated with
  organization: Organization!

  #  The Role this Member is associated in the Organization
  organizationRole: Role!
}

#  Organization member added event.
type MemberAdded {
  #  actorId
  actorId: ID!

  #  actorType
  actorType: String!

  #  category
  category: String!

  #  containsConfidential
  containsConfidential: Boolean!

  #  containsPII
  containsPII: Boolean!

  #  data
  data: MemberAddedPayload!

  #  date
  date: String

  #  eventVersion
  eventVersion: String!

  #  organizationId
  organizationId: ID

  #  type
  type: String!

  #  workspaceId
  workspaceId: ID
}

#  Organization member added event payload.
type MemberAddedPayload {
  #  The User Id of the Organization member
  id: ID!

  #  The Role details the Member in Organization
  organizationRole: MemberRolePayload!

  #  The Role Type of the Organization member
  type: String!
}

#  Member added subscription
input MemberAddedSubscriptionOptions {
  #  Organization Id
  organizationId: ID!
}

#  member filters
input MemberFilters {
  #  and filter
  and: [MemberFilters!]

  #  group filter
  group: MemberGroupFilters

  #  not filter
  not: [MemberFilters!]

  #  or filter
  or: [MemberFilters!]

  #  organization role
  organizationRole: MemberRoleFilters

  #  user filter
  user: MemberUserFilters
}

#  Member group filter
input MemberGroupFilters {
  #  and filter
  and: [MemberGroupFilters!]

  #  Bluescape group join type
  bluescapeGroupJoinType: GroupJoinTypeFilter

  #  description
  description: StringFilter

  #  id
  id: StringFilter

  #  name
  name: StringFilter

  #  not filter
  not: [MemberGroupFilters!]

  #  or filter
  or: [MemberGroupFilters!]

  #  type
  type: StringFilter
}

#  Member ordering.
enum MemberOrderByField {
  #  Order by email.
  email
}

#  Member ordering options.
input MemberOrderedFields {
  #
  email: OrderBy
}

#  Member ordering.
input MemberOrdering {
  #  sort field
  field: MemberOrderByField

  #  sort order
  order: OrderBy = Asc

  #
  orderedField: MemberOrderedFields
}

#  Organization member removed event.
type MemberRemoved {
  #  actorId
  actorId: ID!

  #  actorType
  actorType: String!

  #  category
  category: String!

  #  containsConfidential
  containsConfidential: Boolean!

  #  containsPII
  containsPII: Boolean!

  #  data
  data: MemberRemovedPayload!

  #  date
  date: String

  #  eventVersion
  eventVersion: String!

  #  organizationId
  organizationId: ID

  #  type
  type: String!

  #  workspaceId
  workspaceId: ID
}

#  Organization member removed event payload.
type MemberRemovedPayload {
  #  The email of the Organization member
  email: String!

  #  The User Id of the Organization member
  id: ID!

  #  The name of the Organization member
  name: String!

  #  The organization Id this this Member is associated with
  organizationId: ID!

  #  The Role details of the Organization member
  organizationRole: MemberRolePayload!

  #  The type of the Organization member, can be user/group
  type: String!
}

#  Member Removed subscription
input MemberRemovedSubscriptionOptions {
  #  Organization Id
  organizationId: ID!
}

#  Member Role filters
input MemberRoleFilters {
  #  and filter
  and: [MemberRoleFilters!]

  #  description
  description: StringFilter

  #  id
  id: StringFilter

  #  is custom
  isCustom: BooleanFilter

  #  name
  name: StringFilter

  #  not filter
  not: [MemberRoleFilters!]

  #  or filter
  or: [MemberRoleFilters!]

  #  resource type
  resourceType: StringFilter

  #  type
  type: StringFilter
}

#  Organization member role event payload.
type MemberRolePayload {
  #  The Role Id of the Organization member
  id: ID!

  #  The Role Name of the Organization member
  name: String!

  #  The display order of the role
  order: Float!

  #  The Role Type of the Organization member
  type: String!
}

#  Organization member role updated event.
type MemberRoleUpdated {
  #  actorId
  actorId: ID!

  #  actorType
  actorType: String!

  #  category
  category: String!

  #  containsConfidential
  containsConfidential: Boolean!

  #  containsPII
  containsPII: Boolean!

  #  data
  data: MemberRoleUpdatedPayload!

  #  date
  date: String

  #  eventVersion
  eventVersion: String!

  #  organizationId
  organizationId: ID

  #  type
  type: String!

  #  workspaceId
  workspaceId: ID
}

#  Organization member role updated event payload.
type MemberRoleUpdatedPayload {
  #  The User Id of the Organization member
  id: ID!

  #  The Role details the Member in Organization
  newOrganizationRole: MemberRolePayload!

  #  The Role details the Member in Organization
  previousOrganizationRole: MemberRolePayload!

  #  The Role Type of the Organization member
  type: String!
}

#  Member role updated subscription
input MemberRoleUpdatedSubscriptionOptions {
  #  Member Id
  memberId: ID!

  #  Organization Id
  organizationId: ID!
}

#  Member Union
union MemberUnion = Group | User

#  Member user filters
input MemberUserFilters {
  #  and filter
  and: [MemberUserFilters!]

  #  avatar URL
  avatarUrl: StringFilter

  #  email
  email: StringFilter

  #  first name
  firstName: StringFilter

  #  Id
  id: StringFilter

  #  Invitation Status
  invitationStatus: InvitationStatusFilter

  #  last name
  lastName: StringFilter

  #  not filter
  not: [MemberUserFilters!]

  #  or filter
  or: [MemberUserFilters!]
}

#  A paginated collection of organization members.
type MembersPaged {
  #  next
  next: String

  #  prev
  prev: String

  #  results
  results: [Member!]

  #  totalItems
  totalItems: Int
}

#  OrderBy
enum OrderBy {
  #  Ascending order
  Asc

  #  Descending order
  Desc
}

#  The organization type.
type Organization {
  #  True if IDP user is to be auto associated
  autoAssociateIdentityProviderUser: Boolean!

  #  True if the organization allows guests
  canHaveGuests: Boolean

  #  Created Date
  createdAt: DateTime!

  #  The role to apply when a user is added to an organization, but has no role has been assigned
  defaultOrganizationUserRole: Role

  #  The Id of the role to apply when a user accesses a public workspace, but has no role specified for that workspace
  defaultPublicWorkspaceRole: Role

  #  Id of the organization
  id: ID!

  #  True if custom roles are enabled for the organization
  isCustomRolesEnabled: Boolean

  #  True if the organization requires admin approval for users to invite guest
  isGuestInviteApprovalRequired: Boolean

  #  Members
  members(
    #  cursor
    cursor: String

    #  filtering
    filtering: MemberFilters

    #  ordering
    ordering: [MemberOrdering!]

    #  pagination
    pagination: PaginationArgs
  ): MembersPaged!

  #  Enable/disable Multi-factor authentication for the organization
  mfaEnabled: Boolean

  #  The name of the organization or company
  name: String!

  #  The owner of the organization
  owner: User!

  #  The name of the team or organizational unit
  secondaryName: String

  #  Signed avatar URL of the organization
  signedAvatarUrl: String

  #  Updated Date
  updatedAt: DateTime!

  #  Walls
  walls(
    #  pagination
    pagination: PaginationArgs
  ): WallsPaged!
}

#  Organization Filters
input OrganizationFilters {
  #  and filter
  and: [OrganizationFilters!]

  #  can have guests
  canHaveGuests: BooleanFilter

  #  is custom role enalbed
  isCustomRolesEnabled: BooleanFilter

  #  is guest invite approval required
  isGuestInviteApprovalRequired: BooleanFilter

  #  name
  name: StringFilter

  #  not filter
  not: [OrganizationFilters!]

  #  or filter
  or: [OrganizationFilters!]

  #  Secondary name
  secondaryName: StringFilter
}

#  Organization Order by field
enum OrganizationOrderByField {
  #  Order by the creation date
  createdAt

  #  Order by name
  name

  #  Order by secondaryName
  secondaryName

  #  Order by subscriptionMode
  subscriptionMode

  #  Order by the last updated date
  updatedAt
}

#  Organization ordering options.
input OrganizationOrderedFields {
  #
  createdAt: OrderBy

  #
  name: OrderBy

  #
  secondaryName: OrderBy

  #
  subscriptionMode: OrderBy

  #
  updatedAt: OrderBy
}

#  Organization Ordering
input OrganizationOrdering {
  #  sort fields
  field: OrganizationOrderByField

  #  order fields
  order: OrderBy = Asc

  #
  orderedField: OrganizationOrderedFields
}

#  A paginated collection of organizations.
type OrganizationsPaged {
  #  next
  next: String

  #  prev
  prev: String

  #  results
  results: [Organization!]

  #  totalItems
  totalItems: Int
}

#  OwnedBy
enum OwnedBy {
  #  Owned by me
  me

  #  Owned by other users
  others
}

#  Owned By Filter
input OwnedByFilter {
  #  equals
  eq: OwnedBy

  #  not equals
  ne: OwnedBy
}

input PaginationArgs {
  pageSize: Int = 25
}

#  The permission object reflects the access rights needed or attributed to an entity
type Permission {
  #  Created Date
  createdAt: DateTime!

  #  Permission Id
  id: ID!

  #  The Key this permission gets identified with.
  key: String

  #  The name of the Permission. It should be unique
  name: String!

  #  The resource type of the Permission
  resourceType: ResourceType!

  #  Updated Date
  updatedAt: DateTime!
}

#  A management mechanism to bulk manage permissions.
type PermissionGroup {
  #
  createdAt: DateTime!

  #  The description for the Permission Group.
  description: String

  #  The ID of the permission group.
  id: ID!

  #  True if not hidden
  isVisible: Boolean!

  #  The Key this Permission Group gets identified with.
  key: String

  #  The name of the Permission Group. It should be unique
  name: String!

  #  The permission groups that belong to this permission group.
  permissionGroups: [PermissionGroup!]!

  #  The permissions that belong to this permissions group.
  permissions: [Permission!]!

  #  The resource type of the Permission Group
  resourceType: ResourceType!

  #
  updatedAt: DateTime!
}

#  Filters for filtering paginated collections of permission groups
input PermissionGroupFilters {
  #
  and: [PermissionGroupFilters!]

  #
  name: StringFilter

  #
  not: [PermissionGroupFilters!]

  #
  or: [PermissionGroupFilters!]
}

#  Fields that can be specified for ordering criteria on paginated collections of permission groups.
enum PermissionGroupOrderByField {
  #  The name of the permission group.
  name

  #  The resource type of the permission group.
  resourceType
}

#  Permission group ordering options.
input PermissionGroupOrderedFields {
  #
  name: OrderBy

  #
  resourceType: OrderBy
}

#  A type to specify the ordering of paginated collections of permission groups
input PermissionGroupOrdering {
  #
  field: PermissionGroupOrderByField

  #
  order: OrderBy = Asc

  #
  orderedField: PermissionGroupOrderedFields
}

#  A paginated collection of permission groups.
type PermissionGroupsPaged {
  #  next
  next: String

  #  prev
  prev: String

  #  results
  results: [PermissionGroup!]

  #  totalItems
  totalItems: Int
}

#  Available types of resource
enum ResourceType {
  #  Accounts are entities for billing and associated to one or more organizations
  Account

  #  Application refers to the entire Bluescape instance
  Application

  #  Groups a mechanism to bulk manage users associations to organizations and workspaces
  Group

  #  Organizations are entities for the coordination of users and workspaces
  Organization

  #  Templates a set of predefined workspace elements
  Template

  #  Workspaces are the principle unit that reflects a digital container
  Workspace
}

#  Resource filter
input ResourceTypeFilter {
  #  Equal
  eq: ResourceType

  #  Not Equal
  ne: ResourceType
}

#  The role used in the management and association of permissions for access control.
type Role {
  #  Created Date
  createdAt: DateTime!

  #  The description for the role.
  description: String

  #  Role Id
  id: ID!

  #  True if it is a custom role
  isCustom: Boolean!

  #  The name for the role. It should be unique
  name: String!

  #  The organization this role is associated with
  organization: Organization

  #  Permission groups associated to the role.
  permissionGroups(
    #  cursor
    cursor: String

    #  filtering
    filtering: PermissionGroupFilters

    #  ordering
    ordering: [PermissionGroupOrdering!]

    #  pagination
    pagination: PaginationArgs
  ): PermissionGroupsPaged!

  #
  permissions: [String!]

  #  The resource type this role applies to
  resourceType: ResourceType!

  #  The type of role
  type: RoleType!

  #  Updated Date
  updatedAt: DateTime!
}

#  Event produced when a role is created.
type RoleCreated {
  #  actorId
  actorId: ID!

  #  actorType
  actorType: String!

  #  category
  category: String!

  #  containsConfidential
  containsConfidential: Boolean!

  #  containsPII
  containsPII: Boolean!

  #  data
  data: RoleEventPayload!

  #  date
  date: String

  #  eventVersion
  eventVersion: String!

  #  organizationId
  organizationId: ID

  #  type
  type: String!

  #  workspaceId
  workspaceId: ID
}

#  Subscription options for role create events
input RoleCreatedSubscriptionOptions {
  #  organization Id
  organizationId: ID!
}

#  Event produced when a role is deleted.
type RoleDeleted {
  #  actorId
  actorId: ID!

  #  actorType
  actorType: String!

  #  category
  category: String!

  #  containsConfidential
  containsConfidential: Boolean!

  #  containsPII
  containsPII: Boolean!

  #  data
  data: RoleEventPayload!

  #  date
  date: String

  #  eventVersion
  eventVersion: String!

  #  organizationId
  organizationId: ID

  #  type
  type: String!

  #  workspaceId
  workspaceId: ID
}

#  Subscription options for role delete events
input RoleDeletedSubscriptionOptions {
  #  Organization Id
  organizationId: ID!

  #  Role Id
  roleId: ID!
}

#  Role event payload
type RoleEventPayload {
  #  Role
  role: RolePayload!
}

#  Role Filter
input RoleFilters {
  #  and filter
  and: [RoleFilters!]

  #  is custom
  isCustom: BooleanFilter

  #  name of the role
  name: StringFilter

  #  not filter
  not: [RoleFilters!]

  #  or filter
  or: [RoleFilters!]

  #  Organization Id
  organizationId: IDFilter

  #  Resource filter
  resourceType: ResourceTypeFilter

  #  Filter Type
  type: RoleTypeFilter
}

#  Role order
enum RoleOrderByField {
  #  Order by name
  name
}

#  Role ordering options.
input RoleOrderedFields {
  #
  name: OrderBy
}

#  Role ordering
input RoleOrdering {
  #  field
  field: RoleOrderByField

  #  order
  order: OrderBy = Asc

  #
  orderedField: RoleOrderedFields
}

#  Role event payload
type RolePayload {
  #  Created Date
  createdAt: String!

  #  description
  description: String

  #  Role Id
  id: ID!

  #  Role Name
  name: String!

  #  Organization Id
  organizationId: String!

  #  Resource Type
  resourceType: ResourceType!

  #  Role Type
  type: RoleType!

  #  Updated Date
  updatedAt: String!
}

#  Role changed event payload
type RolePayloadChanged {
  #  Id
  id: ID!

  #  The workspace this new role is associated with
  newWorkspaceRole: WorkspaceRolePayload

  #  The workspace this previous role is associated with
  previousWorkspaceRole: WorkspaceRolePayload

  #  Role Type
  type: String!
}

#  Expresses various levels of user access
enum RoleType {
  #  The Admin roleType is used to categorize roles for association with admins
  Admin

  #  The App roleType is used to categorize roles that can be assoiated to apps
  App

  #  The Owner roleType is used to categorize roles for the owner of a resource
  Owner

  #  The User roleType is used to categorize roles for association with users
  User

  #  The Visitor roleType is used to categorize roles for association with workspace visitors
  Visitor
}

#  RoleTypeFilter
input RoleTypeFilter {
  #  Equal
  eq: RoleType

  #  Not Equal
  ne: RoleType
}

#  Event produced when a role is updated.
type RoleUpdated {
  #  actorId
  actorId: ID!

  #  actorType
  actorType: String!

  #  category
  category: String!

  #  containsConfidential
  containsConfidential: Boolean!

  #  containsPII
  containsPII: Boolean!

  #  data
  data: RoleEventPayload!

  #  date
  date: String

  #  eventVersion
  eventVersion: String!

  #  organizationId
  organizationId: ID

  #  type
  type: String!

  #  workspaceId
  workspaceId: ID
}

#  Subscription options for role update events
input RoleUpdatedSubscriptionOptions {
  #  Organization Id
  organizationId: ID!

  #  Role Id
  roleId: ID!
}

#  A paginated collection of roles
type RolesPaged {
  #  next
  next: String

  #  prev
  prev: String

  #  results
  results: [Role!]

  #  totalItems
  totalItems: Int
}

#  The ScratchWorkspace type
type ScratchWorkspace {
  #  The id of the actor that created the scratch workspace. Only that actor (or matching email) can update it. Scratch workspaces created in V2 don't have an actorId but have a wallId
  actorId: String

  #  When the scratch workspace was created
  createdAt: DateTime!

  #  The email for the user who can modify or delete the scratch workspace
  email: String

  #  Scratch workspace Id
  id: ID!

  #  The name for the scratch workspace
  name: String

  #  When the scratch workspace was last updated
  updatedAt: DateTime!
}

#  Scratch workspace filters
input ScratchWorkspaceFilters {
  #  and filter
  and: [ScratchWorkspaceFilters!]

  #  id
  id: StringFilter

  #  name
  name: StringFilter

  #  not filter
  not: [ScratchWorkspaceFilters!]

  #  or filter
  or: [ScratchWorkspaceFilters!]
}

#  ScratchWorkspace orderBy Field
enum ScratchWorkspaceOrderByField {
  #  Actor that created the scratch workspace
  actorId

  #  Order by creation date
  createdAt

  #  Order by name
  name

  #  Order by last update date
  updatedAt
}

#  Scratch workspace ordering options.
input ScratchWorkspaceOrderedFields {
  #
  actorId: OrderBy

  #
  createdAt: OrderBy

  #
  name: OrderBy

  #
  updatedAt: OrderBy
}

#  Scratch workspace ordering
input ScratchWorkspaceOrdering {
  #  Field
  field: ScratchWorkspaceOrderByField

  #  Order
  order: OrderBy = Asc

  #
  orderedField: ScratchWorkspaceOrderedFields
}

#  A paginated collection of scratch workspaces
type ScratchWorkspacesPaged {
  #  next
  next: String

  #  prev
  prev: String

  #  results
  results: [ScratchWorkspace!]

  #  totalItems
  totalItems: Int
}

#  StringFilter
input StringFilter {
  #  contains
  contains: String

  #  equals
  eq: String

  #  not equal
  ne: String

  #  starts with
  startsWith: String
}

#  User token revoked event.
type TokenRevoked {
  #  actorId
  actorId: ID!

  #  actorType
  actorType: String!

  #  category
  category: String!

  #  containsConfidential
  containsConfidential: Boolean!

  #  containsPII
  containsPII: Boolean!

  #  Token Revoked Data
  data: TokenRevokedData!

  #  date
  date: String

  #  eventVersion
  eventVersion: String!

  #  organizationId
  organizationId: ID

  #  type
  type: String!

  #  workspaceId
  workspaceId: ID
}

#  Token revoked data type.
type TokenRevokedData {
  #  Identity Provider Id
  identityProviderId: ID

  #  Token Id
  tokenId: ID
}

#  Update custom link input
input UpdateCustomLinkInput {
  #  The name for the custom link. It should be unique
  name: String

  #  Owner Id
  ownerId: ID

  #  ResourceId of the resource pointed by the customLink
  resourceId: ID

  #  ResourceType of the resource pointed by the customLink
  resourceType: CustomLinkResourceType
}

#  updated indetity provider input
input UpdateIdentityProviderInput {
  #  The email address of the provider administrator
  adminEmail: String

  #  State of sp-initiated SAML single logout support
  isSamlSpSloEnabled: Boolean

  #  URL of the SAML metadata file. It is required if the new identity provider is one of the SAML types
  metadataUrl: String

  #  The name for the identity provider
  name: String

  #  The type of identity provider
  type: IDPTypeCreate

  #  Attribute name of User Guid in SAML assertion
  userGuidAttributeName: String
}

#  Update member role input
input UpdateMemberRoleInput {
  #  Organization Role Id
  organizationRoleId: ID!
}

#  Update Organization input
input UpdateOrganizationInput {
  #  Auto Associate Identity Provider User
  autoAssociateIdentityProviderUser: Boolean

  #  Can have guests
  canHaveGuests: Boolean

  #  Default Public Organization RoleId
  defaultOrganizationUserRoleId: ID

  #  Default Public Workspace RoleId
  defaultPublicWorkspaceRoleId: ID

  #  Expire Date
  expiredAt: DateTime

  #  Custom Roles Enabled
  isCustomRolesEnabled: Boolean

  #  Guest Invite Approval Required
  isGuestInviteApprovalRequired: Boolean

  #  Enable/disable Multi-factor authentication for the organization
  mfaEnabled: Boolean

  #  The name of the organization or company
  name: String

  #  Owner Id
  ownerId: ID

  #  The name of the team or organizational unit
  secondaryName: String
}

#  Update role input
input UpdateRoleInput {
  #  The description for the role.
  description: String

  #  The name for the role. It should be unique
  name: String

  #  Permission GroupIds
  permissionGroupIds: [ID!]

  #  The type of role
  type: RoleType
}

#  Update user input
input UpdateUserInput {
  #  Application Role Id
  applicationRoleId: String

  #  The email address of the user
  email: String

  #  The first name of the user
  firstName: String

  #  The status of the user's invitation
  invitationStatus: InvitationStatus

  #  The date when they last logged in
  lastLoggedInAt: DateTime

  #  The last name of the user
  lastName: String
}

#  Update user password input
input UpdateUserPasswordInput {
  #  Current Password of the user
  currentPassword: String!

  #  New Password of the user
  newPassword: String!

  #  Revoke ID tokens of the user
  revokeAllExistingLoginSessions: Boolean
}

#  Update workspace input
input UpdateWorkspaceInput {
  #  Archived Date
  archivedAt: DateTime

  #  The classification of workspace.
  classification: String

  #  Default Role Id
  defaultRoleId: String

  #  The description for the workspace.
  description: String

  #  True means that all users in the organization have access to this workspace
  isPublic: Boolean

  #  The name for the workspace. It should be unique
  name: String
}

#  A type representing a user.
type User {
  #  The user's role with respect to the application
  applicationRole: Role!

  #  The avatar url for the user
  avatarUrl: String @deprecated(reason: "New key signedAvatarUrl is added")

  #  The date the user was created
  createdAt: DateTime!

  #  The email address of the user
  email: String

  #  The first name of the user
  firstName: String

  #  The Id of the user
  id: ID!

  #  The status of the user's invitation
  invitationStatus: InvitationStatus

  #  The date when they last logged in
  lastLoggedInAt: DateTime

  #  The last name of the user
  lastName: String

  #  The avatar url for the user
  signedAvatarUrl: String

  #  The date the user was last updated
  updatedAt: DateTime
}

#  User event payload.
type UserEventPayload {
  #  User Id
  userId: ID!
}

#  User Filters
input UserFilters {
  #  and filter
  and: [UserFilters!]

  #  Avatar URL
  avatarUrl: StringFilter

  #  Email
  email: StringFilter

  #  First Name
  firstName: StringFilter

  #  Invitation status
  invitationStatus: InvitationStatusFilter

  #  Last Logged Date
  lastLoggedInAt: DateFilter

  #  Last Name
  lastName: StringFilter

  #  not filter
  not: [UserFilters!]

  #  or filter
  or: [UserFilters!]
}

#  User login event.
type UserLogin {
  #  actorId
  actorId: ID!

  #  actorType
  actorType: String!

  #  category
  category: String!

  #  containsConfidential
  containsConfidential: Boolean!

  #  containsPII
  containsPII: Boolean!

  #  User Login Data
  data: UserLoginData!

  #  date
  date: String

  #  eventVersion
  eventVersion: String!

  #  organizationId
  organizationId: ID

  #  type
  type: String!

  #  workspaceId
  workspaceId: ID
}

#  User login data.
type UserLoginData {
  #  Identity Provider Id
  identityProviderId: ID
}

#  User Login Subscription
input UserLoginSubscriptionOptions {
  #  User Id
  userId: ID
}

#  Sort fields
enum UserOrderByField {
  #  Order by email.
  email

  #  Order by firstName.
  firstName

  #  Order by last login date.
  lastLoggedInAt

  #  Order by lastName.
  lastName
}

#  User ordering options.
input UserOrderedFields {
  #
  email: OrderBy

  #
  lastLoggedInAt: OrderBy

  #
  lastName: OrderBy

  #
  updatedAt: OrderBy
}

#  User Ordering
input UserOrdering {
  #  sort fields
  field: UserOrderByField

  #  order fields
  order: OrderBy = Asc

  #
  orderedField: UserOrderedFields
}

#  User registered event.
type UserRegistered {
  #  actorId
  actorId: ID!

  #  actorType
  actorType: String!

  #  category
  category: String!

  #  containsConfidential
  containsConfidential: Boolean!

  #  containsPII
  containsPII: Boolean!

  #  User Registered Data
  data: UserResendActivationData!

  #  date
  date: String

  #  eventVersion
  eventVersion: String!

  #  organizationId
  organizationId: ID

  #  type
  type: String!

  #  workspaceId
  workspaceId: ID
}

#  User resend activation event.
type UserResendActivation {
  #  actorId
  actorId: ID!

  #  actorType
  actorType: String!

  #  category
  category: String!

  #  containsConfidential
  containsConfidential: Boolean!

  #  containsPII
  containsPII: Boolean!

  #  data
  data: UserResendActivationData!

  #  date
  date: String

  #  eventVersion
  eventVersion: String!

  #  organizationId
  organizationId: ID

  #  type
  type: String!

  #  workspaceId
  workspaceId: ID
}

#  User resend activation data.
type UserResendActivationData {
  #  State of the user
  state: UserStateChange!

  #  Id of the User
  userId: ID
}

#  User password reset event.
type UserResetPassword {
  #  actorId
  actorId: ID!

  #  actorType
  actorType: String!

  #  category
  category: String!

  #  containsConfidential
  containsConfidential: Boolean!

  #  containsPII
  containsPII: Boolean!

  #  data
  data: UserEventPayload!

  #  date
  date: String

  #  eventVersion
  eventVersion: String!

  #  organizationId
  organizationId: ID

  #  type
  type: String!

  #  workspaceId
  workspaceId: ID
}

#  User state change event.
type UserStateChange {
  #  Current state of the user
  current: String!

  #  Previous state of the user
  previous: String!
}

#  User updated event.
type UserUpdated {
  #  actorId
  actorId: ID!

  #  actorType
  actorType: String!

  #  category
  category: String!

  #  containsConfidential
  containsConfidential: Boolean!

  #  containsPII
  containsPII: Boolean!

  #  Update user event data
  data: UserUpdatedEventPayload!

  #  date
  date: String

  #  eventVersion
  eventVersion: String!

  #  organizationId
  organizationId: ID

  #  type
  type: String!

  #  workspaceId
  workspaceId: ID
}

#  User update event payload.
type UserUpdatedEventPayload {
  #  Email of the user
  email: String!

  #  First name of the user
  firstName: String!

  #  Id of the user
  id: ID!

  #  Last name of the user
  lastName: String!
}

#  Subscription User Updated
input UserUpdatedSubscriptionOptions {
  #  Id of the User
  userId: ID!
}

#  Workspace associated to the user.
type UserWorkspace {
  #  Archived Date
  archivedAt: DateTime

  #  The classification of workspace.
  classification: String

  #  Collaborators
  collaborators(
    #  cursor
    cursor: String

    #  filtering
    filtering: CollaboratorFilters

    #  ordering
    ordering: [CollaboratorOrdering!]

    #  pagination
    pagination: PaginationArgs
  ): CollaboratorsPaged!

  #  Content Updated Date
  contentUpdatedAt: DateTime

  #  Created Date
  createdAt: DateTime!

  #  Default Role
  defaultRole: Role!

  #  The description for the workspace.
  description: String

  #  Workspace Id
  id: ID!

  #  True means that all users in the organization have access to this workspace
  isPublic: Boolean!

  #  The name for the workspace. It should be unique
  name: String!

  #  Organization
  organization: Organization!

  #  Owner
  owner: User!

  #  Updated Date
  updatedAt: DateTime!
}

#  User Workspace Filters
input UserWorkspaceFilters {
  #  and filter
  and: [UserWorkspaceFilters!]

  #  Deprecation Warning:
  #
  #     The associatedWorkspace key is ambiguious. This filter will soon be removed.
  #     *false*: return private(collaborator/owner) and includes all public workspaces list that are in the session user organization.
  #     *true*: return excludes all public workspaces to which the session user has NOT been explicitly invited to collaborate and all private workspaces to which the session user is a collaborator/owner
  associatedWorkspaces: BooleanFilter

  #  Created Date
  createdAt: DateFilter

  #  Id
  id: StringFilter

  #  is public
  isPublic: BooleanFilter

  #  name
  name: StringFilter

  #  not filter
  not: [UserWorkspaceFilters!]

  #  or filter
  or: [UserWorkspaceFilters!]

  #  Organization Id
  organizationId: StringFilter

  #  Owned by filter
  ownedBy: OwnedByFilter

  #  updated date
  updatedAt: DateFilter
}

#  A paginated collection of workspaces associated to the user.
type UserWorkspacesPaged {
  #  next
  next: String

  #  prev
  prev: String

  #  results
  results: [UserWorkspace!]

  #  totalItems
  totalItems: Int
}

#  A paginated collection of users.
type UsersPaged {
  #  next
  next: String

  #  prev
  prev: String

  #  results
  results: [User!]

  #  totalItems
  totalItems: Int
}

#  The wall type.
type Wall {
  #  The boolean value of active or inactive wall information
  archived: Boolean!

  #  The date the wall was created
  createdAt: DateTime!

  #  The workspace the wall loads on boot
  defaultWorkspace: Workspace

  #  The Id of the wall
  id: ID!

  #  The name of the wall
  name: String!

  #  Organization information based on specific wall
  organization: Organization!

  #  The date when the wall was last updated
  updatedAt: DateTime!
}

#  Filters for wall listing queries
input WallFilters {
  #
  and: [WallFilters!]

  #
  archived: BooleanFilter

  #
  name: StringFilter

  #
  not: [WallFilters!]

  #
  or: [WallFilters!]

  #
  organizationId: StringFilter
}

#  Wall ordering options.
input WallOrderedFields {
  #
  archived: OrderBy

  #
  createdAt: OrderBy

  #
  updatedAt: OrderBy
}

#   Types for ordering wall listings
input WallOrdering {
  #
  field: WallsOrderByField

  #
  order: OrderBy = Asc

  #
  orderedField: WallOrderedFields
}

#  Walls Orderby Field
enum WallsOrderByField {
  #  True if the wall is archived.
  archived

  #  The date the wall was created.
  createdAt

  #  The id of the wall.
  id

  #  The name of the wall.
  name

  #  The data the wall was last updated.
  updatedAt
}

#  A paginated collection of walls.
type WallsPaged {
  #  next
  next: String

  #  prev
  prev: String

  #  results
  results: [Wall!]

  #  totalItems
  totalItems: Int
}

#  The type expressing workspace management state.
type Workspace {
  #  Archived Date
  archivedAt: DateTime

  #  The classification of workspace.
  classification: String

  #  Collaborators on the workspace.
  collaborators(
    #  cursor
    cursor: String

    #  filtering by fields
    filtering: CollaboratorFilters

    #  ordering
    ordering: [CollaboratorOrdering!]

    #  pagination
    pagination: PaginationArgs
  ): CollaboratorsPaged!

  #  Content Updated Date
  contentUpdatedAt: DateTime

  #  Created Date
  createdAt: DateTime!

  #  The Role this workspace is associated with
  defaultRole: Role

  #  The description for the workspace.
  description: String

  #  Workspace Id
  id: ID!

  #  True means that all users in the organization have access to this workspace
  isPublic: Boolean!

  #  The name for the workspace. It should be unique
  name: String!

  #  The organization this workspace is associated with
  organization: Organization!

  #  Owner data
  owner: User

  #  Updated Date
  updatedAt: DateTime!
  elements: [Element]
}

#  Workspace access request.
type WorkspaceAccessRequest {
  #
  createdAt: DateTime!

  #
  deletedAt: DateTime

  #
  expiredAt: DateTime!

  #
  id: ID!

  #
  requestedAt: DateTime!

  #  The status for the workspace access request
  status: String!

  #
  updatedAt: DateTime!

  #
  user: User
}

#  Workspace access request created event.
type WorkspaceAccessRequestCreated {
  #  actorId
  actorId: ID!

  #  actorType
  actorType: String!

  #  category
  category: String!

  #  containsConfidential
  containsConfidential: Boolean!

  #  containsPII
  containsPII: Boolean!

  #
  data: WorkspaceAccessRequestPayload!

  #  date
  date: String

  #  eventVersion
  eventVersion: String!

  #  organizationId
  organizationId: ID

  #  type
  type: String!

  #  workspaceId
  workspaceId: ID
}

#  WorkspaceAccessRequestCreatedSubscriptionOptions
input WorkspaceAccessRequestCreatedSubscriptionOptions {
  #
  workspaceId: ID!
}

#  Workspace access request filters
input WorkspaceAccessRequestFilters {
  #
  and: [WorkspaceAccessRequestFilters!]

  #
  email: StringFilter

  #
  firstName: StringFilter

  #
  lastName: StringFilter

  #
  not: [WorkspaceAccessRequestFilters!]

  #
  or: [WorkspaceAccessRequestFilters!]

  #
  status: StringFilter
}

#  WorkspaceAccessRequestOrderByField
enum WorkspaceAccessRequestOrderByField {
  #  email address
  email

  #  first name
  firstName

  #  family name
  lastName

  #  access request status.
  status
}

#  Workspace access request ordering options.
input WorkspaceAccessRequestOrderedFields {
  #
  email: OrderBy

  #
  firstName: OrderBy

  #
  lastName: OrderBy

  #
  status: OrderBy
}

#  Ordering fields
input WorkspaceAccessRequestOrdering {
  #
  field: WorkspaceAccessRequestOrderByField

  #
  order: OrderBy = Asc

  #
  orderedField: WorkspaceAccessRequestOrderedFields
}

#  A paged collection of workspace access requests.
type WorkspaceAccessRequestPaged {
  #  next
  next: String

  #  prev
  prev: String

  #  results
  results: [WorkspaceAccessRequest!]

  #  totalItems
  totalItems: Int
}

#  Workspace access request payload.
type WorkspaceAccessRequestPayload {
  #
  id: ID!

  #  The status for the workspace access request
  status: String!

  #
  userId: ID!
}

#  Workspace access request update event.
type WorkspaceAccessRequestUpdate {
  #  actorId
  actorId: ID!

  #  actorType
  actorType: String!

  #  category
  category: String!

  #  containsConfidential
  containsConfidential: Boolean!

  #  containsPII
  containsPII: Boolean!

  #
  data: WorkspaceAccessRequestPayload!

  #  date
  date: String

  #  eventVersion
  eventVersion: String!

  #  organizationId
  organizationId: ID

  #  type
  type: String!

  #  workspaceId
  workspaceId: ID
}

#  WorkspaceAccessRequestUpdateSubscriptionOptions
input WorkspaceAccessRequestUpdateSubscriptionOptions {
  #
  requestId: ID!

  #
  userId: ID!
}

#  Workspace created event.
type WorkspaceCreated {
  #  actorId
  actorId: ID!

  #  actorType
  actorType: String!

  #  category
  category: String!

  #  containsConfidential
  containsConfidential: Boolean!

  #  containsPII
  containsPII: Boolean!

  #  Workspace Created
  data: WorkspaceEventPayload!

  #  date
  date: String

  #  eventVersion
  eventVersion: String!

  #  organizationId
  organizationId: ID

  #  type
  type: String!

  #  workspaceId
  workspaceId: ID
}

#  Workspace duplicated event.
type WorkspaceDuplicated {
  #  actorId
  actorId: ID!

  #  actorType
  actorType: String!

  #  category
  category: String!

  #  containsConfidential
  containsConfidential: Boolean!

  #  containsPII
  containsPII: Boolean!

  #  Workspace Duplicated
  data: WorkspaceDuplicatedEventPayload!

  #  date
  date: String

  #  eventVersion
  eventVersion: String!

  #  organizationId
  organizationId: ID

  #  type
  type: String!

  #  workspaceId
  workspaceId: ID
}

#  Workspace duplicated event payload.
type WorkspaceDuplicatedEventPayload {
  #  New Workspace
  newWorkspace: WorkspacePayload!

  #  Organization Id
  organizationId: String!
}

#  Workspace duplicated subscription
input WorkspaceDuplicatedSubscriptionOptions {
  #  Workspace Id
  workspaceId: ID!
}

#  The workspace event payload.
type WorkspaceEventPayload {
  #  Organization Id
  organizationId: String!

  #  Workspace Event Payload
  workspace: WorkspacePayload!
}

#  Workspace filters
input WorkspaceFilters {
  #  and filter
  and: [WorkspaceFilters!]

  #  Created Date
  createdAt: DateFilter

  #  Id
  id: StringFilter

  #  is public
  isPublic: BooleanFilter

  #  name
  name: StringFilter

  #  not filter
  not: [WorkspaceFilters!]

  #  or filter
  or: [WorkspaceFilters!]

  #  Organization Id
  organizationId: StringFilter

  #  updated date
  updatedAt: DateFilter
}

#  Work space orderBy Field
enum WorkspaceOrderByField {
  #  Order by last date the content was updated.
  contentUpdatedAt

  #  Order by creation date.
  createdAt

  #  Order by name.
  name

  #  Order by last update date.
  updatedAt
}

#  Workspace ordering options.
input WorkspaceOrderedFields {
  #
  contentUpdatedAt: OrderBy

  #
  createdAt: OrderBy

  #
  name: OrderBy

  #
  updatedAt: OrderBy
}

#  Workspace ordering
input WorkspaceOrdering {
  #  Field
  field: WorkspaceOrderByField

  #  Order
  order: OrderBy = Asc

  #  Field
  orderedField: WorkspaceOrderedFields
}

#  The workspace type for a workspace event payload.
type WorkspacePayload {
  #  Created Date
  createdAt: String!

  #  Default Role Id
  defaultRoleId: String!

  #  Description
  description: String

  #  Workspace Id
  id: ID!

  #  isPublic
  isPublic: Boolean!

  #  The name for the workspace
  name: String!

  #  Owner Id
  ownerId: String

  #  Updated Date
  updatedAt: String!
}

#  Workspace reassigned event.
type WorkspaceReassigned {
  #  actorId
  actorId: ID!

  #  actorType
  actorType: String!

  #  category
  category: String!

  #  containsConfidential
  containsConfidential: Boolean!

  #  containsPII
  containsPII: Boolean!

  #  Workspace Reassigned
  data: WorkspaceReassignedPayload!

  #  date
  date: String

  #  eventVersion
  eventVersion: String!

  #  organizationId
  organizationId: ID

  #  type
  type: String!

  #  workspaceId
  workspaceId: ID
}

#  Workspace reassign event payload.
type WorkspaceReassignedPayload {
  #  The id of the user to whom this workspace is reassigned now
  newOwnerId: String!

  #  The id of the user who owned this workspace previously
  oldOwnerId: String!

  #  The workspace ids which are reassigned
  workspaceIds: [ID!]!
}

#  Workspace Reassigned subscription
input WorkspaceReassignedSubscriptionOptions {
  #  Old Workspace OwnerId
  oldWorkspaceOwnerId: ID!

  #  Organization Id
  organizationId: ID!
}

#  Workspace role event payload
type WorkspaceRolePayload {
  #  Organization Id
  id: ID!

  #  Workspace Role Name
  name: String!

  #  order
  order: Float!

  #  Workspace Role Type
  type: String!
}

#  Workspace updated event.
type WorkspaceUpdated {
  #  actorId
  actorId: ID!

  #  actorType
  actorType: String!

  #  category
  category: String!

  #  containsConfidential
  containsConfidential: Boolean!

  #  containsPII
  containsPII: Boolean!

  #  Workspace Updated
  data: WorkspaceUpdatedEventPayload!

  #  date
  date: String

  #  eventVersion
  eventVersion: String!

  #  organizationId
  organizationId: ID

  #  type
  type: String!

  #  workspaceId
  workspaceId: ID
}

#  Workspace updated event payload.
type WorkspaceUpdatedEventPayload {
  #  Work space Updated Event Payload
  workspace: WorkspacePayload!
}

#  Workspace updated subscription
input WorkspaceUpdatedSubscriptionOptions {
  #  Organization Id
  organizationId: String!

  #  Workspace Id
  workspaceId: ID!
}

#  A paginated collection of workspaces.
type WorkspacesPaged {
  #  next
  next: String

  #  prev
  prev: String

  #  results
  results: [Workspace!]

  #  totalItems
  totalItems: Int
}

type UpdateBrowser implements UpdateAttachable & UpdateElement {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateSimilitude
  style: UpdateBrowserStyle
  url: String
}

interface UpdateAttachable {
  pinned: Boolean
  zIndex: Int
  surface: String
}

interface UpdateElement {
  pinned: Boolean
  zIndex: Int
}

# translation relative to origin and uniform scaling. The object is translated and then scaled with the origin at the top left corner of its bounding box
type UpdateSimilitude {
  # x coordinate
  x: Float

  # y coordinate
  y: Float

  # uniform scaling factor
  scale: Float
}

type UpdateBrowserStyle {
  width: Float
  height: Float
}

type UpdateCanvas implements UpdateElement {
  pinned: Boolean
  zIndex: Int
  transform: UpdateTranslation
  style: UpdateCanvasStyle
  name: String
}

# translation relative to origin
type UpdateTranslation {
  # x coordinate
  x: Float

  # y coordinate
  y: Float
}

type UpdateCanvasStyle {
  width: Float
  height: Float

  # Beta (now accepts any RGBA color): This is a Beta feature that is still in development, the documentation and features are subject to change before their GA release. We welcome any feedback you may have that we can use to improve the final version. While we will do our best to communicate breaking changes, think careful about where you deploy integrations using them.
  borderColor: Color

  # Beta: This is a Beta feature that is still in development, the documentation and features are subject to change before their GA release. We welcome any feedback you may have that we can use to improve the final version. While we will do our best to communicate breaking changes, think careful about where you deploy integrations using them.
  fillColor: Color

  # Beta: This is a Beta feature that is still in development, the documentation and features are subject to change before their GA release. We welcome any feedback you may have that we can use to improve the final version. While we will do our best to communicate breaking changes, think careful about where you deploy integrations using them.
  showName: Boolean
}

type Color {
  r: Int!
  g: Int!
  b: Int!
  a: Float!
}

type UpdateDocument implements UpdateAssetElement & UpdateAttachable & UpdateElement {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateSimilitude
}

interface UpdateAssetElement {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateSimilitude
}

type UpdateGrid implements UpdateElement {
  pinned: Boolean
  zIndex: Int
  transform: UpdateTranslation
  rowCount: Int
  columnCount: Int

  # replacement grid cell list
  cells: [Cell!]
  style: UpdateGridStyle
}

type Cell {
  # id of the element occupying this cell
  elementId: String!
  row: Int!
  column: Int!
}

type UpdateGridStyle {
  horizontalCellMargin: Float
  verticalCellMargin: Float
  cellWidth: Float
  cellHeight: Float
}

type UpdateIcon implements UpdateAttachable & UpdateElement {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateSimilitude
  style: UpdateIconStyle
}

type UpdateIconStyle {
  color: Color
}

type UpdateImage implements UpdateAssetElement & UpdateAttachable & UpdateElement {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateSimilitude
}

type UpdateLegacyNote implements UpdateAttachable & UpdateElement {
  pinned: Boolean
  zIndex: Int
  surface: String
  text: String
  transform: Similitude
  style: UpdateLegacyNoteStyle
}

# translation relative to origin and uniform scaling. The object is translated and then scaled with the origin at the top left corner of its bounding box
type Similitude {
  # x coordinate
  x: Float

  # y coordinate
  y: Float

  # uniform scaling factor
  scale: Float
}

type UpdateLegacyNoteStyle {
  fontWeight: FontWeight
  textTransform: TextTransform
  backgroundColor: Color
}

# Font weight (boldness).
enum FontWeight {
  normal
  bold
}

# Text transform. The non-default value of `uppercase` may only occur in legacy text.
enum TextTransform {
  none
  uppercase
}

type UpdateLine implements UpdateAttachable & UpdateElement {
  pinned: Boolean
  zIndex: Int
  surface: String
  style: UpdateLineStyle
  routing: LineRouting
  controlPoints: [LinePoint!]
  start: LinePoint
  end: LinePoint
}

type UpdateLineStyle {
  strokeColor: Color
  strokeStyle: LineStrokeStyle
  strokeWidth: Float
  startCap: LineCapStyle
  endCap: LineCapStyle
}

# one of Solid, Dot, DashShort, DashLong
enum LineStrokeStyle {
  Solid
  Dot
  DashShort
  DashLong
}

# one of None, ArrowFill, ArrowStroke, Tee, Circle
enum LineCapStyle {
  None
  ArrowFill
  ArrowStroke
  Tee
  Circle
}

# one of Direct, Orthogonal
enum LineRouting {
  Direct
  Orthogonal
}

# A line point, which can be either an anchor or an absolute workspace coordinate
union LinePoint = AbsoluteLinePoint | AnchorLinePoint

type AbsoluteLinePoint {
  # workspace x coordinate
  x: Float!

  # workspace y coordinate
  y: Float!
}

type AnchorLinePoint {
  # element ID of anchor
  id: String!

  # position along element's horizontal
  u: Float!

  # position along element's vertical
  v: Float!
}

type UpdateRegularShapeStyle implements UpdateShapeStyle {
  width: Float
  height: Float
  strokeWidth: Float
  strokeColor: Color
  fillColor: Color
}

interface UpdateShapeStyle {
  width: Float
  height: Float
  fillColor: Color
}

type UpdateStickyShapeStyle implements UpdateShapeStyle {
  width: Float
  fillColor: Color
  height: Float
}

type UpdateShape implements UpdateAttachable & UpdateElement {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateTranslation
  style: UpdateShapeStyle
  kind: ShapeKind

  # text on shape
  text: String
  blocks: [ToplevelBlockTextContent!]
  textStyle: UpdateShapeTextStyle
  mirrorX: Boolean
  mirrorY: Boolean
}

enum ShapeKind {
  Rectangle
  Ellipse
  TriangleUp
  TriangleRight
  Diamond
  Cylinder
  ArrowUp
  ArrowRight
  ArrowUpDown
  ArrowLeftRight
  ArrowAll
  Star5
  Hexagon
  Octagon
  StickySquare
}

# Block text content that does not have to be nested inside other block content.
interface ToplevelBlockTextContent {
  align: HorizontalAlign!
}

enum HorizontalAlign {
  left
  right
  center
  justify
}

type UpdateShapeTextStyle {
  # font size in pixels. Set to "auto" to adjust font size to a shape.
  fontSize: FontSize

  # font family
  fontFamily: String
  verticalAlign: VerticalAlign
  color: Color
}

# The `FontSize` scalar type can be either integer value representing font size in pixels or "auto".
scalar FontSize

enum VerticalAlign {
  top
  center
  bottom
}

type UpdateStroke implements UpdateElement {
  pinned: Boolean
  zIndex: Int
  transform: UpdateSimilitude
}

type UpdateText implements UpdateAttachable & UpdateElement {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateTransform
  text: String @deprecated(reason: "please use \"blocks\" instead")
  blocks: [ToplevelBlockTextContent!]
  style: UpdateTextStyle
}

# translation relative to origin and scaling. The object is translated and then scaled with the origin at the top left corner of its bounding box
type UpdateTransform {
  # x coordinate
  x: Float

  # y coordinate
  y: Float

  # x-coordinate scaling factor
  scaleX: Float

  # y-coordinate scaling factor
  scaleY: Float
}

type UpdateTextStyle {
  width: Float
  height: Float
  fontSize: Int

  # Font family name.
  fontFamily: String
  color: Color
  backgroundColor: Color
  verticalAlign: VerticalAlign
}

type UpdateVideo implements UpdateAssetElement & UpdateAttachable & UpdateElement {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateSimilitude
}

type UpdateWindow implements UpdateAttachable & UpdateElement {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateSimilitude
}

input UpdateBrowserInput {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateSimilitudeInput
  style: UpdateBrowserStyleInput
  url: String
}

# translation relative to origin and uniform scaling. The object is translated and then scaled with the origin at the top left corner of its bounding box
input UpdateSimilitudeInput {
  # x coordinate
  x: Float

  # y coordinate
  y: Float

  # uniform scaling factor
  scale: Float
}

input UpdateBrowserStyleInput {
  width: Float
  height: Float
}

input UpdateCanvasInput {
  pinned: Boolean
  zIndex: Int
  transform: UpdateTranslationInput
  style: UpdateCanvasStyleInput
  name: String
}

# translation relative to origin
input UpdateTranslationInput {
  # x coordinate
  x: Float

  # y coordinate
  y: Float
}

input UpdateCanvasStyleInput {
  width: Float
  height: Float

  # Beta (now accepts any RGBA color): This is a Beta feature that is still in development, the documentation and features are subject to change before their GA release. We welcome any feedback you may have that we can use to improve the final version. While we will do our best to communicate breaking changes, think careful about where you deploy integrations using them.
  borderColor: ColorInput

  # Beta: This is a Beta feature that is still in development, the documentation and features are subject to change before their GA release. We welcome any feedback you may have that we can use to improve the final version. While we will do our best to communicate breaking changes, think careful about where you deploy integrations using them.
  fillColor: ColorInput

  # Beta: This is a Beta feature that is still in development, the documentation and features are subject to change before their GA release. We welcome any feedback you may have that we can use to improve the final version. While we will do our best to communicate breaking changes, think careful about where you deploy integrations using them.
  showName: Boolean
}

input ColorInput {
  r: Int = 0
  g: Int = 0
  b: Int = 0
  a: Float = 1
}

input UpdateDocumentInput {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateSimilitudeInput = {}
}

input UpdateGridInput {
  pinned: Boolean
  zIndex: Int
  transform: UpdateTranslationInput
  rowCount: Int
  columnCount: Int

  # replacement grid cell list
  cells: [CellInput!]
  style: UpdateGridStyleInput
}

input CellInput {
  # id of the element occupying this cell
  elementId: String!
  row: Int!
  column: Int!
}

input UpdateGridStyleInput {
  horizontalCellMargin: Float
  verticalCellMargin: Float
  cellWidth: Float
  cellHeight: Float
}

input UpdateIconInput {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateSimilitudeInput
  style: UpdateIconStyleInput
}

input UpdateIconStyleInput {
  color: ColorInput
}

input UpdateImageInput {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateSimilitudeInput = {}
}

input UpdateStrokeInput {
  pinned: Boolean
  zIndex: Int
  transform: UpdateSimilitudeInput
}

input UpdateVideoInput {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateSimilitudeInput = {}
}

input UpdateWindowInput {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateSimilitudeInput
}

# web browser
type Browser implements Element & Attachable & Surface & Selectable {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  attachments(type: [AttachableType!]): [Attachable!]!
  surface: Surface
  url: String
  style: BrowserStyle!
}

# Basic workspace building block
interface Element {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
}

# translation relative to origin and scaling. The object is translated and then scaled with the origin at the top left corner of its bounding box
type Transform {
  # x coordinate
  x: Float!

  # y coordinate
  y: Float!

  # x-coordinate scaling factor
  scaleX: Float!

  # y-coordinate scaling factor
  scaleY: Float!
}

# Comment
type Comment {
  id: ID!

  # Parent comment id.
  parentId: String
  createdAt: DateTime!

  # Identity of commenter.
  actorId: ID!
  actorType: String!

  # Text contents of `.blocks`, extracted without structure and joined by newline characters.
  text: String!

  # First and last name of the commenter.
  commenterName: String!

  # JSON-LD-conforming document representing arbitrary persistent metadata of the comment.
  traits: JSONObject

  # Blocks of comment text.
  blocks: [CommentBlock!]!
}

# The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
scalar JSONObject

# Comment block
type CommentBlock {
  # Structured comment content.
  content: [InlineCommentContentJSON!]!
}

# Comment content as JSON, conforming to the GraphQL SDL definition of `InlineCommentContent`. See the SDL definition for details.
scalar InlineCommentContentJSON

# Bounding box of an element, relative to the origin
type Box {
  # x-coordinate of the top left corner
  x: Float!

  # y-coordinate of the top left corner
  y: Float!

  # width
  width: Float!

  # height
  height: Float!
}

# The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
scalar JSON

# Element that can be attached to other elements
interface Attachable {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  surface: Surface
}

# Element to which other elements can be attached
interface Surface {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  attachments(type: [AttachableType!]): [Attachable!]!
}

# Attachable Element type
enum AttachableType {
  Text
  LegacyNote
  Icon
  Image
  Document
  Browser
  Video
  Stroke
  Shape
  Line
  Window
  Whiteboard
  LinkedDocument
}

# Element that can be selected/grouped
interface Selectable {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
}

type BrowserStyle {
  frameless: Boolean!
  width: Float!
  height: Float!
}

# Rectangular area of the workspace
type Canvas implements Element {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  name: String!
  style: CanvasStyle!
}

type CanvasStyle {
  width: Float!
  height: Float!

  # Beta (now accepts any RGBA color): This is a Beta feature that is still in development, the documentation and features are subject to change before their GA release. We welcome any feedback you may have that we can use to improve the final version. While we will do our best to communicate breaking changes, think careful about where you deploy integrations using them.
  borderColor: Color!

  # Beta: This is a Beta feature that is still in development, the documentation and features are subject to change before their GA release. We welcome any feedback you may have that we can use to improve the final version. While we will do our best to communicate breaking changes, think careful about where you deploy integrations using them.
  fillColor: Color!

  # Beta: This is a Beta feature that is still in development, the documentation and features are subject to change before their GA release. We welcome any feedback you may have that we can use to improve the final version. While we will do our best to communicate breaking changes, think careful about where you deploy integrations using them.
  showName: Boolean!
}

# multipage document with navigation capabilities
type Document implements Element & Attachable & Surface & Selectable & AssetBacked {
  # Intrinsic asset width
  width: Float!

  # Intrinsic asset height
  height: Float!

  # Asset title
  title: String!

  # Original filename, if the asset was uploaded directly by the client (as opposed to from URL)
  filename: String

  # Source URL, if the asset was uploaded via URL
  sourceUrl: String

  # asset url, provided if asset download is allowed and asset format
  preview: ImageAsset
  ingestionState: AssetIngestionState!

  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  attachments(type: [AttachableType!]): [Attachable!]!
  surface: Surface

  # asset url, provided if asset download is allowed and asset format
  asset: DocumentAsset!
}

# Elements backed by immutable assets
interface AssetBacked {
  # Intrinsic asset width
  width: Float!

  # Intrinsic asset height
  height: Float!

  # Asset title
  title: String!

  # Original filename, if the asset was uploaded directly by the client (as opposed to from URL)
  filename: String

  # Source URL, if the asset was uploaded via URL
  sourceUrl: String

  # asset url, provided if asset download is allowed and asset format
  preview: ImageAsset
  ingestionState: AssetIngestionState!
}

# Image asset information
type ImageAsset {
  imageFormat: ImageFormat!

  # asset url, provided if asset download is allowed
  url(scale: AssetScale): String
}

enum ImageFormat {
  jpeg
  gif
  png
  tiff
  unknown
}

enum AssetScale {
  Original
  High
  Medium
  Low
}

# Ingestion state
enum AssetIngestionState {
  processing
  complete_success
  complete_failure
  transferring
}

# Document asset information
type DocumentAsset {
  documentFormat: DocumentFormat!

  # asset url, provided if asset download is allowed
  url(scale: AssetScale): String
}

enum DocumentFormat {
  doc
  docx
  ppt
  pptx
  xls
  xlsx
  pdf
  unknown
}

# Element grid
type Grid implements Element {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  rowCount: Int!
  columnCount: Int!
  cells: [Cell!]!
  style: GridStyle!
}

type GridStyle {
  horizontalCellMargin: Float!
  verticalCellMargin: Float!
  cellWidth: Float!
  cellHeight: Float!
}

# Icon element
type Icon implements Element & Attachable & Surface & Selectable {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  attachments(type: [AttachableType!]): [Attachable!]!
  surface: Surface
  style: IconStyle

  # Defines the width of the icon
  width: Float!

  # Defines the height of the icon
  height: Float!
  assetPath: String!
}

type IconStyle {
  color: Color!
}

# Image
type Image implements Element & Attachable & Surface & Selectable & AssetBacked {
  # Intrinsic asset width
  width: Float!

  # Intrinsic asset height
  height: Float!

  # Asset title
  title: String!

  # Original filename, if the asset was uploaded directly by the client (as opposed to from URL)
  filename: String

  # Source URL, if the asset was uploaded via URL
  sourceUrl: String

  # asset url, provided if asset download is allowed and asset format
  preview: ImageAsset
  ingestionState: AssetIngestionState!

  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  attachments(type: [AttachableType!]): [Attachable!]!
  surface: Surface

  # asset url, provided if asset download is allowed and asset format
  asset: ImageAsset!
}

# Legacy Note card
type LegacyNote implements Element & Attachable & Surface & Selectable {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  attachments(type: [AttachableType!]): [Attachable!]!
  surface: Surface
  width: Float!
  height: Float!

  # LegacyNote content
  text: String!
  style: LegacyNoteStyle!
}

type LegacyNoteStyle {
  # Font size in pixels.
  fontSize: Int!
  fontWeight: FontWeight!
  textTransform: TextTransform!
  backgroundColor: Color!
}

# Predefined shape
type Line implements Element & Attachable & Selectable {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  surface: Surface
  start: LinePoint!
  end: LinePoint!
  controlPoints: [LinePoint!]
  routing: LineRouting!
  style: LineStyle!
}

type LineStyle {
  strokeColor: Color!
  strokeStyle: LineStrokeStyle!
  strokeWidth: Float!
  startCap: LineCapStyle!
  endCap: LineCapStyle!
}

# linked document (OneDrive)
type LinkedDocument implements Element & Attachable & Surface & Selectable {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  attachments(type: [AttachableType!]): [Attachable!]!
  surface: Surface
  url: String
  style: LinkedDocumentStyle!
}

type LinkedDocumentStyle {
  width: Float!
  height: Float!
}

# Selection of elements
type Selection implements Element {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  selected: [Element!]!
}

# List of items.
type TextList implements BlockTextContent & ToplevelBlockTextContent {
  align: HorizontalAlign!
  kind: TextListKind!
  items: [TextListItem!]!
}

# Range of text content that starts on a new line and takes up the full width available.
interface BlockTextContent {
  align: HorizontalAlign!
}

enum TextListKind {
  ordered
  bullet
}

# List item nested in a list.
type TextListItem implements BlockTextContent {
  align: HorizontalAlign!

  # Indentation level of a list item, as a non-negative number.
  indent: Int!

  # Structured inline text content.
  content: [InlineTextContentJSON!]!
}

# Inline Text content as JSON, conforming to the GraphQL SDL definition `InlineTextContent`. See the SDL definition for details.
scalar InlineTextContentJSON

# Structured block of text.
type TextBlock implements BlockTextContent & ToplevelBlockTextContent {
  align: HorizontalAlign!

  # Structured inline text content.
  content: [InlineTextContentJSON!]!
}

type RegularShapeStyle implements ShapeStyle {
  width: Float!
  height: Float!
  strokeWidth: Float!
  strokeColor: Color!
  fillColor: Color!
}

interface ShapeStyle {
  width: Float!
  height: Float!
  fillColor: Color!
}

type StickyShapeStyle implements ShapeStyle {
  width: Float!
  fillColor: Color!
  height: Float!
}

# Predefined shape
type Shape implements Element & Attachable & Surface & Selectable {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  attachments(type: [AttachableType!]): [Attachable!]!
  surface: Surface
  style: ShapeStyle!

  # predefined shape geometry
  kind: ShapeKind!

  # text on shape
  text: String
  blocks: [ToplevelBlockTextContent!]
  textStyle: ShapeTextStyle!

  # if true, flip the predefined shape around the X-axis
  mirrorX: Boolean!

  # if true, flip the predefined shape around the Y-axis
  mirrorY: Boolean!

  # if true, the shape will maintain its initial aspect ratio
  aspectRatioFixed: Boolean!
}

# style of text on shape
type ShapeTextStyle {
  # font size in pixels. Set to "auto" to adjust font size to a shape.
  fontSize: FontSize!

  # font family
  fontFamily: String!
  verticalAlign: VerticalAlign!
  color: Color!
}

# freehand stroke
type Stroke implements Element & Attachable & Selectable {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  surface: Surface

  # stroke locations as a list of pairs,
  #   where coordinates are paired '[x, y, x, y, x, y, ...]' in an array,
  #   in the coordinate space of the containing object
  points: [Float!]!
  style: StrokeStyle!
}

type StrokeStyle {
  color: Color!
  strokeWidth: Float!

  # Eraser stroke will be removed in the future. Using Eraser may lead to unexpected results under certain conditions. Use stroke deletion instead of eraser stroke.
  brushType: StrokeBrush!
}

enum StrokeBrush {
  Pen
  Eraser
    @deprecated(
      reason: "Eraser stroke will be removed in the future. Using Eraser may lead to unexpected results under certain conditions. Use stroke deletion instead of eraser stroke."
    )
}

# Rich text.
type Text implements Element & Attachable & Selectable {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  surface: Surface

  # text content of this text element
  text: String!
  style: TextStyle!
  blocks: [ToplevelBlockTextContent!]!
}

type TextStyle {
  textTransform: TextTransform!

  # Font size in pixels.
  fontSize: Int!

  # Font family name.
  fontFamily: String!
  verticalAlign: VerticalAlign!
  color: Color!
  backgroundColor: Color!
  width: Float!
  height: Float!
}

# Video file asset asset
type Video implements Element & Attachable & Surface & Selectable & AssetBacked {
  # Intrinsic asset width
  width: Float!

  # Intrinsic asset height
  height: Float!

  # Asset title
  title: String!

  # Original filename, if the asset was uploaded directly by the client (as opposed to from URL)
  filename: String

  # Source URL, if the asset was uploaded via URL
  sourceUrl: String

  # asset url, provided if asset download is allowed and asset format
  preview: ImageAsset
  ingestionState: AssetIngestionState!

  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  attachments(type: [AttachableType!]): [Attachable!]!
  surface: Surface

  # asset url, provided if asset download is allowed and asset format
  asset: VideoAsset!
}

# Video asset information
type VideoAsset {
  videoFormat: VideoFormat!

  # asset url, provided if asset download is allowed
  url(scale: AssetScale): String
}

enum VideoFormat {
  mkv
  avi
  flv
  wmv
  mp4
  webm
  quicktime
  unknown
}

# whiteboard
type Whiteboard implements Element & Attachable & Surface & Selectable {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  attachments(type: [AttachableType!]): [Attachable!]!
  surface: Surface
  style: WhiteboardStyle!
  preview: String
}

type WhiteboardStyle {
  width: Float!
  height: Float!
}

# Generic rectangular element with possibly custom content
type Window implements Element & Attachable & Surface & Selectable {
  # Workspace-unique element id
  id: ID!

  # Stack order, an element with a higher stack order is in front of a lower stack order
  zIndex: Int!
  transform: Transform!

  # If true, element will be "pinned" and immovable in the workspace
  pinned: Boolean!
  comments: [Comment!]!
  boundingBox: Box!

  # additional element properties specified using JSON-LD
  traits(
    # If present, shape the output using a JSON-LD frame constructed from content, context and vocab.
    content: JSONObject

    # JSON-LD context to use to compact the output. If framing, also used to construct the frame.
    context: JSON

    # Common prefix to use to compact the output. If framing, also used to construct or augment the context of the frame.
    vocab: String

    # If framing, include only the properties specified in the frame.
    explicit: Boolean = false
  ): JSON
  attachments(type: [AttachableType!]): [Attachable!]!
  surface: Surface
  style: WindowStyle!
}

type WindowStyle {
  # Extrinsic window width
  width: Float!

  # Extrinsic window height
  height: Float!
}

type CreateElementCommand implements Command & HistoryCommand {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!

  # Unique idenfitier of the client instance issuing the command
  clientId: ID!
  element: Element!
}

interface Command {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!
}

interface HistoryCommand {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!

  # Unique idenfitier of the client instance issuing the command
  clientId: ID!
}

type UpdateElementCommand implements Command & HistoryCommand {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!

  # Unique idenfitier of the client instance issuing the command
  clientId: ID!

  # Workspace-unique element id
  elementId: ID!
  data: UpdateElement!
}

type DeleteElementCommand implements Command & HistoryCommand {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!

  # Unique idenfitier of the client instance issuing the command
  clientId: ID!

  # Workspace-unique element id
  elementId: ID!
  elementType: ElementType!
}

# Element type
enum ElementType {
  Text
  LegacyNote
  Icon
  Image
  Document
  Grid
  Browser
  Video
  Stroke
  Shape
  Line
  LinkedDocument
  Canvas
  Selection
  Window
  Whiteboard
}

type UpdateTraitsCommand implements Command & HistoryCommand {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!

  # Unique idenfitier of the client instance issuing the command
  clientId: ID!

  # Workspace-unique element id
  elementId: ID!
  elementType: ElementType!

  # JSON-LD-conforming document representing arbitrary persistent metadata of the element
  traits: JSONObject!
}

type CreateCommentCommand implements Command & HistoryCommand {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!

  # Unique idenfitier of the client instance issuing the command
  clientId: ID!

  # Workspace-unique element id
  elementId: ID!
  elementType: ElementType!
  comment: Comment!
}

type AttachCommand implements Command & HistoryCommand & AdhesionCommand {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!

  # Unique idenfitier of the client instance issuing the command
  clientId: ID!

  # id of attachable element
  elementId: ID!
  zIndex: Int
  transform: Transform
  elementType: ElementType!

  # id of the target surface
  surfaceId: String
}

interface AdhesionCommand {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!

  # Unique idenfitier of the client instance issuing the command
  clientId: ID!

  # id of attachable element
  elementId: ID!
  zIndex: Int
  transform: Transform
  elementType: ElementType!
}

type DetachCommand implements Command & HistoryCommand & AdhesionCommand {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!

  # Unique idenfitier of the client instance issuing the command
  clientId: ID!

  # id of attachable element
  elementId: ID!
  zIndex: Int
  transform: Transform
  elementType: ElementType!
}

type UploadAssetCommand implements Command & HistoryCommand {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!

  # Unique idenfitier of the client instance issuing the command
  clientId: ID!

  # Workspace-unique element id
  elementId: ID!
  elementType: ElementType!
  ingestionState: AssetIngestionState!

  # JSON-LD-conforming document representing arbitrary persistent metadata of the element
  traits: JSONObject
}

type UpdateWorkspaceCommand implements Command & HistoryCommand {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!

  # Unique idenfitier of the client instance issuing the command
  clientId: ID!
  style: UpdateWorkspaceStyle
}

type UpdateWorkspaceStyle {
  backgroundTheme: BackgroundTheme
}

# one of dark, light
enum BackgroundTheme {
  dark
  light
}

type WorkspaceState {
  # a cursor ID for commands subscription
  cursor: ID!
  style: WorkspaceStyle!
  elements: [Element!]!
}

type WorkspaceStyle {
  backgroundTheme: BackgroundTheme!
}

# Open-ended metadata properties attached to an element, based on JSON-LD
input TraitInput {
  # JSON-LD context specified as a JSON object, an URL pointing to the location of a JSON-LD context document, or an array of either
  context: JSON

  # JSON-LD document describing element traits
  content: JSONObject!

  # Common prefix used to expand short property names to URIs, whenever a more specific expansion is not defined in the context.
  vocab: String
}

input Viewport {
  x: Float!
  y: Float!
  width: Float!
  height: Float!
}

# Bounding box of an element, relative to the origin
input BoxInput {
  # x-coordinate of the top left corner
  x: Float = 0

  # y-coordinate of the top left corner
  y: Float = 0

  # width
  width: Float = 0

  # height
  height: Float = 0
}

# Find Availabile Area search order direction
enum FindAvailableAreaDirection {
  left
  right
  up
  down
}

type LibrariesPaged {
  results: [IconLibrary!]!
  next: String
  prev: String
  totalItems: Int
}

type IconLibrary {
  name: String!
  categories: [IconCategory!]!
  categoryCount: Int!
  iconCount: Int!
}

type IconCategory {
  name: String!
  availableVariantNames: [String!]!
  iconCount: Int!
  icons: [IconInfo!]!
}

type IconInfo {
  name: String!
  libraryName: String!
  categoryName: String!
  variant: IconVariant!
  availableVariants: [IconVariant!]!
  aspectRatio: Float!
}

type IconVariant {
  name: String
  assetPath: String
}

type IconsPaged {
  results: [IconInfo!]!
  next: String
  prev: String
  totalItems: Int
}

input TransferCompleteInput {
  errorCode: String
  errorMessage: String
  multipartUploadId: String
}

type UpdateWorkspaceStyleResponse {
  # id of modified workspace.
  workspaceId: String!
}

input UpdateWorkspaceStyleInput {
  backgroundTheme: BackgroundTheme
}

# Comment creation input.
input CommentInput {
  blocks: [CommentBlockInput!]!

  # Parent comment id.
  parentId: String

  # JSON-LD-conforming document representing arbitrary persistent metadata of the comment.
  traits: JSONObject
}

# Comment block input
input CommentBlockInput {
  content: [InlineCommentContent!]!
}

# Input union of either plain text or mention.
input InlineCommentContent {
  mention: TextMention

  # Plain text content. Newline characters are ignored.
  text: String
}

# User, group or all workspace collaborators mention.
input TextMention {
  # User or group id. Must be absent or `null` if `.targetType` is `all`.
  targetId: String
  targetType: MentionTargetType!
}

enum MentionTargetType {
  group
  user
  all
}

input CreateCanvasInput {
  traits: TraitInput
  pinned: Boolean = false
  zIndex: Int
  transform: TranslationInput = { x: 0, y: 0 }
  style: CanvasStyleInput
  name: String!
}

# translation relative to origin
input TranslationInput {
  # x coordinate
  x: Float = 0

  # y coordinate
  y: Float = 0
}

input CanvasStyleInput {
  width: Float = 1000
  height: Float = 1000

  # Beta (now accepts any RGBA color): This is a Beta feature that is still in development, the documentation and features are subject to change before their GA release. We welcome any feedback you may have that we can use to improve the final version. While we will do our best to communicate breaking changes, think careful about where you deploy integrations using them.
  borderColor: ColorInput = { r: 238, g: 85, b: 80, a: 1 }

  # Beta: This is a Beta feature that is still in development, the documentation and features are subject to change before their GA release. We welcome any feedback you may have that we can use to improve the final version. While we will do our best to communicate breaking changes, think careful about where you deploy integrations using them.
  fillColor: ColorInput = { r: 0, g: 0, b: 0, a: 0 }

  # Beta: This is a Beta feature that is still in development, the documentation and features are subject to change before their GA release. We welcome any feedback you may have that we can use to improve the final version. While we will do our best to communicate breaking changes, think careful about where you deploy integrations using them.
  showName: Boolean = false
}

type UpdateElementResponse {
  id: String!
}

input CreateStrokeInput {
  traits: TraitInput
  pinned: Boolean = false
  zIndex: Int

  # Id of the surface to which this element is attached
  surface: String
  transform: SimilitudeInput = { x: 0, y: 0, scale: 1 }
  style: StrokeStyleInput
  points: [Float!]!
}

# translation relative to origin and uniform scaling. The object is translated and then scaled with the origin at the top left corner of its bounding box
input SimilitudeInput {
  # x coordinate
  x: Float = 0

  # y coordinate
  y: Float = 0

  # uniform scaling factor
  scale: Float = 1
}

input StrokeStyleInput {
  color: ColorInput = { r: 255, g: 255, b: 255, a: 1 }
  strokeWidth: Float = 1

  # Eraser stroke will be removed in the future. Using Eraser may lead to unexpected results under certain conditions. Use stroke deletion instead of eraser stroke.
  brushType: StrokeBrush = Pen
}

input CreateTextInput {
  traits: TraitInput
  pinned: Boolean = false
  zIndex: Int
  surface: String
  transform: TransformInput = { x: 0, y: 0, scaleX: 1, scaleY: 1 }
  style: TextStyleInput

  # Plain multiline text, exclusive with `.blocks`. A shorthand alternative for producing a sequence of left-aligned blocks of text with no additional styling.
  text: String

  # A list of blocks of structured text content, exclusive with `.text`.
  blocks: [ToplevelBlockTextContentInput!]
}

# translation relative to origin and scaling. The object is translated and then scaled with the origin at the top left corner of its bounding box
input TransformInput {
  # x coordinate
  x: Float = 0

  # y coordinate
  y: Float = 0

  # x-coordinate scaling factor
  scaleX: Float = 1

  # y-coordinate scaling factor
  scaleY: Float = 1
}

input TextStyleInput {
  textTransform: TextTransform = none

  # Font size in pixels.
  fontSize: Int = 64

  # Font family name.
  fontFamily: String = "Dosis"
  verticalAlign: VerticalAlign = top
  color: ColorInput = { r: 255, g: 255, b: 255, a: 1 }
  backgroundColor: ColorInput = { r: 0, g: 0, b: 0, a: 0 }

  # if omitted, width will be computed based on text content
  width: Float

  # if omitted, height will be computed based on text content
  height: Float
}

# Input union of block text content input.
input ToplevelBlockTextContentInput {
  block: TextBlockInput
  list: TextListInput

  # Plain text. A shorthand alternative to the `.block` property, producing a single, left-aligned block of text with no additional styling. Newlines are ignored.
  text: String
}

# Structured block of text.
input TextBlockInput {
  align: HorizontalAlign

  # Plain text, exclusive with `.content`. A shorthand alternative to specifying block content, producing a single, left-aligned block of text with no additional styling. Newlines are ignored.
  text: String

  # Structured inline text content, exclusive with `.text`.
  content: [InlineTextContent!]
}

# Input union of inline text content input.
input InlineTextContent {
  link: TextLink
  text: String
  span: TextSpan
}

input TextLink {
  url: String!

  # Plain text, exclusive with `.content`. A shorthand alternative to specifying inline content, producing a single range of text with no additional styling. Newlines are ignored.
  text: String

  # Structured inline text content, exclusive with `.text`.
  content: [InlineTextContent!]
}

# Adds attributes to nested text content.
input TextSpan {
  # Font family name.
  fontFamily: String

  # Font size in pixels.
  fontSize: Int

  # Normal or bold font weight. If absent, implies that the actual value is inherited from ancestor spans, or `normal` if no ancestor specifies it.
  fontWeight: FontWeight

  # Normal or italic font style. If absent, implies that the actual value is inherited from ancestor spans, or `normal` if no ancestor specifies it.
  fontStyle: FontStyle
  textDecoration: [TextDecoration!]
  color: ColorInput
  backgroundColor: ColorInput

  # Plain text, exclusive with `.content`. A shorthand alternative to specifying inline content, producing a single range of text with no additional styling. Newlines are ignored.
  text: String

  # Structured inline text content, exclusive with `.text`.
  content: [InlineTextContent!]
}

# Italicization.
enum FontStyle {
  normal
  italic
}

# Appearance of decorative lines on text.
enum TextDecoration {
  underline
  lineThrough
}

# List of items.
input TextListInput {
  kind: TextListKind!
  items: [TextListItemInput!]!
}

input TextListItemInput {
  # Indentation level of a list item, as a non-negative number.
  indent: Int = 0

  # Plain text, exclusive with `.content`. A shorthand alternative to specifying block content, producing a single, left-aligned block of text with no additional styling. Newlines are ignored.
  text: String

  # Structured inline text content, exclusive with `.text`.
  content: [InlineTextContent!]
}

input UpdateTextInput {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateTransformInput

  # Plain multiline text, exclusive with `.blocks`. A shorthand alternative for producing a sequence of left-aligned blocks of text with no additional styling.
  text: String

  # A list of blocks of structured text content, exclusive with `.text`.
  blocks: [ToplevelBlockTextContentInput!]
  style: UpdateTextStyleInput
}

# translation relative to origin and scaling. The object is translated and then scaled with the origin at the top left corner of its bounding box
input UpdateTransformInput {
  # x coordinate
  x: Float

  # y coordinate
  y: Float

  # x-coordinate scaling factor
  scaleX: Float

  # y-coordinate scaling factor
  scaleY: Float
}

input UpdateTextStyleInput {
  width: Float
  height: Float
  fontSize: Int

  # Font family name.
  fontFamily: String
  color: ColorInput
  backgroundColor: ColorInput
  verticalAlign: VerticalAlign
}

input CreateWindowInput {
  traits: TraitInput
  pinned: Boolean = false
  zIndex: Int
  surface: String
  transform: SimilitudeInput = { x: 0, y: 0, scale: 1 }
  style: WindowStyleInput
}

input WindowStyleInput {
  # Extrinsic window width
  width: Float = 0

  # Extrinsic window height
  height: Float = 0
}

input CreateGridInput {
  traits: TraitInput
  pinned: Boolean = false
  zIndex: Int
  transform: TranslationInput = { x: 0, y: 0 }
  style: GridStyleInput
  rowCount: Int = 5
  columnCount: Int = 5
  cells: [CellInput!]!
}

input GridStyleInput {
  horizontalCellMargin: Float = 5
  verticalCellMargin: Float = 5
  cellWidth: Float = 1000
  cellHeight: Float = 1000
}

# Return value for the creation of a video call.
type CreateVideoResponse {
  # Upload form data for use when uploading asset to storage. If the input has provided a sourceUrl instead, this field will be null.
  content: UploadData

  # Upload form data for use when uploading asset preview to storage. If the input has provided a sourceUrl instead, this field will be null.
  preview: UploadData

  # Video entity that has been created.
  video: Video!
}

# Describes data about how to upload something to storage (an image, a document, a video preview image, etc)
type UploadData {
  # upload ID
  uploadId: String!

  # URL for uploading asset data, valid for a limited time
  url: String!

  # POST form data to supply on upload
  fields: JSONObject!
}

# If the dimensions of the asset to be uploaded are known and are provided as width/height the transform can be used to position and scale the asset. If the dimensions of the asset to be uploaded are unknown then width and height will specify the bounding box for the asset, and the transform will be used to position and or scale it. Once uploaded, the asset will be positioned in the center of the bounding box and scaled to fit it.
input CreateVideoInput {
  traits: TraitInput
  pinned: Boolean = false
  zIndex: Int
  surface: String

  # The transform of an asset bounding box. The asset position, size and scale may be automatically adjusted once the asset is uploaded.
  transform: SimilitudeInput = { x: 0, y: 0, scale: 1 }

  # Original filename of the uploaded asset, without a path. Do not use this field if you are doing an upload by URL.
  filename: String

  # URL of the source data of an image. This is optional; either the client can perform the upload to storage (typically for locally stored assets) and not provide this url or, given this url, the system will perform the upload (typically signed urls for cloud stored data).
  sourceUrl: String
  title: String

  # The width of a bounding box that an asset should fit into.
  width: Float = 1000

  # The height of a bounding box that an asset should fit into.
  height: Float = 1000

  # Format type of preview image (optional).
  previewFormat: ImageFormatInput
  videoFormat: VideoFormatInput!
}

enum ImageFormatInput {
  jpeg
  jpg
  gif
  png
  tiff
  tif
  jpegMime
  gifMime
  pngMime
  tiffMime
}

enum VideoFormatInput {
  mkv
  avi
  flv
  wmv
  mp4
  mov
  m4v
  webm
  webmMime
  quicktime
  mp4Mime
  m4vMime
  quicktimeMime
}

input CreateBrowserInput {
  traits: TraitInput
  pinned: Boolean = false
  zIndex: Int
  surface: String
  transform: SimilitudeInput = { x: 0, y: 0, scale: 1 }
  style: BrowserStyleInput
  url: String
}

input BrowserStyleInput {
  frameless: Boolean = false
  width: Float = 800
  height: Float = 600
}

# Return value for the creation of an image call.
type CreateImageResponse {
  # Upload form data for use when uploading asset to storage. If the input has provided a sourceUrl instead, this field will be null.
  content: UploadData

  # Upload form data for use when uploading asset preview to storage. If the input has provided a sourceUrl instead, this field will be null.
  preview: UploadData

  # Image entity that has been created.
  image: Image!
}

# If the dimensions of the asset to be uploaded are known and are provided as width/height the transform can be used to position and scale the asset. If the dimensions of the asset to be uploaded are unknown then width and height will specify the bounding box for the asset, and the transform will be used to position and or scale it. Once uploaded, the asset will be positioned in the center of the bounding box and scaled to fit it.
input CreateImageInput {
  traits: TraitInput
  pinned: Boolean = false
  zIndex: Int
  surface: String

  # The transform of an asset bounding box. The asset position, size and scale may be automatically adjusted once the asset is uploaded.
  transform: SimilitudeInput = { x: 0, y: 0, scale: 1 }

  # Original filename of the uploaded asset, without a path. Do not use this field if you are doing an upload by URL.
  filename: String

  # URL of the source data of an image. This is optional; either the client can perform the upload to storage (typically for locally stored assets) and not provide this url or, given this url, the system will perform the upload (typically signed urls for cloud stored data).
  sourceUrl: String
  title: String

  # The width of a bounding box that an asset should fit into.
  width: Float = 1000

  # The height of a bounding box that an asset should fit into.
  height: Float = 1000

  # Format type of preview image (optional).
  previewFormat: ImageFormatInput
  imageFormat: ImageFormatInput!
}

# Return value for the creation of a document call.
type CreateDocumentResponse {
  # Upload form data for use when uploading asset to storage. If the input has provided a sourceUrl instead, this field will be null.
  content: UploadData

  # Upload form data for use when uploading asset preview to storage. If the input has provided a sourceUrl instead, this field will be null.
  preview: UploadData

  # Document entity that has been created.
  document: Document!
}

# If the dimensions of the asset to be uploaded are known and are provided as width/height the transform can be used to position and scale the asset. If the dimensions of the asset to be uploaded are unknown then width and height will specify the bounding box for the asset, and the transform will be used to position and or scale it. Once uploaded, the asset will be positioned in the center of the bounding box and scaled to fit it.
input CreateDocumentInput {
  traits: TraitInput
  pinned: Boolean = false
  zIndex: Int
  surface: String

  # The transform of an asset bounding box. The asset position, size and scale may be automatically adjusted once the asset is uploaded.
  transform: SimilitudeInput = { x: 0, y: 0, scale: 1 }

  # Original filename of the uploaded asset, without a path. Do not use this field if you are doing an upload by URL.
  filename: String

  # URL of the source data of an image. This is optional; either the client can perform the upload to storage (typically for locally stored assets) and not provide this url or, given this url, the system will perform the upload (typically signed urls for cloud stored data).
  sourceUrl: String
  title: String

  # The width of a bounding box that an asset should fit into.
  width: Float = 1000

  # The height of a bounding box that an asset should fit into.
  height: Float = 1000

  # Format type of preview image (optional).
  previewFormat: ImageFormatInput
  documentFormat: DocumentFormatInput!
}

enum DocumentFormatInput {
  doc
  docx
  ppt
  pptx
  xls
  xlsx
  pdf
  docMime
  docxMime
  pptMime
  pptxMime
  xlsMime
  xlsxMime
  pdfMime
}

input CreateShapeInput {
  traits: TraitInput
  pinned: Boolean = false
  zIndex: Int
  surface: String
  transform: TranslationInput = { x: 0, y: 0 }
  style: ShapeStyleInputUnion!

  # text on shape
  text: String

  # Structured text content on shape, exclusive with `.text`.
  blocks: [ToplevelBlockTextContentInput!]
  textStyle: ShapeTextStyleInput
  mirrorX: Boolean = false
  mirrorY: Boolean = false
}

# Input union of shape styles.
input ShapeStyleInputUnion {
  regularShape: RegularShapeStyleInput
  stickyShape: StickyShapeStyleInput
}

input RegularShapeStyleInput {
  width: Float = 600
  height: Float = 600
  strokeWidth: Float = 8
  strokeColor: ColorInput = { r: 255, g: 255, b: 255, a: 1 }
  fillColor: ColorInput = { r: 0, g: 0, b: 0, a: 1 }

  # predefined shape geometry
  kind: RegularShapeKind!
}

enum RegularShapeKind {
  Rectangle
  Ellipse
  TriangleUp
  TriangleRight
  Diamond
  Cylinder
  ArrowUp
  ArrowRight
  ArrowUpDown
  ArrowLeftRight
  ArrowAll
  Star5
  Hexagon
  Octagon
}

# Sticky shapes have a fixed aspect ratio. The height will be calculated based on the width
input StickyShapeStyleInput {
  width: Float = 600
  fillColor: ColorInput = { r: 0, g: 0, b: 0, a: 1 }

  # predefined shape geometry
  kind: StickyShapeKind!
}

enum StickyShapeKind {
  StickySquare
}

# style of text on shape
input ShapeTextStyleInput {
  # font size in pixels. Set to "auto" to adjust font size to a shape.
  fontSize: FontSize = "auto"

  # font family
  fontFamily: String = "Noto Sans"
  verticalAlign: VerticalAlign = center
  color: ColorInput = { r: 255, g: 255, b: 255, a: 1 }
}

input UpdateShapeInput {
  pinned: Boolean
  zIndex: Int
  surface: String
  transform: UpdateTranslationInput
  style: UpdateShapeStyleInputUnion

  # text on shape
  text: String

  # Structured text content on shape, exclusive with `.text`.
  blocks: [ToplevelBlockTextContentInput!]
  textStyle: UpdateShapeTextStyleInput
  mirrorX: Boolean
  mirrorY: Boolean
}

# Input union of shape styles.
input UpdateShapeStyleInputUnion {
  regularShape: UpdateRegularShapeStyleInput
  stickyShape: UpdateStickyShapeStyleInput
}

input UpdateRegularShapeStyleInput {
  width: Float
  height: Float
  strokeWidth: Float
  strokeColor: ColorInput
  fillColor: ColorInput

  # predefined shape geometry
  kind: RegularShapeKind
}

# Sticky shapes have a fixed aspect ratio. The height will be calculated based on the width
input UpdateStickyShapeStyleInput {
  width: Float
  fillColor: ColorInput

  # predefined shape geometry
  kind: StickyShapeKind
}

input UpdateShapeTextStyleInput {
  # font size in pixels. Set to "auto" to adjust font size to a shape.
  fontSize: FontSize

  # font family
  fontFamily: String
  verticalAlign: VerticalAlign
  color: ColorInput
}

input CreateLineInput {
  traits: TraitInput
  pinned: Boolean = false
  zIndex: Int
  surface: String
  style: LineStyleInput
  routing: LineRouting = Direct
  controlPoints: [LinePointInput!]
  start: LinePointInput!
  end: LinePointInput!
}

input LineStyleInput {
  strokeColor: ColorInput = { r: 255, g: 255, b: 255, a: 1 }
  strokeStyle: LineStrokeStyle = Solid
  strokeWidth: Float = 0
  startCap: LineCapStyle = None
  endCap: LineCapStyle = None
}

input LinePointInput {
  anchor: AnchorLinePointInput
  absolute: AbsoluteLinePointInput
}

input AnchorLinePointInput {
  # element ID of anchor
  id: String!

  # position along element's horizontal
  u: Float!

  # position along element's vertical
  v: Float!
}

input AbsoluteLinePointInput {
  # workspace x coordinate
  x: Float = 0

  # workspace y coordinate
  y: Float = 0
}

input UpdateLineInput {
  pinned: Boolean
  zIndex: Int
  surface: String
  style: UpdateLineStyleInput
  routing: LineRouting
  controlPoints: [LinePointInput!]
  start: LinePointInput
  end: LinePointInput
}

input UpdateLineStyleInput {
  strokeColor: ColorInput
  strokeStyle: LineStrokeStyle
  strokeWidth: Float
  startCap: LineCapStyle
  endCap: LineCapStyle
}

# If the dimensions of the icon to be created are known and are provided as width/height the transform can be used to position and scale the asset. If the aspect ratio of the input width and height are not the same as the desired aspect ratio, the width and height will be scaled accordingly. Once created, the icon will be positioned in the center of the bounding box and scaled to fit it.
input CreateIconInput {
  traits: TraitInput
  pinned: Boolean = false
  zIndex: Int
  surface: String
  transform: SimilitudeInput = { x: 0, y: 0, scale: 1 }

  # Defines the width of the bounding box that the icon should fit into
  width: Float = 300

  # Defines the height of the bounding box that the icon should fit into
  height: Float = 300
  style: IconStyleInput
  assetPath: String!
}

input IconStyleInput {
  color: ColorInput = { r: 0, g: 0, b: 0, a: 1 }
}

type RawCommand implements Command {
  workspaceId: ID!

  # a cursor ID for the next commands subscription
  cursor: ID!

  # identity of the principal performing the command
  actorId: ID!
  actorType: String!
  data: JSON!
}
